! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine base_mlbddc_set_state_start(this)
  class(base_mlbddc_t), intent(inout) :: this
  this%state = BASE_MLBDDC_STATE_START
end subroutine base_mlbddc_set_state_start

subroutine base_mlbddc_set_state_created(this)
  class(base_mlbddc_t), intent(inout) :: this
  this%state = BASE_MLBDDC_STATE_CREATED
end subroutine base_mlbddc_set_state_created

subroutine base_mlbddc_set_state_symbolic(this)
  class(base_mlbddc_t), intent(inout) :: this
  this%state = BASE_MLBDDC_STATE_SYMBOLIC
end subroutine base_mlbddc_set_state_symbolic

subroutine base_mlbddc_set_state_numeric(this)
  class(base_mlbddc_t), intent(inout) :: this
  this%state = BASE_MLBDDC_STATE_NUMERIC
end subroutine base_mlbddc_set_state_numeric

function base_mlbddc_state_is_start(this) result(is_start)
  class(base_mlbddc_t), intent(in) :: this
  logical                                 :: is_start
  is_start = this%state == BASE_MLBDDC_STATE_START
end function base_mlbddc_state_is_start

function base_mlbddc_state_is_created(this) result(is_start)
  class(base_mlbddc_t), intent(in) :: this
  logical                                 :: is_start
  is_start = this%state == BASE_MLBDDC_STATE_CREATED
end function base_mlbddc_state_is_created

function base_mlbddc_state_is_symbolic(this) result(is_symbolic_setup)
  class(base_mlbddc_t), intent(in) :: this
  logical                                 :: is_symbolic_setup
  is_symbolic_setup = this%state == BASE_MLBDDC_STATE_SYMBOLIC
end function base_mlbddc_state_is_symbolic

function base_mlbddc_state_is_numeric(this) result(is_numerical_setup)
  class(base_mlbddc_t), intent(in) :: this
  logical                                 :: is_numerical_setup
  is_numerical_setup= this%state == BASE_MLBDDC_STATE_NUMERIC
end function base_mlbddc_state_is_numeric

subroutine base_mlbddc_assert_dirichlet_solver_params ( this )
  implicit none
  class(base_mlbddc_t), intent(in) :: this
  assert ( associated(this%mlbddc_params) )
  assert ( this%mlbddc_params%isPresent(Key=mlbddc_dirichlet_solver_params) ) 
  assert ( this%mlbddc_params%isSubList(Key=mlbddc_dirichlet_solver_params) ) 
end subroutine base_mlbddc_assert_dirichlet_solver_params 

subroutine base_mlbddc_assert_neumann_solver_params ( this )
  implicit none
  class(base_mlbddc_t), intent(in) :: this
  assert ( associated(this%mlbddc_params) )
  assert ( this%mlbddc_params%isPresent(Key=mlbddc_neumann_solver_params) ) 
  assert ( this%mlbddc_params%isSubList(Key=mlbddc_neumann_solver_params) ) 
end subroutine base_mlbddc_assert_neumann_solver_params 

subroutine base_mlbddc_parse_or_transfer_coarse_matrix_params ( this, &
                                                                coarse_matrix_symmetric_storage, &
                                                                coarse_matrix_is_symmetric, &
                                                                coarse_matrix_sign  )
  implicit none
  class(base_mlbddc_t), intent(in)    :: this
  logical             , intent(inout) :: coarse_matrix_symmetric_storage
  logical             , intent(inout) :: coarse_matrix_is_symmetric
  integer(ip)         , intent(inout) :: coarse_matrix_sign
  
  integer(ip) :: ierr
  type(ParameterList_t), pointer :: coarse_matrix_params
  type(par_sparse_matrix_t), pointer :: par_sparse_matrix
  
  assert ( associated(this%mlbddc_params) )
  assert ( associated(this%environment) )
  if ( this%mlbddc_params%isPresent(Key=mlbddc_coarse_matrix_params) ) then
    assert ( this%mlbddc_params%isSubList(Key=mlbddc_coarse_matrix_params) )
    ierr = this%mlbddc_params%getSubList(Key     = mlbddc_coarse_matrix_params, & 
                                         SubList = coarse_matrix_params) 
    assert(ierr==0)
#ifdef DEBUG
    assert(coarse_matrix_params%isPresent(mlbddc_coarse_matrix_symmetric_storage))
    assert(coarse_matrix_params%isAssignable(mlbddc_coarse_matrix_symmetric_storage, coarse_matrix_symmetric_storage))
    assert(coarse_matrix_params%isPresent(mlbddc_coarse_matrix_is_symmetric))
    assert(coarse_matrix_params%isAssignable(mlbddc_coarse_matrix_is_symmetric, coarse_matrix_is_symmetric))
    assert(coarse_matrix_params%isPresent(mlbddc_coarse_matrix_sign))
    assert(coarse_matrix_params%isAssignable(mlbddc_coarse_matrix_sign, coarse_matrix_sign))
#endif 
    ierr = coarse_matrix_params%Get(Key=mlbddc_coarse_matrix_symmetric_storage, Value=coarse_matrix_symmetric_storage)
    assert(ierr == 0)
    ierr = coarse_matrix_params%Get(Key=mlbddc_coarse_matrix_is_symmetric, Value=coarse_matrix_is_symmetric)
    assert(ierr == 0)
    ierr = coarse_matrix_params%Get(Key=mlbddc_coarse_matrix_sign, Value=coarse_matrix_sign)
    assert(ierr == 0)
  else
     if ( this%environment%am_i_l1_to_l2_task() ) then
        if ( this%environment%am_i_l1_task() ) then
           par_sparse_matrix => this%get_par_sparse_matrix()
           coarse_matrix_symmetric_storage = par_sparse_matrix%get_symmetric_storage()
           coarse_matrix_is_symmetric      = par_sparse_matrix%is_symmetric()
           coarse_matrix_sign              = par_sparse_matrix%get_sign()
        end if

        if ( this%environment%am_i_l1_to_l2_root() ) then
           ! Recv side
           call this%environment%l1_to_l2_transfer(input_data=coarse_matrix_symmetric_storage, &
                output_data=coarse_matrix_symmetric_storage)
           call this%environment%l1_to_l2_transfer(input_data=coarse_matrix_is_symmetric, &
                output_data=coarse_matrix_is_symmetric)
           call this%environment%l1_to_l2_transfer(input_data=coarse_matrix_sign, &
                output_data=coarse_matrix_sign)
        else
           ! Send. side
           call this%environment%l1_to_l2_transfer(input_data=coarse_matrix_symmetric_storage, &
                output_data=coarse_matrix_symmetric_storage)
           call this%environment%l1_to_l2_transfer(input_data=coarse_matrix_is_symmetric, &
                output_data=coarse_matrix_is_symmetric)
           call this%environment%l1_to_l2_transfer(input_data=coarse_matrix_sign, &
                output_data=coarse_matrix_sign)
        end if
     end if
  end if
end subroutine base_mlbddc_parse_or_transfer_coarse_matrix_params





subroutine base_mlbddc_assert_coarse_solver_params ( this )
  implicit none
  class(base_mlbddc_t), intent(in) :: this
  assert ( associated(this%mlbddc_params) )
  assert ( this%mlbddc_params%isPresent(Key=mlbddc_coarse_solver_params) ) 
  assert ( this%mlbddc_params%isSubList(Key=mlbddc_coarse_solver_params) ) 
end subroutine base_mlbddc_assert_coarse_solver_params 

recursive subroutine base_mlbddc_symbolic_setup ( this )
  implicit none
  class(base_mlbddc_t), intent(inout) :: this
  type(environment_t), pointer :: par_environment  
  par_environment => this%get_par_environment()
  
  assert ( this%state_is_created() .or. this%state_is_symbolic() .or. this%state_is_numeric() )
  
  if ( this%state_is_created() ) then
    if( par_environment%am_i_l1_task() ) then
      if ( par_environment%get_l1_size() > 1 ) then
        call this%setup_constraint_matrix()
        call this%setup_weighting_operator()
      end if
    end if

    call this%symbolic_setup_coarse_grid_matrix()
    call this%symbolic_setup_mlbddc_coarse()

    if ( par_environment%am_i_l1_task() ) then
      if ( par_environment%get_l1_size() > 1 ) then      
        call this%symbolic_setup_dirichlet_problem()
        call this%symbolic_setup_dirichlet_solver()
        call this%symbolic_setup_constrained_neumann_problem()
        call this%symbolic_setup_constrained_neumann_solver()
      else
        call this%symbolic_setup_coarse_solver()
      end if
    end if
    call this%set_state_symbolic()
    ! In the case the call to this subroutine is triggered by 
    ! "this%update_matrix(same_nonzero_pattern=.false.)" it might be
    ! necessary to re-generate vector spaces associated to this. 
    ! Provided that we do not know who triggered this subroutine, 
    ! and that the computational time spent here is not significant, 
    ! we always regenerate vector spaces right before returning control
    ! from a call to symbolic_setup
    call this%create_vector_spaces()
  end if
end subroutine base_mlbddc_symbolic_setup

subroutine base_mlbddc_setup_constraint_matrix (this)
  implicit none
  class(base_mlbddc_t), intent(inout) :: this
  assert(.false.)
end subroutine base_mlbddc_setup_constraint_matrix

subroutine base_mlbddc_setup_weighting_operator (this)
  implicit none
  class(base_mlbddc_t), intent(inout) :: this
  assert(.false.)
end subroutine base_mlbddc_setup_weighting_operator

subroutine base_mlbddc_symbolic_setup_dirichlet_problem ( this) 
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  class(base_fe_space_t)      , pointer       :: fe_space
  type(par_sparse_matrix_t) , pointer       :: par_sparse_matrix
  type(sparse_matrix_t)     , pointer       :: A

  assert ( this%am_i_l1_task() )
  fe_space => this%get_fe_space()
  par_sparse_matrix => this%get_par_sparse_matrix()
  A => par_sparse_matrix%get_sparse_matrix()
  if ( A%get_symmetric_storage() ) then
     call A%split_2x2_symbolic( num_row = fe_space%get_block_num_interior_dofs(1), &
          num_col = fe_space%get_block_num_interior_dofs(1), &
          A_II    = this%A_II, &
          A_IG    = this%A_IG, &
          A_GG    = this%A_GG)
  else
     call A%split_2x2_symbolic( num_row = fe_space%get_block_num_interior_dofs(1), &
          num_col = fe_space%get_block_num_interior_dofs(1), &
          A_II    = this%A_II, &
          A_IG    = this%A_IG, &
          A_GI    = this%A_GI, &
          A_GG    = this%A_GG)
  end if
end subroutine base_mlbddc_symbolic_setup_dirichlet_problem

subroutine base_mlbddc_symbolic_setup_dirichlet_solver (this) 
  implicit none
  class(base_mlbddc_t), intent(inout) :: this
  type(ParameterList_t), pointer :: dirichlet_solver_params 
  integer(ip) :: ierror

  assert ( this%am_i_l1_task() )
  call this%assert_dirichlet_solver_params()

  ierror = this%mlbddc_params%getSubList(Key=mlbddc_dirichlet_solver_params, & 
                                         SubList=dirichlet_solver_params) 
  assert(ierror==0)

  call this%dirichlet_solver%set_type_from_pl(dirichlet_solver_params)
  call this%dirichlet_solver%set_parameters_from_pl(dirichlet_solver_params)
  call this%dirichlet_solver%set_matrix(matrix = this%A_II)
  call this%dirichlet_solver%symbolic_setup() 
end subroutine base_mlbddc_symbolic_setup_dirichlet_solver

subroutine base_mlbddc_symbolic_setup_constrained_neumann_problem(this)
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  type(environment_t)   , pointer       :: par_environment
  type(par_sparse_matrix_t) , pointer       :: par_sparse_matrix
  type(sparse_matrix_t)     , pointer       :: A

  assert ( this%am_i_l1_task() )
  par_sparse_matrix => this%get_par_sparse_matrix()
  A => par_sparse_matrix%get_sparse_matrix()

  call A%expand_matrix_symbolic(C_T               = this%constraint_matrix, &
       to                = this%constrained_neumann_matrix, &
       symmetric_storage = A%get_symmetric_storage(), & 
       symmetric         = A%is_symmetric(), &
       sign              = SPARSE_MATRIX_SIGN_INDEFINITE)

end subroutine base_mlbddc_symbolic_setup_constrained_neumann_problem

subroutine base_mlbddc_symbolic_setup_constrained_neumann_solver(this)
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  type(ParameterList_t), pointer :: neumann_solver_params 
  integer(ip) :: ierror
  
  assert ( this%am_i_l1_task() )
  call this%assert_neumann_solver_params()

  ierror = this%mlbddc_params%getSubList(Key=mlbddc_neumann_solver_params, & 
                                         SubList=neumann_solver_params) 
  assert(ierror==0)

  call this%constrained_neumann_solver%set_type_from_pl(neumann_solver_params)
  call this%constrained_neumann_solver%set_parameters_from_pl(neumann_solver_params)
  call this%constrained_neumann_solver%set_matrix(matrix = this%constrained_neumann_matrix)
  call this%constrained_neumann_solver%symbolic_setup() 
end subroutine base_mlbddc_symbolic_setup_constrained_neumann_solver

subroutine base_mlbddc_symbolic_setup_coarse_grid_matrix ( this )
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  type(environment_t)   , pointer       :: L1_environment
  type(environment_t)   , pointer       :: L2_environment
  integer(ip)                               :: istat
  class(base_fe_space_t), pointer :: fe_space
  type(coarse_fe_space_t), pointer :: coarse_fe_space
  logical     :: cm_symmetric_storage, cm_is_symmetric
  integer(ip) :: cm_sign

  call this%parse_or_transfer_coarse_matrix_params(cm_symmetric_storage, &
                                                   cm_is_symmetric, &
                                                   cm_sign)
  
  L1_environment => this%get_par_environment()
  if ( L1_environment%am_i_lgt1_task() ) then
     ! lgt1 MPI tasks symbolically set-up this%coarse_grid_matrix
     allocate  ( this%coarse_grid_matrix, stat = istat )
     check( istat == 0 )

     fe_space    => this%get_fe_space()
     coarse_fe_space => fe_space%get_coarse_fe_space()
     L2_environment  => L1_environment%get_next_level()
     call this%coarse_grid_matrix%create( p_env             = L2_environment, &
          dof_import        = coarse_fe_space%get_block_dof_import(1), &
          symmetric_storage = cm_symmetric_storage, &
          is_symmetric      = cm_is_symmetric, &
          sign              = cm_sign )
     if ( L2_environment%am_i_l1_task() ) then
        call this%coarse_grid_matrix_symbolic_assembly()
     end if
  else       
     ! L1 tasks do not hold any piece of the coarse triangulation
     nullify(this%coarse_grid_matrix)
  end if
end subroutine base_mlbddc_symbolic_setup_coarse_grid_matrix

subroutine base_mlbddc_coarse_grid_matrix_symbolic_assembly ( this )
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  type(environment_t)   , pointer       :: L1_environment
  type(environment_t)   , pointer       :: L2_environment
  type(coarse_fe_cell_iterator_t) :: coarse_fe
  type(i1p_t), allocatable :: fe_dofs(:)
  logical, pointer :: field_coupling(:,:)
  integer(ip) :: ifield, jfield, i, j, istat
  class(base_fe_space_t), pointer :: fe_space
  type(coarse_fe_space_t), pointer :: coarse_fe_space

  L1_environment => this%get_par_environment()
  L2_environment => L1_environment%get_next_level()
  assert ( associated (L2_environment) )
  assert ( L2_environment%am_i_l1_task() )

  fe_space    => this%get_fe_space()
  coarse_fe_space => fe_space%get_coarse_fe_space()

  allocate ( fe_dofs(coarse_fe_space%get_num_fields()), stat=istat)
  check(istat==0)     

  field_coupling => coarse_fe_space%get_field_coupling()

  call coarse_fe_space%create_coarse_fe_cell_iterator(coarse_fe)
  do while ( .not. coarse_fe%has_finished() )
     call coarse_fe%get_fe_dofs(fe_dofs)
     do ifield=1, coarse_fe_space%get_num_fields()
        do jfield=1, coarse_fe_space%get_num_fields()
           if ((field_coupling(ifield,jfield))) then
              do j=1, size(fe_dofs(jfield)%p)
                 do i=1, size(fe_dofs(ifield)%p)
                    call this%coarse_grid_matrix%insert(ia=fe_dofs(ifield)%p(i), &
                         ja=fe_dofs(jfield)%p(j) )
                 end do
              end do
           end if
        end do
     end do
     call coarse_fe%next()
  end do
  call coarse_fe_space%free_coarse_fe_cell_iterator(coarse_fe)

  deallocate ( fe_dofs, stat=istat )
  check(istat==0)
  
  call this%coarse_grid_matrix%convert(csr_format)
end subroutine base_mlbddc_coarse_grid_matrix_symbolic_assembly
 
subroutine base_mlbddc_symbolic_setup_mlbddc_coarse(this)
  implicit none
  class(base_mlbddc_t), intent(inout)     :: this
  type(environment_t)  , pointer :: par_environment
  integer(ip)                        :: istat 
  class(base_fe_space_t)   , pointer   :: fe_space
  type(coarse_fe_space_t), pointer   :: coarse_fe_space
  type(ParameterList_t), pointer :: coarse_solver_params 
  integer(ip) :: ierror

  par_environment => this%get_par_environment()
  if ( par_environment%am_i_lgt1_task() ) then
     call this%assert_coarse_solver_params()
     ierror = this%mlbddc_params%getSubList(Key=mlbddc_coarse_solver_params, & 
                                            SubList=coarse_solver_params) 
     assert(ierror==0)

     fe_space    => this%get_fe_space()
     coarse_fe_space => fe_space%get_coarse_fe_space()

     ! lgt1 MPI tasks symbolically setup mlbddc coarse
     allocate  ( this%mlbddc_coarse, stat = istat )
     check( istat == 0 )
     call this%mlbddc_coarse%create(coarse_fe_space, &
                                    this%coarse_grid_matrix, &
                                    coarse_solver_params)
     call this%mlbddc_coarse%symbolic_setup()
  else
     ! L1 tasks do not hold any piece of the coarse triangulation
     nullify(this%mlbddc_coarse)
  end if
end subroutine base_mlbddc_symbolic_setup_mlbddc_coarse

subroutine base_mlbddc_symbolic_setup_coarse_solver(this)
  implicit none
  class(base_mlbddc_t), intent(inout)     :: this
  type(environment_t)  , pointer :: par_environment
  type(par_sparse_matrix_t), pointer :: par_sparse_matrix
  integer(ip) :: ierror
  par_environment => this%get_par_environment()
  assert ( par_environment%get_l1_size() == 1 )
  assert ( par_environment%am_i_l1_task() )

  par_sparse_matrix => this%get_par_sparse_matrix()
  call this%coarse_solver%set_type_from_pl(this%mlbddc_params)
  call this%coarse_solver%set_parameters_from_pl(this%mlbddc_params)
  call this%coarse_solver%set_matrix(matrix = par_sparse_matrix%get_sparse_matrix())
  call this%coarse_solver%symbolic_setup() 
end subroutine base_mlbddc_symbolic_setup_coarse_solver

recursive subroutine base_mlbddc_numerical_setup ( this )
  implicit none
  class(base_mlbddc_t)        , intent(inout)   :: this
  type(environment_t), pointer         :: par_environment

  assert ( this%state_is_created() .or. this%state_is_symbolic() .or. this%state_is_numeric() )
  
  if ( this%state_is_created() ) then
    call this%symbolic_setup()
  end if 
  
  assert ( this%state_is_symbolic() .or. this%state_is_numeric() )
  
  if ( this%state_is_symbolic() ) then
    par_environment => this%get_par_environment()
    if ( par_environment%am_i_l1_task() ) then
      if ( par_environment%get_l1_size() > 1 ) then  
        call this%numerical_setup_constrained_neumann_problem()
        call this%numerical_setup_constrained_neumann_solver()
        call this%setup_coarse_grid_basis()
      end if
    end if

    call this%numerical_setup_coarse_grid_matrix()
    call this%numerical_setup_mlbddc_coarse()

    if ( par_environment%am_i_l1_task() ) then
       if ( par_environment%get_l1_size() > 1 ) then  
        call this%numerical_setup_dirichlet_problem()
        call this%numerical_setup_dirichlet_solver()
       else if ( par_environment%get_l1_size() == 1 ) then
        call this%numerical_setup_coarse_solver()
       end if
    end if
    call this%set_state_numeric()
  end if
  
end subroutine base_mlbddc_numerical_setup


subroutine base_mlbddc_numerical_setup_dirichlet_problem (this) 
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  class(base_fe_space_t)      , pointer       :: fe_space
  type(par_sparse_matrix_t) , pointer       :: par_sparse_matrix
  type(sparse_matrix_t)     , pointer       :: A

  type(environment_t)  , pointer :: par_environment
  par_environment => this%get_par_environment()

  assert ( this%am_i_l1_task() )
  fe_space => this%get_fe_space()
  par_sparse_matrix => this%get_par_sparse_matrix()
  A => par_sparse_matrix%get_sparse_matrix()
  if ( A%get_symmetric_storage() ) then
     call A%split_2x2_numeric(  num_row = fe_space%get_block_num_interior_dofs(1), &
          num_col = fe_space%get_block_num_interior_dofs(1), &
          A_II    = this%A_II, &
          A_IG    = this%A_IG, &
          A_GG    = this%A_GG)
  else
     call A%split_2x2_numeric(  num_row = fe_space%get_block_num_interior_dofs(1), &
          num_col = fe_space%get_block_num_interior_dofs(1), &
          A_II    = this%A_II, &
          A_IG    = this%A_IG, &
          A_GI    = this%A_GI, &
          A_GG    = this%A_GG)
  end if

  !call par_environment%l1_barrier()
  !call A%print_matrix_market(6)
  !call this%A_II%print_matrix_market(6)
  !call this%A_IG%print_matrix_market(6)
  !call this%A_GG%print_matrix_market(6)
  !call par_environment%l1_barrier()
end subroutine base_mlbddc_numerical_setup_dirichlet_problem

subroutine base_mlbddc_numerical_setup_dirichlet_solver(this)
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  assert ( this%am_i_l1_task() )
  call this%dirichlet_solver%numerical_setup() 
  !call this%dirichlet_solver%log_info()
end subroutine base_mlbddc_numerical_setup_dirichlet_solver

subroutine base_mlbddc_numerical_constrained_neumann_problem(this)
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  type(par_sparse_matrix_t) , pointer       :: par_sparse_matrix
  type(sparse_matrix_t)     , pointer       :: A

  assert ( this%am_i_l1_task() )
  par_sparse_matrix => this%get_par_sparse_matrix()
  A => par_sparse_matrix%get_sparse_matrix()
  call A%expand_matrix_numeric(C_T = this%constraint_matrix, &
       to  = this%constrained_neumann_matrix)

  !call this%constrained_neumann_matrix%print(6)
end subroutine  base_mlbddc_numerical_constrained_neumann_problem

subroutine base_mlbddc_numerical_setup_constrained_neumann_solver(this)
  implicit none
  class(base_mlbddc_t), intent(inout) :: this
  assert ( this%am_i_l1_task() )
  call this%constrained_neumann_solver%numerical_setup() 
  !call this%constrained_neumann_solver%log_info()
end subroutine base_mlbddc_numerical_setup_constrained_neumann_solver

subroutine base_mlbddc_allocate_coarse_grid_basis ( this )
  implicit none
  class(base_mlbddc_t), intent(inout) :: this
  class(base_fe_space_t)      , pointer       :: fe_space
  assert ( this%am_i_l1_task() )
  fe_space => this%get_fe_space() 
  call this%free_coarse_grid_basis()
  call memalloc (fe_space%get_block_num_dofs(1), &
       fe_space%get_block_num_coarse_dofs(1), &
       this%Phi, &
       __FILE__, &
       __LINE__) 
end subroutine base_mlbddc_allocate_coarse_grid_basis

subroutine base_mlbddc_setup_coarse_grid_basis ( this )
  implicit none
  class(base_mlbddc_t)  , intent(inout) :: this
  class(base_fe_space_t), pointer       :: fe_space
  real(rp), allocatable                     :: work1(:,:)
  real(rp), allocatable                     :: work2(:,:)
  integer(ip)                               :: i, j

  assert ( this%am_i_l1_task() )
  fe_space => this%get_fe_space() 

  call memalloc ( this%constrained_neumann_matrix%get_num_rows(), &
       fe_space%get_block_num_coarse_dofs(1), &
       work1, __FILE__,__LINE__ )

  call memalloc ( this%constrained_neumann_matrix%get_num_rows(), &
       fe_space%get_block_num_coarse_dofs(1), &
       work2, __FILE__,__LINE__ )

  work1 = 0.0_rp
  work2 = 0.0_rp
  j=1
  do i = fe_space%get_block_num_dofs(1)+1, this%constrained_neumann_matrix%get_num_rows()
     work1 (i,j) = 1.0_rp
     j = j + 1 
  end do

  if (fe_space%get_block_num_coarse_dofs(1)>0) then
    call this%constrained_neumann_solver%solve(work1, &
         work2)
  end if

  call this%allocate_coarse_grid_basis()
  this%Phi = work2 (1:fe_space%get_block_num_dofs(1),:) 

  call memfree ( work1, __FILE__,__LINE__ )
  call memfree ( work2, __FILE__,__LINE__ )
end subroutine base_mlbddc_setup_coarse_grid_basis

! Computes subdomain_elmat = \Phi^t A_i \Phi 
subroutine base_mlbddc_compute_subdomain_elmat ( this, subdomain_elmat )
  implicit none
  class(base_mlbddc_t)      , intent(in)    :: this
  real(rp), allocatable, intent(inout) :: subdomain_elmat(:,:)

  real(rp), allocatable :: work(:,:)
  type(par_sparse_matrix_t), pointer :: par_sparse_matrix
  type(sparse_matrix_t), pointer :: A
  class(base_fe_space_t), pointer :: fe_space

  assert ( this%am_i_l1_task() )
  par_sparse_matrix => this%get_par_sparse_matrix()
  A => par_sparse_matrix%get_sparse_matrix()
  fe_space => this%get_fe_space()

  if ( allocated(subdomain_elmat) ) then
     call memfree ( subdomain_elmat, __FILE__, __LINE__ )
  end if

  call memalloc ( fe_space%get_block_num_coarse_dofs(1), &
       fe_space%get_block_num_coarse_dofs(1), &
       subdomain_elmat, &
       __FILE__, &
       __LINE__ );

  call memalloc ( A%get_num_rows(), & 
       fe_space%get_block_num_coarse_dofs(1), &
       work, &
       __FILE__, & 
       __LINE__ )

  work = 0.0_rp
  if ( fe_space%get_block_num_coarse_dofs(1) > 0 ) then
     call A%apply_to_dense_matrix ( n     = fe_space%get_block_num_coarse_dofs(1), &
          alpha = 1.0_rp, &
          ldb   = A%get_num_rows(), &
          b     = this%Phi, &
          beta  = 0.0_rp, &
          ldc   = A%get_num_rows(), &
          c     = work )  
  end if
  subdomain_elmat = 0.0_rp
#ifdef ENABLE_BLAS
  if ( fe_space%get_block_num_coarse_dofs(1) > 0 ) then
     call DGEMM( 'T', &
          'N', &
          fe_space%get_block_num_coarse_dofs(1), &
          fe_space%get_block_num_coarse_dofs(1), &
          A%get_num_rows(), &
          1.0, &
          this%Phi, &
          A%get_num_rows() , &
          work, &
          A%get_num_rows(), &
          0.0, &
          subdomain_elmat, &
          fe_space%get_block_num_coarse_dofs(1))
  end if
#else
  write (0,*) 'Error: mlbddc.f90 was not compiled with -DENABLE_BLAS.'
  write (0,*) 'Error: You must activate this cpp macro in order to use the BLAS'
  check(.false.)    
#endif
  call memfree ( work, __FILE__, __LINE__)
end subroutine base_mlbddc_compute_subdomain_elmat

subroutine base_mlbddc_compute_subdomain_elmat_counts_and_displs ( this, counts, displs )
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  integer(ip), allocatable  , intent(inout) :: counts(:)
  integer(ip), allocatable  , intent(inout) :: displs(:)
  type(environment_t), pointer :: par_environment
  integer(ip) :: i, l1_to_l2_size
  type(coarse_fe_cell_iterator_t) :: coarse_fe

  class(base_fe_space_t)   , pointer :: fe_space
  type(coarse_fe_space_t), pointer :: coarse_fe_space

  par_environment => this%get_par_environment()
  assert (par_environment%am_i_l1_to_l2_root())
  l1_to_l2_size = par_environment%get_l1_to_l2_size()
  if ( allocated(counts) ) call memfree ( counts, __FILE__, __LINE__ )
  if ( allocated(displs) ) call memfree ( displs, __FILE__, __LINE__ )
  call memalloc ( l1_to_l2_size, counts, __FILE__, __LINE__ )
  call memalloc ( l1_to_l2_size, displs, __FILE__, __LINE__ )

  fe_space    => this%get_fe_space()
  coarse_fe_space => fe_space%get_coarse_fe_space()

  i = 1
  counts(l1_to_l2_size) = 0
  call coarse_fe_space%create_coarse_fe_cell_iterator(coarse_fe)
  do while ( .not. coarse_fe%has_finished() )
     if ( coarse_fe%is_local() ) then
        counts(i) = coarse_fe%get_num_dofs()**2    
        i = i +1
     end if
     call coarse_fe%next()
  end do
  call coarse_fe_space%free_coarse_fe_cell_iterator(coarse_fe)


  displs(1) = 0
  do i=2, l1_to_l2_size
     displs(i) = displs(i-1) + counts(i-1)
  end do
end subroutine base_mlbddc_compute_subdomain_elmat_counts_and_displs


subroutine base_mlbddc_compute_and_gather_subdomain_elmat ( this, subdomain_elmat_gathered )
  implicit none
  class(base_mlbddc_t)      , intent(inout) :: this
  real(rp), allocatable, intent(inout) :: subdomain_elmat_gathered(:)
  type(environment_t), pointer :: par_environment
  integer(ip), allocatable :: counts(:)
  integer(ip), allocatable :: displs(:)
  real(rp), allocatable :: subdomain_elmat(:,:)
  real(rp) :: dummy_real_array_rp_2D(0,0)
  real(rp) :: dummy_real_array_rp_1D(0)
  integer(ip) :: dummy_integer_array_ip(0)
  integer(ip) :: l1_to_l2_size
  par_environment => this%get_par_environment()
  assert (par_environment%am_i_l1_to_l2_task())

  if ( par_environment%am_i_l1_to_l2_root() ) then
     call this%compute_subdomain_elmat_counts_and_displs(counts, displs)
     l1_to_l2_size = par_environment%get_l1_to_l2_size()

     if ( allocated(subdomain_elmat_gathered) ) & 
          call memfree (subdomain_elmat_gathered, __FILE__, __LINE__)

     call memalloc ( displs(l1_to_l2_size), & 
          subdomain_elmat_gathered, & 
          __FILE__, __LINE__ ) 

     call par_environment%l2_from_l1_gather( input_data      = dummy_real_array_rp_2D, &
          recv_counts     = counts, &
          displs          = displs, &
          output_data     = subdomain_elmat_gathered )

     call memfree ( counts, __FILE__, __LINE__ )
     call memfree ( displs, __FILE__, __LINE__ )
  else
     call this%compute_subdomain_elmat(subdomain_elmat)
     call par_environment%l2_from_l1_gather( input_data      = subdomain_elmat, &
          recv_counts     = dummy_integer_array_ip, &
          displs          = dummy_integer_array_ip, &
          output_data     = dummy_real_array_rp_1D )
     call memfree ( subdomain_elmat, __FILE__, __LINE__ )
  end if
end subroutine base_mlbddc_compute_and_gather_subdomain_elmat

subroutine base_mlbddc_numerical_setup_coarse_grid_matrix ( this )
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  type(environment_t)   , pointer       :: L1_environment
  type(environment_t)   , pointer       :: L2_environment
  integer(ip)                               :: istat
  real(rp), allocatable                     :: subdomain_elmat_gathered(:)
  L1_environment => this%get_par_environment()
  if ( L1_environment%am_i_l1_to_l2_task() ) then
     call this%compute_and_gather_subdomain_elmat(subdomain_elmat_gathered)
  end if
  if ( L1_environment%am_i_lgt1_task() ) then
     L2_environment => L1_environment%get_next_level() 
     if ( L2_environment%am_i_l1_task() ) then
        call this%coarse_grid_matrix_numerical_assembly(subdomain_elmat_gathered)
     end if
  end if
  ! subdomain_elmat_gathered is only allocated on L2 MPI tasks
  if (allocated(subdomain_elmat_gathered) ) call memfree(subdomain_elmat_gathered, __FILE__, __LINE__ )
end subroutine base_mlbddc_numerical_setup_coarse_grid_matrix

subroutine base_mlbddc_coarse_grid_matrix_numerical_assembly ( this, subdomain_elmat_gathered )
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  real(rp)                  , intent(in)    :: subdomain_elmat_gathered(*)

  type(environment_t)   , pointer       :: L1_environment
  type(environment_t)   , pointer       :: L2_environment
  type(coarse_fe_cell_iterator_t) :: coarse_fe
  type(i1p_t), allocatable :: fe_dofs(:)
  logical, pointer :: field_coupling(:,:)
  integer(ip) :: ifield, jfield, i, j, istat, offset, offset_i, offset_j, LDA
  class(base_fe_space_t)   , pointer :: fe_space
  type(coarse_fe_space_t), pointer :: coarse_fe_space

  L1_environment => this%get_par_environment()
  L2_environment => L1_environment%get_next_level()
  assert ( associated (L2_environment) )
  assert ( L2_environment%am_i_l1_task() )

  fe_space    => this%get_fe_space()
  coarse_fe_space => fe_space%get_coarse_fe_space() 

  allocate ( fe_dofs(coarse_fe_space%get_num_fields()), stat=istat)
  check(istat==0)     
  field_coupling => coarse_fe_space%get_field_coupling()
  offset  = 0 
  call coarse_fe_space%create_coarse_fe_cell_iterator(coarse_fe)
  do while ( .not. coarse_fe%has_finished() )
     call coarse_fe%get_fe_dofs(fe_dofs)
     LDA = coarse_fe%get_num_dofs()
     if ( coarse_fe%is_local() ) then
        offset_i = 0
        do ifield=1, coarse_fe_space%get_num_fields()
          offset_j = 0
          do jfield=1, coarse_fe_space%get_num_fields()
              if ((field_coupling(ifield,jfield))) then
                 do j=1, size(fe_dofs(jfield)%p)
                    do i=1, size(fe_dofs(ifield)%p)
                       call this%coarse_grid_matrix%insert(ia = fe_dofs(ifield)%p(i) , &
                            ja  = fe_dofs(jfield)%p(j), &
                            val = subdomain_elmat_gathered(offset+(offset_j+j-1)*LDA+(offset_i+i)) )
                    end do
                 end do
              end if
              offset_j = offset_j +  size(fe_dofs(jfield)%p)
           end do
           offset_i = offset_i +  size(fe_dofs(ifield)%p)
        end do
     end if
     offset = offset + LDA**2
     call coarse_fe%next()
  end do
  call coarse_fe_space%free_coarse_fe_cell_iterator(coarse_fe)
  deallocate ( fe_dofs, stat=istat )
  check(istat==0)     
  call this%coarse_grid_matrix%convert(csr_format)
  !call this%coarse_grid_matrix%print_matrix_market(6)
end subroutine base_mlbddc_coarse_grid_matrix_numerical_assembly

subroutine base_mlbddc_numerical_setup_mlbddc_coarse ( this )
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  type(environment_t)  , pointer :: par_environment

  par_environment => this%get_par_environment()
  if ( par_environment%am_i_lgt1_task() ) then
     call this%mlbddc_coarse%numerical_setup()
  end if
end subroutine base_mlbddc_numerical_setup_mlbddc_coarse

subroutine base_mlbddc_numerical_setup_coarse_solver(this)
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  type(environment_t)  , pointer :: par_environment
  par_environment => this%get_par_environment()
  assert ( par_environment%get_l1_size() == 1 )
  assert ( par_environment%am_i_l1_task() )
  call this%coarse_solver%numerical_setup() 
  !call this%coarse_solver%log_info()
end subroutine base_mlbddc_numerical_setup_coarse_solver

!=============================================================================
recursive subroutine base_mlbddc_apply (this, x, y)
  implicit none
  ! Parameters
  class(base_mlbddc_t)   , intent(inout)    :: this
  class(vector_t)   , intent(in)    :: x
  class(vector_t)   , intent(inout) :: y
  
  assert ( this%state_is_created() .or. this%state_is_symbolic() .or. this%state_is_numeric() )

  if (this%state_is_created() ) then
    call this%symbolic_setup()
  end if 
  
  assert ( this%state_is_symbolic() .or. this%state_is_numeric() )
  
  if (this%state_is_symbolic() ) then
    call this%numerical_setup()
  end if 
  
  assert ( this%state_is_numeric() )
  
  call this%abort_if_not_in_domain(x)
  call this%abort_if_not_in_range(y)
  call x%GuardTemp()
  select type(x)
     class is (par_scalar_array_t)
     select type(y)
        class is(par_scalar_array_t)
        call this%apply_par_scalar_array( x, y )
     end select
  end select
  call x%CleanTemp()
end subroutine base_mlbddc_apply

!=============================================================================
recursive subroutine base_mlbddc_apply_add(this, x, y)
  implicit none
  ! Parameters
  class(base_mlbddc_t)   , intent(inout)    :: this
  class(vector_t)   , intent(in)    :: x
  class(vector_t)   , intent(inout) :: y
  class(vector_t), allocatable      :: w
  type(vector_space_t), pointer     :: range_vector_space
  integer(ip)                       :: istat
  call this%abort_if_not_in_domain(x)
  call this%abort_if_not_in_range(y)
  call x%GuardTemp()
  range_vector_space => this%get_range_vector_space()
  call range_vector_space%create_vector(w)
  call this%apply(x,w)
  call y%axpby(1.0, w, 1.0)
  call x%CleanTemp()
  call w%free()
  deallocate(w, stat=istat); check(istat==0)
end subroutine base_mlbddc_apply_add

recursive subroutine base_mlbddc_apply_par_scalar_array ( this, x, y )
  implicit none
  class(base_mlbddc_t)         , intent(inout)    :: this
  type(par_scalar_array_t), intent(in)    :: x
  type(par_scalar_array_t), intent(inout) :: y

  type(par_scalar_array_t) :: y_I, y_G
  type(par_scalar_array_t) :: residual, residual_I, residual_G
  type(par_scalar_array_t) :: delta, delta_I, delta_G
  type(par_scalar_array_t) :: constrained_neumann_correction, &
       constrained_neumann_correction_I, &
       constrained_neumann_correction_G
  type(par_scalar_array_t) :: coarse_correction, &
       coarse_correction_I, &
       coarse_correction_G
  type(environment_t), pointer :: par_environment
  
  par_environment => this%get_par_environment()
  if ( par_environment%get_l1_size() == 1 ) then
     call this%solve_coarse_problem(x, y)
  else ! l1_size > 1 .or. l1_size < 1    
     call this%create_interior_interface_views(y, &
          y_I, & 
          y_G)

     ! Clone, copy, and create views for input residual
     call residual%clone(x)
     call residual%copy(x)
     call this%create_interior_interface_views(residual, &
          residual_I, & 
          residual_G)

     ! Clone, init, and create views for delta
     call delta%clone(x)
     call this%create_interior_interface_views(delta, &
          delta_I, & 
          delta_G)

     ! Clone and create views for constrained_neumann_correction
     call constrained_neumann_correction%clone(x)
     call this%create_interior_interface_views(constrained_neumann_correction, &
          constrained_neumann_correction_I, & 
          constrained_neumann_correction_G)

     ! Clone and create views for coarse_correction
     call coarse_correction%clone(x)
     call this%create_interior_interface_views(coarse_correction, &
          coarse_correction_I, & 
          coarse_correction_G)


     ! 1) Compute delta_I = A_II^-1 residual_I,   delta_G = 0
     call this%solve_dirichlet_problem( residual_I, delta_I )

     ! 2) y_I = delta_I
     call y_I%copy(delta_I)

     ! 3) ! I-A P_D = [ 0                    0 ]
     !           [ -A_GI A_II^{-1}      I ]
     !delta_G = A_GI * A_II^{-1}*residual_I
     call this%apply_A_GI(delta_I, delta_G)
     call delta%comm()
     call residual_I%init(0.0_rp)
     ! residual_G = residual_G - delta_G =
     !              residual_G - sum(A_GI*A_II^{-1}*residual_I,i=1..P)
     call residual_G%axpby(-1.0_rp, delta_G, 1.0_rp)

     ! 4) Compute delta_G = A_{BDDC}^{-1} r
     call this%apply_weight_operator(residual,residual) 
     call this%compute_coarse_correction(residual, coarse_correction)
     call this%solve_constrained_neumann_problem ( residual, constrained_neumann_correction )
     call delta_G%copy (coarse_correction_G)
     call delta_G%axpby(1.0_rp, constrained_neumann_correction_G,1.0_rp)
     call this%apply_weight_operator(delta,delta) 
     call delta%comm()
     
     ! y_G = delta_G
     call y_G%copy(delta_G)

     ! 5) I-P_D A = [ 0      -A_II^{-1} A_IG ]
     !              [ 0                   I  ]
     call this%apply_A_IG(delta_G, residual_I)
     call this%solve_dirichlet_problem(residual_I, delta_I)
     ! y_I = y_I - delta_I
     call y_I%axpby(-1.0_rp, delta_I, 1.0_rp)

     call constrained_neumann_correction_I%free()
     call constrained_neumann_correction_G%free()
     call constrained_neumann_correction%free()
     call coarse_correction_I%free()
     call coarse_correction_G%free()
     call coarse_correction%free()
     call delta_I%free()
     call delta_G%free()
     call delta%free()
     call residual_I%free()
     call residual_G%free()
     call residual%free()
     call y_I%free()
     call y_G%free()
  end if
end subroutine base_mlbddc_apply_par_scalar_array

subroutine base_mlbddc_solve_coarse_problem(this,x,y)
  implicit none
  class(base_mlbddc_t)            , intent(in)    :: this
  type(par_scalar_array_t)   , intent(in)    :: x
  type(par_scalar_array_t)   , intent(inout) :: y
  type(environment_t)    , pointer       :: par_environment
  type(serial_scalar_array_t), pointer       :: serial_y 

  par_environment => this%get_par_environment()
  assert ( par_environment%get_l1_size() == 1 )
  assert ( par_environment%am_i_l1_task() )

  serial_y => y%get_serial_scalar_array()
  call this%coarse_solver%solve(x%get_serial_scalar_array(), &
       serial_y)
end subroutine base_mlbddc_solve_coarse_problem

recursive subroutine base_mlbddc_compute_coarse_correction (this, residual, coarse_correction)
  implicit none
  class(base_mlbddc_t)         , intent(in)    :: this
  type(par_scalar_array_t), intent(in)    :: residual
  type(par_scalar_array_t), intent(inout) :: coarse_correction

  type(par_scalar_array_t) :: coarse_residual
  type(par_scalar_array_t) :: coarse_coarse_correction
  type(environment_t), pointer :: L1_environment
  type(environment_t), pointer :: L2_environment
  class(base_fe_space_t)   , pointer :: fe_space
  type(coarse_fe_space_t), pointer :: coarse_fe_space

  L1_environment => this%get_par_environment()
  fe_space    => this%get_fe_space()
  if ( L1_environment%am_i_lgt1_task() ) then
     L2_environment => L1_environment%get_next_level()
     coarse_fe_space => fe_space%get_coarse_fe_space()
     call coarse_residual%create_and_allocate( p_env      = L2_environment, &
          dof_import = coarse_fe_space%get_block_dof_import(1) )
     call coarse_coarse_correction%clone(coarse_residual)
  end if

  ! Transfer residual from L1 to L2 tasks
  call this%setup_coarse_grid_residual ( residual, coarse_residual )

  ! Solve coarse problem on > L1 tasks
  if ( L1_environment%am_i_lgt1_task() ) then
     call this%mlbddc_coarse%apply(coarse_residual, coarse_coarse_correction)
  end if
  call this%scatter_and_interpolate_coarse_grid_correction ( coarse_coarse_correction, coarse_correction )
  if ( L1_environment%am_i_lgt1_task() ) then
     call coarse_coarse_correction%free()
     call coarse_residual%free()
  end if

end subroutine base_mlbddc_compute_coarse_correction

subroutine base_mlbddc_setup_coarse_grid_residual ( this, vector, coarse_grid_vector )
  implicit none
  class(base_mlbddc_t)         , intent(in)    :: this
  type(par_scalar_array_t), intent(in)    :: vector
  type(par_scalar_array_t), intent(inout) :: coarse_grid_vector
  type(environment_t), pointer        :: L1_environment
  type(environment_t), pointer        :: L2_environment
  real(rp), allocatable                   :: coarse_dofs_values_gathered(:)

  L1_environment => this%get_par_environment()
  if ( L1_environment%am_i_l1_to_l2_task() ) then
     call this%compute_and_gather_coarse_dofs_values(vector, coarse_dofs_values_gathered)
  end if

  if ( L1_environment%am_i_lgt1_task() ) then
     call coarse_grid_vector%init(0.0_rp) 
     L2_environment => L1_environment%get_next_level()
     if ( L2_environment%am_i_l1_task() ) then
        call this%coarse_grid_residual_assembly(coarse_dofs_values_gathered, coarse_grid_vector)
     end if
  else
     call coarse_grid_vector%free()
  end if
  if ( allocated(coarse_dofs_values_gathered) ) call memfree(coarse_dofs_values_gathered, __FILE__, __LINE__ )
end subroutine base_mlbddc_setup_coarse_grid_residual


! Computes subdomain_elvec = \Phi^t v_i
subroutine base_mlbddc_compute_coarse_dofs_values ( this, vector, coarse_dofs_values )
  implicit none
  class(base_mlbddc_t)         , intent(in) :: this
  type(par_scalar_array_t), intent(in) :: vector
  real(rp), allocatable, intent(inout) :: coarse_dofs_values(:)
  type(serial_scalar_array_t), pointer :: serial_scalar_array
  class(base_fe_space_t), pointer :: fe_space

  assert ( this%am_i_l1_task() )
  serial_scalar_array => vector%get_serial_scalar_array()

  fe_space => this%get_fe_space()

  if ( allocated(coarse_dofs_values) ) then
     call memfree ( coarse_dofs_values, __FILE__, __LINE__ )
  end if

  call memalloc ( fe_space%get_block_num_coarse_dofs(1), &
       coarse_dofs_values, &
       __FILE__, &
       __LINE__ );

  coarse_dofs_values = 0.0_rp
#ifdef ENABLE_BLAS
  if (fe_space%get_block_num_coarse_dofs(1) .ne.0 ) then
    call DGEMV(  'T', & 
         serial_scalar_array%get_size(), &
         fe_space%get_block_num_coarse_dofs(1), &
         1.0_rp, &
         this%Phi, &
         serial_scalar_array%get_size(), &
         serial_scalar_array%get_entries(), &
         1, &
         0.0_rp, & 
         coarse_dofs_values, & 
         1)
  end if
#else
  write (0,*) 'Error: mlbddc.f90 was not compiled with -DENABLE_BLAS.'
  write (0,*) 'Error: You must activate this cpp macro in order to use the BLAS'
  check(.false.)    
#endif
end subroutine base_mlbddc_compute_coarse_dofs_values

subroutine base_mlbddc_compute_coarse_dofs_values_counts_and_displs ( this, counts, displs )
  implicit none
  class(base_mlbddc_t)           , intent(in)    :: this
  integer(ip), allocatable  , intent(inout) :: counts(:)
  integer(ip), allocatable  , intent(inout) :: displs(:)
  type(environment_t), pointer :: par_environment
  integer(ip) :: i, l1_to_l2_size
  type(coarse_fe_cell_iterator_t) :: coarse_fe
  class(base_fe_space_t)   , pointer :: fe_space
  type(coarse_fe_space_t), pointer :: coarse_fe_space

  par_environment => this%get_par_environment()
  assert (par_environment%am_i_l1_to_l2_root())
  fe_space => this%get_fe_space()
  coarse_fe_space => fe_space%get_coarse_fe_space()

  l1_to_l2_size = par_environment%get_l1_to_l2_size()
  if ( allocated(counts) ) call memfree ( counts, __FILE__, __LINE__ )
  if ( allocated(displs) ) call memfree ( displs, __FILE__, __LINE__ )
  call memalloc ( l1_to_l2_size, counts, __FILE__, __LINE__ )
  call memalloc ( l1_to_l2_size, displs, __FILE__, __LINE__ )

  i=1
  counts(l1_to_l2_size) = 0
  call coarse_fe_space%create_coarse_fe_cell_iterator(coarse_fe)
  do while ( .not. coarse_fe%has_finished() )
     if ( coarse_fe%is_local() ) then
        counts(i) = coarse_fe%get_num_dofs()
        i=i+1
     end if
     call coarse_fe%next()
  end do
  call coarse_fe_space%free_coarse_fe_cell_iterator(coarse_fe)
  displs(1) = 0
  do i=2, l1_to_l2_size
     displs(i) = displs(i-1) + counts(i-1)
  end do
end subroutine base_mlbddc_compute_coarse_dofs_values_counts_and_displs

subroutine base_mlbddc_compute_and_gather_coarse_dofs_values ( this, vector, coarse_dofs_values_gathered )
  implicit none
  class(base_mlbddc_t)         , intent(in)    :: this
  type(par_scalar_array_t), intent(in)    :: vector
  real(rp)   , allocatable, intent(inout) :: coarse_dofs_values_gathered(:)
  type(environment_t), pointer :: par_environment
  integer(ip), allocatable :: counts(:)
  integer(ip), allocatable :: displs(:)
  real(rp), allocatable :: coarse_dofs_values(:)
  real(rp) :: dummy_real_array_rp(0)
  integer(ip) :: dummy_integer_array_ip(0)
  integer(ip) :: l1_to_l2_size
  par_environment => this%get_par_environment()
  assert (par_environment%am_i_l1_to_l2_task())

  if ( par_environment%am_i_l1_to_l2_root() ) then
     call this%compute_coarse_dofs_values_counts_and_displs(counts, displs)
     l1_to_l2_size = par_environment%get_l1_to_l2_size()

     if ( allocated(coarse_dofs_values_gathered) ) & 
          call memfree (coarse_dofs_values_gathered, __FILE__, __LINE__)

     call memalloc ( displs(l1_to_l2_size), & 
          coarse_dofs_values_gathered, & 
          __FILE__, __LINE__ ) 

     call par_environment%l2_from_l1_gather( input_data_size = 0, &
          input_data      = dummy_real_array_rp, &
          recv_counts     = counts, &
          displs          = displs, &
          output_data     = coarse_dofs_values_gathered )

     call memfree ( counts, __FILE__, __LINE__ )
     call memfree ( displs, __FILE__, __LINE__ )
  else
     call this%compute_coarse_dofs_values(vector, coarse_dofs_values)
     call par_environment%l2_from_l1_gather( input_data_size = size(coarse_dofs_values), &
          input_data      = coarse_dofs_values, &
          recv_counts     = dummy_integer_array_ip, &
          displs          = dummy_integer_array_ip, &
          output_data     = dummy_real_array_rp )
     call memfree ( coarse_dofs_values, __FILE__, __LINE__ )
  end if
end subroutine base_mlbddc_compute_and_gather_coarse_dofs_values

! This subroutine assumes that coarse_grid_vector has been already created+allocated, and initialized to zero.
subroutine base_mlbddc_coarse_grid_residual_assembly ( this, coarse_dofs_values_gathered, coarse_grid_vector ) 
  implicit none
  class(base_mlbddc_t)         , intent(in)    :: this
  real(rp)                , intent(in)    :: coarse_dofs_values_gathered(*)
  type(par_scalar_array_t), intent(inout) :: coarse_grid_vector

  type(environment_t)   , pointer       :: L1_environment
  type(environment_t)   , pointer       :: L2_environment
  type(coarse_fe_cell_iterator_t)                :: coarse_fe
  class(base_fe_space_t)   , pointer :: fe_space
  type(coarse_fe_space_t), pointer :: coarse_fe_space

  type(i1p_t), allocatable :: fe_dofs(:)
  integer(ip) :: ifield, i, istat, current

  L1_environment => this%get_par_environment()
  L2_environment => L1_environment%get_next_level()
  assert ( associated (L2_environment) )
  assert ( L2_environment%am_i_l1_task() )
  fe_space => this%get_fe_space()
  coarse_fe_space => fe_space%get_coarse_fe_space()

  allocate ( fe_dofs(coarse_fe_space%get_num_fields()), stat=istat)
  check(istat==0)     
  current = 1
  call coarse_fe_space%create_coarse_fe_cell_iterator(coarse_fe)
  do while ( .not. coarse_fe%has_finished() )
     call coarse_fe%get_fe_dofs(fe_dofs)
     if ( coarse_fe%is_local() ) then
        do ifield=1, coarse_fe_space%get_num_fields()
           do i=1, size(fe_dofs(ifield)%p)
              call coarse_grid_vector%add(i   =  fe_dofs(ifield)%p(i), &
                   val = coarse_dofs_values_gathered(current) )
              current = current + 1
           end do
        end do
     end if
     call coarse_fe%next()
  end do
  call coarse_fe_space%free_coarse_fe_cell_iterator(coarse_fe)
  deallocate ( fe_dofs, stat=istat )
  check(istat==0)
  call coarse_grid_vector%comm()
end subroutine base_mlbddc_coarse_grid_residual_assembly

subroutine base_mlbddc_scatter_and_interpolate_coarse_grid_correction (this, coarse_grid_vector, vector)
  implicit none
  class(base_mlbddc_t)           , intent(in)    :: this
  type(par_scalar_array_t)  , intent(in)    :: coarse_grid_vector
  type(par_scalar_array_t)  , intent(inout) :: vector
  type(environment_t)   , pointer :: L1_environment
  real(rp), allocatable :: coarse_dofs_values(:)

  L1_environment => this%get_par_environment()
  if ( L1_environment%am_i_l1_to_l2_task() ) then
     call this%scatter_coarse_grid_correction(coarse_grid_vector, coarse_dofs_values)
  end if

  if ( L1_environment%am_i_l1_task() ) then
     call this%interpolate_coarse_grid_correction(coarse_dofs_values, vector)
  end if

  if ( allocated(coarse_dofs_values) ) call memfree(coarse_dofs_values, __FILE__, __LINE__ )
end subroutine base_mlbddc_scatter_and_interpolate_coarse_grid_correction

subroutine base_mlbddc_scatter_coarse_grid_correction ( this, coarse_grid_vector, coarse_dofs_values )
  implicit none
  class(base_mlbddc_t)         , intent(in)    :: this
  type(par_scalar_array_t), intent(in)    :: coarse_grid_vector
  real(rp), allocatable   , intent(inout) :: coarse_dofs_values(:)

  integer(ip) :: l1_to_l2_size
  real(rp), allocatable :: coarse_dofs_values_scattered(:)
  integer(ip), allocatable :: counts(:), displs(:)
  type(environment_t), pointer :: par_environment
  real(rp) :: dummy_real_array_rp(0)
  integer(ip) :: dummy_integer_array_ip(0)
  class(base_fe_space_t), pointer :: fe_space

  par_environment => this%get_par_environment()
  assert (par_environment%am_i_l1_to_l2_task())
  fe_space => this%get_fe_space()
  if ( par_environment%am_i_l1_to_l2_root() ) then

     call this%compute_coarse_dofs_values_counts_and_displs(counts, displs)
     l1_to_l2_size = par_environment%get_l1_to_l2_size()

     call memalloc ( displs(l1_to_l2_size), & 
          coarse_dofs_values_scattered, & 
          __FILE__, __LINE__ ) 

     call this%fill_coarse_dofs_values_scattered ( coarse_grid_vector, &
          coarse_dofs_values_scattered)

     call par_environment%l2_to_l1_scatter( input_data       = coarse_dofs_values_scattered, &
          send_counts      = counts, &
          displs           = displs, &
          output_data_size = 0, &
          output_data      = dummy_real_array_rp )

     call memfree ( coarse_dofs_values_scattered, & 
          __FILE__, __LINE__ ) 

     call memfree ( counts, __FILE__, __LINE__ )
     call memfree ( displs, __FILE__, __LINE__ )

  else 
     if ( allocated (coarse_dofs_values) ) call memfree( coarse_dofs_values, __FILE__, __LINE__ )
     call memalloc ( fe_space%get_block_num_coarse_dofs(1), &
          coarse_dofs_values, &
          __FILE__, __LINE__ );

     call par_environment%l2_to_l1_scatter( input_data       = dummy_real_array_rp, &
          send_counts      = dummy_integer_array_ip, &
          displs           = dummy_integer_array_ip, &
          output_data_size = size(coarse_dofs_values), &
          output_data      = coarse_dofs_values )
  end if
end subroutine base_mlbddc_scatter_coarse_grid_correction

subroutine base_mlbddc_fill_coarse_dofs_values_scattered ( this, coarse_grid_vector, coarse_dofs_values_scattered ) 
  implicit none
  class(base_mlbddc_t)          , intent(in)     :: this
  type(par_scalar_array_t) , intent(in)     :: coarse_grid_vector
  real(rp)                 , intent(inout)  :: coarse_dofs_values_scattered(*)
  type(environment_t), pointer    :: par_environment
  type(i1p_t)           , allocatable :: fe_dofs(:)
  type(coarse_fe_cell_iterator_t)          :: coarse_fe
  integer(ip)                         :: istat, current, ifield
  class(base_fe_space_t)   , pointer :: fe_space
  type(coarse_fe_space_t), pointer :: coarse_fe_space

  par_environment => this%get_par_environment()
  assert (par_environment%am_i_l1_to_l2_root())

  fe_space => this%get_fe_space()
  coarse_fe_space => fe_space%get_coarse_fe_space()

  allocate ( fe_dofs(coarse_fe_space%get_num_fields()), stat=istat)
  check(istat==0)

  current = 1
  call coarse_fe_space%create_coarse_fe_cell_iterator(coarse_fe) 
  do while ( .not. coarse_fe%has_finished() )
     call coarse_fe%get_fe_dofs(fe_dofs)
     if ( coarse_fe%is_local() ) then
        do ifield=1, coarse_fe_space%get_num_fields()
           call coarse_grid_vector%extract_subvector ( iblock       = 1, &
                size_indices = size(fe_dofs(ifield)%p), &
                indices     = fe_dofs(ifield)%p, &
                values      = coarse_dofs_values_scattered(current) )
           current = current + size(fe_dofs(ifield)%p)
        end do
     end if
     call coarse_fe%next()
  end do
  call coarse_fe_space%free_coarse_fe_cell_iterator(coarse_fe)
  deallocate ( fe_dofs, stat=istat )
  check(istat==0)
end subroutine base_mlbddc_fill_coarse_dofs_values_scattered

subroutine base_mlbddc_interpolate_coarse_grid_correction (this, coarse_dofs_values, vector)
  implicit none
  class(base_mlbddc_t)            , intent(in)    :: this
  real(rp)                   , intent(in)    :: coarse_dofs_values(*)
  type(par_scalar_array_t)   , intent(inout) :: vector
  type(environment_t)    , pointer       :: L1_environment
  type(serial_scalar_array_t), pointer       :: serial_scalar_array 
  real(rp)                   , pointer       :: serial_scalar_array_entries(:)
  class(base_fe_space_t)       , pointer       :: fe_space

  L1_environment => this%get_par_environment()
  assert ( L1_environment%am_i_l1_task() )

  fe_space => this%get_fe_space()

  call vector%init(0.0_rp)
  serial_scalar_array         => vector%get_serial_scalar_array()
  serial_scalar_array_entries => serial_scalar_array%get_entries()

#ifdef ENABLE_BLAS
  if (fe_space%get_block_num_coarse_dofs(1) .ne. 0) then
    call DGEMV(  'N', & 
         serial_scalar_array%get_size(), &
         fe_space%get_block_num_coarse_dofs(1), &
         1.0_rp, &
         this%Phi, &
         serial_scalar_array%get_size(), &
         coarse_dofs_values, &
         1,    &
         0.0_rp,  & 
         serial_scalar_array_entries, & 
         1)
  end if
#else
  write (0,*) 'Error: mlbddc.f90 was not compiled with -DENABLE_BLAS.'
  write (0,*) 'Error: You must activate this cpp macro in order to use the BLAS'
  check(.false.)    
#endif

end subroutine base_mlbddc_interpolate_coarse_grid_correction


subroutine base_mlbddc_solve_dirichlet_problem(this, x_I, y_I)
  implicit none
  class(base_mlbddc_t)           , intent(in)    :: this
  type(par_scalar_array_t)  , intent(in)    :: x_I
  type(par_scalar_array_t)  , intent(inout) :: y_I
  type(serial_scalar_array_t), pointer      :: y_I_serial
  if ( this%am_i_l1_task() ) then
     y_I_serial => y_I%get_serial_scalar_array()
     call this%dirichlet_solver%solve(x_I%get_serial_scalar_array(), &
          y_I_serial)
  end if
end subroutine base_mlbddc_solve_dirichlet_problem

subroutine base_mlbddc_apply_A_GI(this, x_I, y_G)
  implicit none
  class(base_mlbddc_t)           , intent(inout)    :: this
  type(par_scalar_array_t)  , intent(in)    :: x_I
  type(par_scalar_array_t)  , intent(inout) :: y_G
  type(par_sparse_matrix_t), pointer :: par_sparse_matrix
  type(sparse_matrix_t), pointer :: A
  type(serial_scalar_array_t), pointer    :: y_G_serial

  if ( this%am_i_l1_task() ) then
     par_sparse_matrix => this%get_par_sparse_matrix()
     A => par_sparse_matrix%get_sparse_matrix()
     y_G_serial => y_G%get_serial_scalar_array()
     if ( A%get_symmetric_storage() ) then
        call this%A_IG%apply_transpose(x_I%get_serial_scalar_array(), &
             y_G_serial)
     else
        call this%A_GI%apply(x_I%get_serial_scalar_array(), &
             y_G_serial)
     end if
  end if

end subroutine base_mlbddc_apply_A_GI

subroutine base_mlbddc_apply_A_IG(this, x_G, y_I)
  implicit none
  class(base_mlbddc_t)           , intent(inout)    :: this
  type(par_scalar_array_t)  , intent(in)    :: x_G
  type(par_scalar_array_t)  , intent(inout) :: y_I
  type(par_sparse_matrix_t), pointer :: par_sparse_matrix
  type(sparse_matrix_t), pointer :: A
  type(serial_scalar_array_t), pointer    :: y_I_serial
  if ( this%am_i_l1_task() ) then
     par_sparse_matrix => this%get_par_sparse_matrix()
     A => par_sparse_matrix%get_sparse_matrix()
     y_I_serial => y_I%get_serial_scalar_array()
     call this%A_IG%apply(x_G%get_serial_scalar_array(), y_I_serial)
  end if
end subroutine base_mlbddc_apply_A_IG

subroutine base_mlbddc_solve_constrained_neumann_problem(this, x, y)
  implicit none
  class(base_mlbddc_t)            , intent(in)    :: this
  type(par_scalar_array_t)   , intent(in)    :: x
  type(par_scalar_array_t)   , intent(inout) :: y
  type(serial_scalar_array_t), pointer :: x_serial
  type(serial_scalar_array_t), pointer :: y_serial
  real(rp)                   , pointer :: y_serial_entries(:)
  type(serial_scalar_array_t)          :: augmented_x
  type(serial_scalar_array_t)          :: augmented_y
  real(rp), allocatable                :: augmented_x_entries(:)
  real(rp), allocatable                :: augmented_y_entries(:)
  integer(ip)                          :: block_num_dofs
  integer(ip)                          :: block_num_coarse_dofs
  class(base_fe_space_t)       , pointer :: fe_space

  fe_space => this%get_fe_space()
  if ( this%am_i_l1_task() ) then
     block_num_dofs        = fe_space%get_block_num_dofs(1)
     block_num_coarse_dofs = fe_space%get_block_num_coarse_dofs(1)

     x_serial => x%get_serial_scalar_array()

     ! Set-up augmented_x from x_serial
     call augmented_x%create(block_num_dofs + block_num_coarse_dofs)
     call memalloc ( block_num_dofs + block_num_coarse_dofs, & 
          augmented_x_entries, __FILE__,__LINE__)  
     augmented_x_entries(1:block_num_dofs)  = x_serial%get_entries() 
     augmented_x_entries(block_num_dofs+1:) = 0.0_rp 
     call augmented_x%set_view_entries(augmented_x_entries)

     ! Set-up augmented_y
     call augmented_y%create(block_num_dofs + block_num_coarse_dofs)
     call memalloc ( block_num_dofs + block_num_coarse_dofs, & 
          augmented_y_entries, __FILE__,__LINE__)  
     call augmented_y%set_view_entries(augmented_y_entries)
     call this%constrained_neumann_solver%solve(augmented_x, &
          augmented_y)

     ! Set-up y from augmented_y
     y_serial         => y%get_serial_scalar_array()
     y_serial_entries => y_serial%get_entries()
     y_serial_entries = augmented_y_entries(1:block_num_dofs)

     call memfree ( augmented_x_entries, __FILE__,__LINE__)  
     call memfree ( augmented_y_entries, __FILE__,__LINE__)  
  end if
end subroutine base_mlbddc_solve_constrained_neumann_problem

subroutine base_mlbddc_apply_weight_operator(this, x, y)
  implicit none
  class(base_mlbddc_t)    , intent(in)    :: this
  type(par_scalar_array_t)  , intent(in)    :: x
  type(par_scalar_array_t)  , intent(inout) :: y
  type(serial_scalar_array_t), pointer :: x_local
  type(serial_scalar_array_t), pointer :: y_local
  real(rp), pointer :: x_local_entries(:)
  real(rp), pointer :: y_local_entries(:)

  if ( this%am_i_l1_task() ) then
     x_local         => x%get_serial_scalar_array()
     x_local_entries => x_local%get_entries()
     y_local         => y%get_serial_scalar_array()
     y_local_entries => y_local%get_entries()
     y_local_entries = x_local_entries*this%W
  end if
end subroutine base_mlbddc_apply_weight_operator

subroutine base_mlbddc_create_interior_interface_views ( this, x, x_I, X_G )
  implicit none
  class(base_mlbddc_t)         , intent(in)       :: this
  type(par_scalar_array_t), intent(in)       :: x
  type(par_scalar_array_t), intent(inout)    :: x_I
  type(par_scalar_array_t), intent(inout)    :: x_G
  class(base_fe_space_t), pointer :: fe_space
  fe_space => this%get_fe_space()
  call x%create_view(1, &
       fe_space%get_block_num_interior_dofs(1), &
       x_I)
  call x%create_view(fe_space%get_block_num_interior_dofs(1)+1, &
       fe_space%get_block_num_dofs(1), &
       x_G)
end subroutine base_mlbddc_create_interior_interface_views

subroutine base_mlbddc_free(this)
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  call this%free_numerical_setup()
  call this%free_symbolic_setup()
  call this%free_clean()
end subroutine base_mlbddc_free

subroutine base_mlbddc_free_clean(this)
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  
  assert ( this%state_is_start() .or. this%state_is_created() .or. this%state_is_symbolic() .or. this%state_is_numeric() )

  if ( this%state_is_numeric() ) then
    call this%free_numerical_setup() 
  end if
  
  if ( this%state_is_symbolic() ) then
    call this%free_symbolic_setup() 
  end if
  
  call this%nullify_operator()
  call this%free_vector_spaces()
  nullify(this%mlbddc_params)
  nullify(this%environment)
  
  call this%set_state_start()
end subroutine base_mlbddc_free_clean

recursive subroutine base_mlbddc_free_symbolic_setup(this)
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  type(environment_t)   , pointer       :: par_environment
  integer(ip)                               :: istat

  assert ( this%state_is_start() .or. this%state_is_created() .or. this%state_is_symbolic() .or. this%state_is_numeric() )

  if ( this%state_is_numeric() ) then
    call this%free_numerical_setup() 
  end if
  
  if ( this%state_is_symbolic() ) then 
     par_environment => this%get_par_environment()
     if ( par_environment%am_i_l1_task() ) then
        if ( par_environment%get_l1_size() > 1 ) then
           call this%free_symbolic_setup_dirichlet_solver()
           call this%free_symbolic_setup_dirichlet_problem()
           call this%free_symbolic_setup_constrained_neumann_solver()
           call this%free_symbolic_setup_constrained_neumann_problem()
           nullify (this%mlbddc_coarse)
           nullify (this%coarse_grid_matrix)
           call this%constraint_matrix%free()
           if ( allocated(this%W) ) then 
             call memfree(this%W, __FILE__, __LINE__)
           end if
        else
           call this%free_symbolic_setup_coarse_solver()
        end if
     else
        if ( associated(this%mlbddc_coarse) ) then
          ! mlbddc_coarse should be freed before coarse_fe_space
          ! (as the former was created from the latter)
          call this%mlbddc_coarse%free_symbolic_setup()
          call this%mlbddc_coarse%free_clean()
          deallocate (this%mlbddc_coarse, stat=istat)
          check (istat==0)
        end if  
        
        if ( associated(this%coarse_grid_matrix) ) then
          call this%coarse_grid_matrix%free()
          deallocate  ( this%coarse_grid_matrix, stat = istat )
          check( istat == 0 )
        end if  
     end if
     call this%set_state_created()
  end if
end subroutine base_mlbddc_free_symbolic_setup

subroutine base_mlbddc_free_symbolic_setup_dirichlet_problem(this)
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  assert ( this%am_i_l1_task() )
  call this%A_II%free()
  call this%A_IG%free()
  call this%A_GI%free()
  call this%A_GG%free()
end subroutine base_mlbddc_free_symbolic_setup_dirichlet_problem

subroutine base_mlbddc_free_symbolic_setup_dirichlet_solver(this)
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  assert ( this%am_i_l1_task() )
  call this%dirichlet_solver%free()
end subroutine base_mlbddc_free_symbolic_setup_dirichlet_solver

subroutine base_mlbddc_free_symbolic_setup_constrained_neumann_problem(this)
  implicit none
  class(base_mlbddc_t), intent(inout) :: this
  assert ( this%am_i_l1_task() )
  call this%constrained_neumann_matrix%free()
end subroutine base_mlbddc_free_symbolic_setup_constrained_neumann_problem

subroutine base_mlbddc_free_symbolic_setup_constrained_neumann_solver(this)
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  assert ( this%am_i_l1_task() )
  call this%constrained_neumann_solver%free()
end subroutine base_mlbddc_free_symbolic_setup_constrained_neumann_solver

subroutine base_mlbddc_free_symbolic_setup_coarse_solver(this)
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  assert ( this%am_i_l1_task() )
  call this%coarse_solver%free()
end subroutine base_mlbddc_free_symbolic_setup_coarse_solver

recursive subroutine base_mlbddc_free_numerical_setup(this)
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  type(environment_t)   , pointer       :: par_environment
 
  assert ( this%state_is_start() .or. this%state_is_created() .or. this%state_is_symbolic() .or. this%state_is_numeric() )
  
  if ( this%state_is_numeric() ) then 
     par_environment => this%get_par_environment()
     if ( par_environment%am_i_l1_task() ) then
        if ( par_environment%get_l1_size() > 1 ) then
           call this%free_numerical_setup_dirichlet_solver()
           call this%free_numerical_setup_dirichlet_problem()
           call this%free_numerical_setup_constrained_neumann_solver()
           call this%free_numerical_setup_constrained_neumann_problem()
           call this%free_coarse_grid_basis()
        else if ( par_environment%get_l1_size() == 1 ) then
           call this%free_numerical_setup_coarse_solver()
        end if
     else
        if (associated(this%mlbddc_coarse)) then
           call this%mlbddc_coarse%free_numerical_setup()
        end if 
        if (associated(this%coarse_grid_matrix)) then
           call this%coarse_grid_matrix%free_in_stages(free_numerical_setup)
        end if   
     end if
     call this%set_state_symbolic()
  end if
end subroutine base_mlbddc_free_numerical_setup

subroutine base_mlbddc_free_numerical_setup_dirichlet_problem(this)
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  assert ( this%am_i_l1_task() )
  call this%A_II%free_in_stages(free_numerical_setup)
  call this%A_IG%free_in_stages(free_numerical_setup)
  call this%A_GI%free_in_stages(free_numerical_setup)
  call this%A_GG%free_in_stages(free_numerical_setup)
end subroutine base_mlbddc_free_numerical_setup_dirichlet_problem

subroutine base_mlbddc_free_numerical_setup_dirichlet_solver(this)
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  assert ( this%am_i_l1_task() )
  call this%dirichlet_solver%free_in_stages(free_numerical_setup)
end subroutine base_mlbddc_free_numerical_setup_dirichlet_solver

subroutine base_mlbddc_free_numerical_setup_constrained_neumann_problem(this)
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  assert ( this%am_i_l1_task() )
  call this%constrained_neumann_matrix%free_in_stages(free_numerical_setup)
end subroutine base_mlbddc_free_numerical_setup_constrained_neumann_problem

subroutine base_mlbddc_free_numerical_setup_constrained_neumann_solver(this)
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  assert ( this%am_i_l1_task() )
  call this%constrained_neumann_solver%free_in_stages(free_numerical_setup)
end subroutine base_mlbddc_free_numerical_setup_constrained_neumann_solver

subroutine base_mlbddc_free_coarse_grid_basis ( this ) 
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  assert ( this%am_i_l1_task() )
  if ( allocated ( this%Phi ) ) then
     call memfree ( this%Phi, __FILE__, __LINE__ )
  end if
end subroutine base_mlbddc_free_coarse_grid_basis

subroutine base_mlbddc_free_numerical_setup_coarse_solver ( this )
  implicit none
  class(base_mlbddc_t)           , intent(inout) :: this
  type(environment_t)  , pointer :: par_environment
  par_environment => this%get_par_environment()
  assert ( par_environment%get_l1_size() == 1 )
  assert ( par_environment%am_i_l1_task() )
  call this%coarse_solver%free_in_stages(free_numerical_setup)
end subroutine base_mlbddc_free_numerical_setup_coarse_solver

function base_mlbddc_am_i_l1_task(this)
  implicit none
  class(base_mlbddc_t), intent(in) :: this
  logical :: base_mlbddc_am_i_l1_task
  type(environment_t)   , pointer   :: par_environment
  par_environment => this%get_par_environment()
  base_mlbddc_am_i_l1_task = par_environment%am_i_l1_task()
end function base_mlbddc_am_i_l1_task

function base_mlbddc_is_linear( this )
  implicit none
  class(base_mlbddc_t)          , intent(in) :: this
  logical :: base_mlbddc_is_linear
  base_mlbddc_is_linear = .true.
end function base_mlbddc_is_linear

function base_mlbddc_get_par_environment(this)
  implicit none
  class(base_mlbddc_t), target, intent(in) :: this
  class(environment_t), pointer :: base_mlbddc_get_par_environment
  base_mlbddc_get_par_environment => this%environment
end function base_mlbddc_get_par_environment

subroutine base_mlbddc_set_par_environment(this, environment)
  implicit none
  class(base_mlbddc_t)       , intent(inout) :: this
  class(environment_t), target, intent(in)    :: environment
  this%environment => environment
end subroutine base_mlbddc_set_par_environment

function base_mlbddc_is_operator_associated( this )
  implicit none
  class(base_mlbddc_t)          , intent(in) :: this
  logical :: base_mlbddc_is_operator_associated
  assert(.false.)
end function base_mlbddc_is_operator_associated

subroutine base_mlbddc_nullify_operator ( this )
  implicit none
  class(base_mlbddc_t), intent(inout) :: this
  assert(.false.)
end subroutine base_mlbddc_nullify_operator 

function base_mlbddc_get_par_sparse_matrix(this)
  implicit none
  class(base_mlbddc_t), intent(in) :: this
  type(par_sparse_matrix_t), pointer :: base_mlbddc_get_par_sparse_matrix
  assert(.false.)
end function base_mlbddc_get_par_sparse_matrix

function base_mlbddc_get_fe_space(this)
  implicit none
  class(base_mlbddc_t), intent(in) :: this
  class(base_fe_space_t) , pointer :: base_mlbddc_get_fe_space
  assert(.false.)
end function base_mlbddc_get_fe_space

subroutine base_mlbddc_create_vector_spaces(this)
  implicit none
  class(base_mlbddc_t), intent(inout) :: this
  assert(.false.)
end subroutine base_mlbddc_create_vector_spaces
