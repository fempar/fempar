! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
subroutine serial_fe_space_create_same_reference_fes_on_all_cells( this,          &
                                                                   triangulation, &
                                                                   reference_fes, &
                                                                   conditions,    &
                                                                   field_blocks,  &
                                                                   field_coupling, &
                                                                   generate_global_dof_numbering)
  implicit none
  class(serial_fe_space_t)                     , intent(inout) :: this
  class(triangulation_t)            , target   , intent(in)    :: triangulation
  type(p_reference_fe_t)                       , intent(in)    :: reference_fes(:)
  class(conditions_t)               , target   , optional, intent(in)    :: conditions
  integer(ip)                       , optional , intent(in)    :: field_blocks(:)
  logical                           , optional , intent(in)    :: field_coupling(:,:)
  logical                           , optional , intent(in)    :: generate_global_dof_numbering

  integer(ip) :: i, istat, jfield, ifield
  logical :: perform_numbering

  call this%free()

  call this%set_triangulation(triangulation)
  call this%set_environment(triangulation%get_environment())
  call this%set_num_fields(size(reference_fes))
  call this%allocate_and_fill_reference_fes(reference_fes)
  call this%allocate_and_fill_set_ids_to_reference_fes(  RESHAPE([(i, i=1,size(reference_fes))], [size(reference_fes),1]) )
  call this%allocate_field_cell_to_ref_fes()
  call this%fill_field_cell_to_ref_fes_same_on_all_cells()
  call this%check_cell_vs_fe_topology_consistency()
  call this%allocate_and_fill_fe_space_type_x_field()
  call this%fill_facet_gids()
  call this%allocate_and_init_ptr_lst_dofs_gids()
  
  if ( present(conditions) ) call this%set_conditions(conditions)
  call this%allocate_and_init_at_strong_dirichlet_bound()
  call this%allocate_and_init_has_fixed_dofs()
  call this%allocate_and_init_has_hanging_dofs_x_fe()
  call this%set_up_strong_dirichlet_bcs()
  
  call this%block_layout%create(this%get_num_fields(),&
                                field_blocks, &
                                field_coupling)
  
  if ( present(generate_global_dof_numbering) ) then
    if ( generate_global_dof_numbering ) then
      call this%generate_global_dof_numbering()
    end if 
  else
    call this%generate_global_dof_numbering()
  end if 
  
end subroutine serial_fe_space_create_same_reference_fes_on_all_cells

subroutine serial_fe_space_create_different_ref_fes_between_cells( this,             &
                                                           triangulation,            &
                                                           reference_fes,            &
                                                           set_ids_to_reference_fes, &
                                                           conditions,               &
                                                           field_blocks,             &
                                                           field_coupling,           &
                                                           generate_global_dof_numbering )
  implicit none
  class(serial_fe_space_t)                    , intent(inout) :: this
  class(triangulation_t)    , target          , intent(in)    :: triangulation
  type(p_reference_fe_t)                      , intent(in)    :: reference_fes(:)
  integer(ip)                                 , intent(in)    :: set_ids_to_reference_fes(:,:)
  class(conditions_t)       , target, optional, intent(in)    :: conditions
  integer(ip)                       , optional , intent(in)   :: field_blocks(:)
  logical                           , optional , intent(in)   :: field_coupling(:,:)
  logical                           , optional , intent(in)   :: generate_global_dof_numbering

  call this%free()
  
  call this%set_triangulation(triangulation)
  call this%set_environment(triangulation%get_environment())
  call this%set_num_fields(size(set_ids_to_reference_fes,1))
  call this%allocate_and_fill_reference_fes(reference_fes)
  call this%allocate_and_fill_set_ids_to_reference_fes(set_ids_to_reference_fes)
  call this%allocate_field_cell_to_ref_fes()
  call this%fill_field_cell_to_ref_fes_different_ref_fes_between_cells(set_ids_to_reference_fes)
  call this%check_cell_vs_fe_topology_consistency()
  call this%allocate_and_fill_fe_space_type_x_field()
  call this%fill_facet_gids()
  call this%allocate_and_init_ptr_lst_dofs_gids()
  
  if ( present(conditions) ) call this%set_conditions(conditions)
  call this%allocate_and_init_at_strong_dirichlet_bound()
  call this%allocate_and_init_has_fixed_dofs()
  call this%allocate_and_init_has_hanging_dofs_x_fe()
  call this%set_up_strong_dirichlet_bcs()
  
  call this%block_layout%create( this%get_num_fields(), &
                                 field_blocks, &
                                 field_coupling ) 
  
  if ( present(generate_global_dof_numbering) ) then
    if ( generate_global_dof_numbering ) then
      call this%generate_global_dof_numbering()
    end if 
  else
    call this%generate_global_dof_numbering()
  end if 
  
end subroutine serial_fe_space_create_different_ref_fes_between_cells

subroutine serial_fe_space_free (this)
  implicit none
  class(serial_fe_space_t)    , intent(inout) :: this
  call this%free_reference_fes()
  call this%free_set_ids_to_reference_fes()
  call this%free_field_cell_to_ref_fes()
  call this%free_fe_space_type_x_field()
  call this%free_facet_gids()
  call this%free_ptr_lst_dofs()
  call this%free_at_strong_dirichlet_boundary()
  call this%free_has_fixed_dofs()
  nullify(this%conditions)
  this%num_fixed_dofs = 0
  if (allocated(this%num_dofs_x_field)) call memfree( this%num_dofs_x_field, __FILE__, __LINE__ )
  call this%free_fe_integration()
  call this%free_facet_integration()
  this%num_hanging_dofs = 0
  this%num_dirichlet_dofs = 0
  call this%free_has_hanging_dofs_x_fe()
  call this%free_constraining_dofs_arrays()
  call this%block_layout%free()
  nullify(this%triangulation)
  nullify(this%environment)
end subroutine serial_fe_space_free

subroutine serial_fe_space_free_constraining_dofs_arrays (this)
  implicit none
  class(serial_fe_space_t)    , intent(inout) :: this
  call this%free_ptr_constraining_free_dofs()
  call this%free_constraining_free_dofs
  call this%free_constraining_free_dofs_coefficients
  call this%free_ptr_constraining_dirichlet_dofs()
  call this%free_constraining_dirichlet_dofs
  call this%free_constraining_dirichlet_dofs_coefficients
  call this%free_constraints_independent_term
end subroutine serial_fe_space_free_constraining_dofs_arrays

subroutine serial_fe_space_print ( this )
  class(serial_fe_space_t), intent(in)    :: this
  class(fe_cell_iterator_t), allocatable :: fe
  type(i1p_t), allocatable         :: fe_dofs(:)
  integer(ip)                      :: field_id, istat

  if (allocated(this%num_dofs_x_field)) write(*,'(a,i10,a)') '********* num_dofs_x_field ',this%num_dofs_x_field,'********'

  allocate ( fe_dofs(this%get_num_fields()), stat=istat)
  check(istat==0)

  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe%has_finished())
     write(*,'(a,i10,a)') '********* ELEMENT: ',fe%get_gid(),'********'
     write(*,'(a)') '********* ELEMENT 2 DOF********'
     call fe%get_fe_dofs(fe_dofs)
     do field_id = 1, fe%get_num_fields()
        write(*,'(a,i10,a)') '********* FIELD: ',field_id,'********'
        write(*,'(10i10)') fe_dofs(field_id)%p
     end do
     call fe%next()
  end do
  call this%free_fe_cell_iterator(fe)

  deallocate ( fe_dofs, stat=istat)
  check(istat==0)
end subroutine serial_fe_space_print


subroutine serial_fe_space_allocate_and_fill_fe_space_type_x_field(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  class(fe_cell_iterator_t), allocatable :: fe
  integer(ip) :: field_id
  class(reference_fe_t), pointer ::reference_fe
  call this%free_fe_space_type_x_field()
  call memalloc ( this%num_fields, this%fe_space_type_x_field, __FILE__, __LINE__ )
  do field_id=1, this%get_num_fields()
    this%fe_space_type_x_field(field_id) = this%determine_fe_space_type(field_id)
  end do
#ifdef DEBUG  
  call this%create_fe_cell_iterator(fe)
  call fe%next()
  do while ( .not. fe%has_finished())
     do field_id=1, this%get_num_fields()
        assert ( this%fe_space_type_x_field(field_id) == fe%get_fe_space_type(field_id)  )
     end do
     call fe%next()
  end do
  call this%free_fe_cell_iterator(fe)
#endif  
end subroutine serial_fe_space_allocate_and_fill_fe_space_type_x_field

subroutine serial_fe_space_free_fe_space_type_x_field(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  if ( allocated(this%fe_space_type_x_field) ) call memfree ( this%fe_space_type_x_field, __FILE__, __LINE__ )
end subroutine serial_fe_space_free_fe_space_type_x_field

subroutine serial_fe_space_allocate_and_init_ptr_lst_dofs_gids(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this

  integer(ip)                    :: field_id
  class(fe_cell_iterator_t), allocatable :: fe
  class(reference_fe_t), pointer :: reference_fe
  integer(ip)                    :: error

  if ( .not. allocated(this%ptr_dofs_x_fe) ) then
    allocate( this%ptr_dofs_x_fe(this%num_fields), stat = error ); check ( error == 0 )
  end if
  
  do field_id = 1,this%num_fields
    call this%ptr_dofs_x_fe(field_id)%resize(this%triangulation%get_num_cells()+1)
  end do
  
  call this%ptr_dofs_x_fe(1)%set(1,1) 
  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe%has_finished())
     do field_id=1, fe%get_num_fields()-1
        reference_fe => fe%get_reference_fe(field_id)
        call this%ptr_dofs_x_fe(field_id+1)%set( fe%get_gid(), & 
             this%ptr_dofs_x_fe(field_id)%get(fe%get_gid()) + reference_fe%get_num_shape_functions() )
     end do
     reference_fe => fe%get_reference_fe(field_id)
     call this%ptr_dofs_x_fe(1)%set( fe%get_gid()+1, & 
          this%ptr_dofs_x_fe(field_id)%get(fe%get_gid()) + reference_fe%get_num_shape_functions() )
     call fe%next()
  end do
  call this%free_fe_cell_iterator(fe) 
  
  call this%lst_dofs_gids%resize(0)
  call this%lst_dofs_gids%resize(this%ptr_dofs_x_fe(1)%get(this%triangulation%get_num_cells()+1)-1,0)

end subroutine serial_fe_space_allocate_and_init_ptr_lst_dofs_gids

subroutine serial_fe_space_copy_ptr_lst_dofs ( this, ptr_dofs_x_fe, lst_dofs_gids )
  implicit none
  class(serial_fe_space_t)                  , intent(inout) :: this
  type(std_vector_integer_ip_t), allocatable, intent(inout) :: ptr_dofs_x_fe(:)
  type(std_vector_integer_ip_t)             , intent(inout) :: lst_dofs_gids
  integer(ip) :: field_id, error
  assert ( .not. allocated(ptr_dofs_x_fe) )
  allocate( ptr_dofs_x_fe(this%num_fields), stat = error ); check( error == 0 )
  do field_id = 1,this%num_fields
    call ptr_dofs_x_fe(field_id)%copy(this%ptr_dofs_x_fe(field_id))
  end do
  call lst_dofs_gids%copy(this%lst_dofs_gids)
end subroutine serial_fe_space_copy_ptr_lst_dofs

subroutine serial_fe_space_free_ptr_lst_dofs(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip) :: field_id, error
  if ( allocated(this%ptr_dofs_x_fe) ) then
    do field_id = 1,this%num_fields
      call this%ptr_dofs_x_fe(field_id)%free()
    end do
    deallocate( this%ptr_dofs_x_fe, stat = error ) ; check( error == 0 )
  end if
  call this%lst_dofs_gids%free()
end subroutine serial_fe_space_free_ptr_lst_dofs

subroutine serial_fe_space_allocate_and_init_at_strong_dirichlet_bound(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip) :: field_id, error
  if ( .not. allocated( this%at_strong_dirichlet_boundary_x_fe ) ) then
    allocate( this%at_strong_dirichlet_boundary_x_fe(this%num_fields), stat = error ) ; check( error == 0 )
  end if
  do field_id = 1,this%num_fields
    call this%at_strong_dirichlet_boundary_x_fe(field_id)%resize(0)
    call this%at_strong_dirichlet_boundary_x_fe(field_id)%resize(this%triangulation%get_num_cells(),.false.)
  end do
end subroutine serial_fe_space_allocate_and_init_at_strong_dirichlet_bound

subroutine serial_fe_space_free_at_strong_dirichlet_boundary (this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip) :: field_id, error
  if ( allocated(this%at_strong_dirichlet_boundary_x_fe) ) then
    do field_id = 1,this%num_fields
      call this%at_strong_dirichlet_boundary_x_fe(field_id)%free()
    end do
    deallocate( this%at_strong_dirichlet_boundary_x_fe, stat = error ) ; check ( error == 0 )
  end if
end subroutine serial_fe_space_free_at_strong_dirichlet_boundary

subroutine serial_fe_space_allocate_and_init_has_fixed_dofs(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip) :: field_id, error
  if ( .not. allocated( this%has_fixed_dofs_x_fe ) ) then
    allocate( this%has_fixed_dofs_x_fe(this%num_fields), stat = error ) ; check( error == 0 )
  end if
  do field_id = 1,this%num_fields
    call this%has_fixed_dofs_x_fe(field_id)%resize(0)
    call this%has_fixed_dofs_x_fe(field_id)%resize(this%triangulation%get_num_cells(),.false.)
  end do
end subroutine serial_fe_space_allocate_and_init_has_fixed_dofs

subroutine serial_fe_space_free_has_fixed_dofs(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip) :: field_id, error
  if ( allocated(this%has_fixed_dofs_x_fe) ) then
    do field_id = 1,this%num_fields
      call this%has_fixed_dofs_x_fe(field_id)%free()
    end do
    deallocate( this%has_fixed_dofs_x_fe, stat = error ) ; check ( error == 0 )
  end if
end subroutine serial_fe_space_free_has_fixed_dofs

subroutine serial_fe_space_set_up_strong_dirichlet_bcs( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this

  integer(ip)             :: field_id
  integer(ip)             :: ivef
  integer(ip)             :: component_id
  integer(ip), allocatable :: offset_component_x_field(:)
  integer(ip)             :: istat
  class(fe_cell_iterator_t), allocatable :: fe, source_fe
  class(fe_cell_iterator_t), allocatable :: coarser_fe
  type(fe_vef_iterator_t)    :: vef
  class(reference_fe_t), pointer :: reference_fe
  logical              , allocatable :: components_code(:)
  integer(ip), allocatable           :: visited_proper_vef_to_cell_map(:,:)
  integer(ip), allocatable           :: visited_improper_vef_to_cell_map(:,:)
  integer(ip)                        :: previous_num_dirichlet_dofs
  class(triangulation_t), pointer :: triangulation
  
  
  ! Count num_dirichlet_dofs
  this%num_dirichlet_dofs = 0
  
  triangulation => this%get_triangulation()
  
  if ( .not. associated(this%conditions) .or. triangulation%get_num_cells() == 0 ) then
    return
  end if
  
  ! For every component of every field, we go through all FEs and look for DoFs 
  ! subject to strong Dirichlet BCs. It would be desirable (for efficiency) to 
  ! know a priori which FEs have DoFs which are subject to strong Dirichlet BCs, 
  ! but at the present moment we do not have any way to determine such a thing
  assert ( this%conditions%get_num_components() == this%get_num_components() )
  call memalloc ( this%conditions%get_num_components(), components_code, __FILE__, __LINE__ )

  call memalloc (this%get_num_fields()+1,offset_component_x_field,__FILE__,__LINE__)
  call memalloc ( 2, this%triangulation%get_num_proper_vefs(), visited_proper_vef_to_cell_map,  __FILE__, __LINE__ )
  call memalloc ( 2, this%triangulation%get_num_improper_vefs(), visited_improper_vef_to_cell_map,  __FILE__, __LINE__ )

  call this%create_fe_cell_iterator(fe)
  call this%create_fe_cell_iterator(coarser_fe)
  call this%create_fe_cell_iterator(source_fe)
  call this%create_fe_vef_iterator(vef)

  ! Precompute the offsets
  offset_component_x_field(1) = 1
  do field_id = 1, this%get_num_fields()
    reference_fe => fe%get_reference_fe(field_id)
    offset_component_x_field(field_id+1) = offset_component_x_field(field_id) + reference_fe%get_num_field_components()
  end do

  do field_id = 1, this%get_num_fields()
    ! Initialize
    visited_proper_vef_to_cell_map = -1
    visited_improper_vef_to_cell_map = -1

    call fe%first()
    do while (.not. fe%has_finished() )
         do ivef = 1, fe%get_num_vefs()
            call fe%get_vef(ivef, vef)
            
            if ( .not. vef%is_ghost() ) then

             ! Check whether a set_id different from 0 has been set for current vef. 
             !        "0" is a magic number. MUCH BETTER REPLACE by parameter constant.
             if ( vef%get_set_id() /= 0 .and. vef%all_coarser_cells_are_void(field_id, coarser_fe) ) then

               ! Get components code corresponding to set_id assigned to current vef
               ! TO-DO: The number of calls to this TBP (virtual) could be reduced by using
               ! a more clever strategy. Does pay off to look carefully at this?
               call this%conditions%get_components_code( vef%get_set_id(), components_code )

               ! Auxiliary function containing the work done at each innermost iteration
               previous_num_dirichlet_dofs = this%num_dirichlet_dofs
               
               if ( vef%is_proper() ) then
                 call this%set_up_strong_dirichlet_bcs_on_vef_and_field(fe,&
                                                                        vef,&
                                                                        ivef,&
                                                                        field_id,&
                                                                        components_code(offset_component_x_field(field_id):&
                                                                                        offset_component_x_field(field_id+1)-1),&
                                                                        visited_proper_vef_to_cell_map,&
                                                                        source_fe)

                 if ( visited_proper_vef_to_cell_map(1, vef%get_gid()) == -1 .and. &
                      previous_num_dirichlet_dofs < this%num_dirichlet_dofs ) then
                    visited_proper_vef_to_cell_map ( 1, vef%get_gid() ) = fe%get_gid()
                    visited_proper_vef_to_cell_map ( 2, vef%get_gid() ) = ivef
                 end if
               else
                 call this%set_up_strong_dirichlet_bcs_on_vef_and_field(fe,&
                                                                        vef,&
                                                                        ivef,&
                                                                        field_id,&
                                                                        components_code(offset_component_x_field(field_id):&
                                                                                        offset_component_x_field(field_id+1)-1),&
                                                                        visited_improper_vef_to_cell_map,&
                                                                        source_fe)

                 if ( visited_improper_vef_to_cell_map(1, abs(vef%get_gid())) == -1 .and. &
                      previous_num_dirichlet_dofs < this%num_dirichlet_dofs ) then
                    visited_improper_vef_to_cell_map ( 1, abs(vef%get_gid()) ) = fe%get_gid()
                    visited_improper_vef_to_cell_map ( 2, abs(vef%get_gid()) ) = ivef
                 end if               
               end if 
             end if
            end if
         end do
      call fe%next()
    end do ! Loop in FEs
  end do ! Loop in fields
  ! This second sweep over all cells cannot be integrated as part of the first one
  ! as the fe%determine_* TBPs have as a pre-condition that this%strong_dirichlet_values
  ! has at least been created (i.e., that it has at least size already set)
  call fe%first()
  do while (.not. fe%has_finished() )
    do field_id = 1, this%get_num_fields()
      call fe%determine_at_strong_dirichlet_boundary(field_id)
    end do
    call fe%next()
  end do
  
  this%num_fixed_dofs = this%num_dirichlet_dofs

  call memfree ( visited_proper_vef_to_cell_map,  __FILE__, __LINE__ )
  call memfree ( visited_improper_vef_to_cell_map,  __FILE__, __LINE__ )
  call memfree ( components_code, __FILE__, __LINE__ )
  call memfree (offset_component_x_field,__FILE__,__LINE__)
  call this%free_fe_cell_iterator(fe)
  call this%free_fe_cell_iterator(source_fe)
  call this%free_fe_vef_iterator(vef)
  call this%free_fe_cell_iterator(coarser_fe)
end subroutine serial_fe_space_set_up_strong_dirichlet_bcs

subroutine serial_fe_space_set_up_strong_dirichlet_bcs_on_vef_and_field(this,&
                                                                        fe, &
                                                                        vef, &
                                                                        ivef, &
                                                                        field_id,&
                                                                        components_code,&
                                                                        visited_vef_to_cell_map,&
                                                                        source_fe)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  class(fe_cell_iterator_t),     intent(inout) :: fe
  type(fe_vef_iterator_t),  intent(in)    :: vef
  integer(ip),              intent(in)    :: ivef
  integer(ip),              intent(in)    :: field_id
  logical,                  intent(in)    :: components_code(:)
  integer(ip),              intent(inout) :: visited_vef_to_cell_map(:,:)
  class(fe_cell_iterator_t),     intent(inout) :: source_fe

  type(list_iterator_t)           :: own_dofs_on_vef_iterator
  class(reference_fe_t), pointer  :: reference_fe

  ! TO-DO: there is no need to call `get_reference_fe` for each inner loop iteration.
  !        We could use an allocatable array of type(p_reference_fe_t) items, and
  !        allocate/initialize it from the beginning.
  reference_fe => fe%get_reference_fe(field_id)
  assert ( size(components_code) == reference_fe%get_num_field_components() )
  
  select type ( reference_fe )
     class is ( nedelec_reference_fe_t )
     if ( components_code(1) ) then
       if ( visited_vef_to_cell_map(1, abs(vef%get_gid())) == -1 ) then
           call fe%generate_own_dofs_vef ( ivef, &
                                          field_id, &
                                          this%num_dirichlet_dofs, &
                                          free_dofs_loop=.false.)
       end if
     end if
     class is ( lagrangian_reference_fe_t )
     if ( visited_vef_to_cell_map(1, abs(vef%get_gid())) == -1 ) then
       call fe%generate_own_dofs_vef_component_wise ( ivef, &
                                                     field_id, &
                                                     this%num_dirichlet_dofs, &
                                                     components_code, &
                                                     free_dofs_loop=.false. )
     end if
  end select
  
  if ( visited_vef_to_cell_map(1, abs(vef%get_gid())) /= -1 ) then
    call source_fe%set_gid(visited_vef_to_cell_map(1,abs(vef%get_gid())))
    call fe%fetch_own_dofs_vef_from_source_fe ( ivef, &
                                                source_fe, &
                                                visited_vef_to_cell_map(2,abs(vef%get_gid())), &
                                                field_id) 
  end if
end subroutine serial_fe_space_set_up_strong_dirichlet_bcs_on_vef_and_field

function select_default_interpolator_type(reference_fe) 
  implicit none
  class(reference_fe_t), intent(in) :: reference_fe
  character(:), allocatable :: select_default_interpolator_type
  
  select type ( reference_fe )
  class is (nedelec_reference_fe_t ) 
    select_default_interpolator_type = interpolator_type_Hcurl
  class is (lagrangian_reference_fe_t)
    select_default_interpolator_type = interpolator_type_nodal  
  class is (void_reference_fe_t)
    check(.false.)
  class DEFAULT
  check(.false.) 
  end select 
end function select_default_interpolator_type 

subroutine serial_fe_space_interpolate_scalar_function (this, field_id, function, fe_function, interpolator_type, time)
  implicit none
  class(serial_fe_space_t)         , intent(in)    :: this
  integer(ip)                      , intent(in)    :: field_id
  class(scalar_function_t)         , intent(in)    :: function 
  type(fe_function_t)              , intent(inout) :: fe_function
  character(*)           , optional, intent(in)    :: interpolator_type
  real(rp)               , optional, intent(in)    :: time

  class(reference_fe_t)    , pointer     :: reference_fe 
  class(fe_cell_iterator_t), allocatable :: fe 
  class(fe_cell_iterator_t), allocatable :: aux_fe
  type(fe_vef_iterator_t)                :: vef
  real(rp)                 , allocatable :: dof_values(:)
  class(interpolator_t)    , allocatable :: interpolator
  character(:)             , allocatable :: interpolator_type_
  logical                                :: is_void_field 
  class(triangulation_t)   , pointer     :: triangulation 
  integer(ip)                            :: vef_lid
  integer(ip)                            :: ielem  
  logical                                :: local_found 

  triangulation => this%get_triangulation() 
  if ( triangulation%get_num_cells() == 0) return 

  ! Extract reference_fe_t instance associated to field_id for the first non-void element 
  call this%create_fe_cell_iterator(fe)
  call this%create_fe_cell_iterator(aux_fe)
  call this%create_fe_vef_iterator(vef)

  is_void_field = .true. 
  do while (  (.not. fe%has_finished() )) 
     if ( .not. fe%is_void(field_id)) then 
        is_void_field = .false.; exit 
     end if
     call fe%next() 
  end do

  ! I am already located at the first non-void FE, if it exists
  if ( .not. is_void_field ) then 
     reference_fe => fe%get_reference_fe(field_id)
     call memalloc( reference_fe%get_num_shape_functions(), dof_values, __FILE__, __LINE__ )

     ! Process optional arguments
     if ( present(interpolator_type) ) then
        interpolator_type_ = interpolator_type
     else
        interpolator_type_  = select_default_interpolator_type(reference_fe)
     end if

     call make_interpolator  (interpolator_type_, reference_fe%get_topology(), interpolator )
     call interpolator%create(this, field_id)
     do while (.not. fe%has_finished() )  
        local_found=.true. 
        if ( .not. fe%is_local() .and. .not. fe%is_void(field_id) ) then 
           vef_loop: do vef_lid = 1, fe%get_num_vefs() 
              call fe%get_vef(vef_lid, vef)
              if ( .not. vef%is_ghost() .and. vef%is_proper() ) then
                 local_found = .false.
                 do ielem=1, vef%get_num_cells_around()
                    call vef%get_cell_around(ielem, aux_fe)
                    if (aux_fe%is_local()) then
                       local_found = .true.
                       exit 
                    end if
                 end do
                 if (.not. local_found) exit vef_loop 
              end if
           end do vef_loop
        end if

        if ( (fe%is_local() .and. .not. fe%is_void(field_id)) .or. .not. local_found) then
           call interpolator%evaluate_scalar_function_moments( fe, function, dof_values, time=time )
           call fe_function%insert_nodal_values(fe, field_id, dof_values) 
        end if
        call fe%next()
     end do
     call memfree( dof_values, __FILE__, __LINE__ )
     call interpolator%free() 
  end if

  call this%update_hanging_dof_values(fe_function)
  call this%free_fe_cell_iterator(fe) 
  call this%free_fe_cell_iterator(aux_fe)
  call this%free_fe_vef_iterator(vef)
end subroutine serial_fe_space_interpolate_scalar_function

subroutine serial_fe_space_interpolate_vector_function (this, field_id, function, fe_function, interpolator_type, time)
  implicit none
  class(serial_fe_space_t)         , intent(in)    :: this
  integer(ip)                      , intent(in)    :: field_id
  class(vector_function_t)         , intent(in)    :: function 
  type(fe_function_t)              , intent(inout) :: fe_function
  character(*)           , optional, intent(in)    :: interpolator_type
  real(rp)               , optional, intent(in)    :: time

  class(reference_fe_t)    , pointer     :: reference_fe 
  class(fe_cell_iterator_t), allocatable :: fe 
  class(fe_cell_iterator_t), allocatable :: aux_fe
  type(fe_vef_iterator_t)                :: vef
  real(rp)                 , allocatable :: dof_values(:)
  class(interpolator_t)    , allocatable :: interpolator
  character(:)             , allocatable :: interpolator_type_
  logical                  , allocatable :: is_void_field  
  class(triangulation_t)   , pointer     :: triangulation 
  integer(ip)                            :: vef_lid
  integer(ip)                            :: ielem  
  logical                                :: local_found 

  triangulation => this%get_triangulation() 
  if ( triangulation%get_num_cells() == 0) return 

  ! Extract reference_fe_t instance associated to field_id for the first non-void element 
  call this%create_fe_cell_iterator(fe)
  call this%create_fe_cell_iterator(aux_fe)
  call this%create_fe_vef_iterator(vef)

  is_void_field = .true. 
  do while (  (.not. fe%has_finished() )) 
     if ( .not. fe%is_void(field_id) ) then 
        is_void_field = .false.; exit 
     end if
     call fe%next() 
  end do

  ! I am already located at the first non-void FE, if it exists 
  if ( .not. is_void_field ) then    
     reference_fe => fe%get_reference_fe(field_id)
     call memalloc( reference_fe%get_num_shape_functions(), dof_values, __FILE__, __LINE__ )

     ! Process optional arguments
     if ( present(interpolator_type) ) then
        interpolator_type_ = interpolator_type
     else
        interpolator_type_  = select_default_interpolator_type(reference_fe)
     end if

     call make_interpolator  (interpolator_type_, reference_fe%get_topology(), interpolator )
     call interpolator%create(this, field_id)
     do while (.not. fe%has_finished() )  
        local_found=.true. 
        if ( .not. fe%is_local() .and. .not. fe%is_void(field_id) ) then 
           vef_loop: do vef_lid = 1, fe%get_num_vefs() 
              call fe%get_vef(vef_lid, vef)
              if ( .not. vef%is_ghost() .and. vef%is_proper() ) then
                 local_found = .false.
                 do ielem=1, vef%get_num_cells_around()
                    call vef%get_cell_around(ielem, aux_fe)
                    if (aux_fe%is_local()) then
                       local_found = .true.
                       exit 
                    end if
                 end do
                 if (.not. local_found) exit vef_loop
              end if
           end do vef_loop
        end if

        if ( (fe%is_local() .and. .not. fe%is_void(field_id)) .or. .not. local_found ) then
           call interpolator%evaluate_vector_function_moments( fe, function, dof_values, time=time )
           call fe_function%insert_nodal_values(fe, field_id, dof_values)
        end if

        call fe%next()
     end do
     call memfree( dof_values, __FILE__, __LINE__ ) 
     call interpolator%free() 
  end if

  call this%update_hanging_dof_values(fe_function)
  call this%free_fe_cell_iterator(fe)
  call this%free_fe_cell_iterator(aux_fe)
  call this%free_fe_vef_iterator(vef)
end subroutine serial_fe_space_interpolate_vector_function

subroutine serial_fe_space_interpolate_dirichlet_values (this, fe_function, interpolator_type, time)
  implicit none
  class(serial_fe_space_t)          , intent(in)    :: this
  type(fe_function_t)               , intent(inout) :: fe_function
  character(*)            , optional, intent(in)    :: interpolator_type(:)
  real(rp)                , optional, intent(in)    :: time

  class(reference_fe_t)    , pointer        :: reference_fe 
  class(fe_cell_iterator_t), allocatable    :: fe 
  class(fe_cell_iterator_t), allocatable    :: coarser_fe 
  class(fe_cell_iterator_t), allocatable    :: aux_fe 
  type(fe_vef_iterator_t)                   :: vef 
  type(list_iterator_t)                     :: own_dofs_on_vef_iterator  

  integer(ip)                :: field_id 
  integer(ip)                :: icomp, component_id 
  logical     , allocatable  :: components_code(:)
  integer(ip) , allocatable  :: offset_component(:)

  type(p_scalar_function_t), allocatable :: function_scalar_components(:,:)
  real(rp)                 , allocatable :: dof_values(:)  
  integer(ip)              , pointer     :: fe_dofs(:)
  real(rp)                 , pointer     :: fixed_dof_values_entries(:)
  integer(ip)                            :: idof, vef_lid, istat
  type(p_interpolator_t)   , allocatable :: interpolators(:) 
  character(:)             , allocatable :: interpolator_type_
  logical                  , allocatable :: is_void_field(:) 
  logical                  , allocatable :: n_face_mask(:,:) 
  logical                                :: reallocate 
  logical                                :: local_found
  integer(ip)                            :: ielem
  class(triangulation_t), pointer        :: triangulation 
  
  triangulation => this%get_triangulation()
  if ( triangulation%get_num_cells() == 0 ) return
  
  call this%create_fe_cell_iterator(fe) 
  call this%create_fe_cell_iterator(coarser_fe) 
  call this%create_fe_cell_iterator(aux_fe)
  call memalloc( this%get_num_fields(), is_void_field, __FILE__, __LINE__ ) 

  ! Create and initialize interpolators 
  allocate ( interpolators(this%get_num_fields()), stat=istat); check(istat==0)  
  do field_id = 1, this%get_num_fields() 

     call fe%first() 
     is_void_field(field_id) = .true. 
     do while (  (.not. fe%has_finished() )) 
        if ( .not. fe%is_void(field_id) ) then 
           is_void_field(field_id) = .false.
           exit 
        end if
        call fe%next() 
     end do

     if ( .not. is_void_field(field_id) ) then 
        reference_fe => fe%get_reference_fe(field_id)

        if ( present(interpolator_type) ) then
           interpolator_type_ = interpolator_type(field_id)
        else
           interpolator_type_  = select_default_interpolator_type(reference_fe)
        end if

        call make_interpolator( interpolator_type_, reference_fe%get_topology(), interpolators(field_id)%p )  
        call interpolators(field_id)%p%create( this, field_id ) 
     end if

  end do

  call this%create_fe_vef_iterator(vef)
  fixed_dof_values_entries => fe_function%fixed_dof_values%get_entries()

  call this%allocate_and_fill_offset_component(offset_component)
  assert(associated(this%conditions) )
  call memalloc ( this%get_num_components(), components_code, __FILE__, __LINE__ )

  do field_id = 1, this%get_num_fields()
     if ( .not. is_void_field(field_id) ) then 
        call fe%first() 
        do while (.not. fe%has_finished() )     
           if ( fe%at_strong_dirichlet_boundary(field_id) .and. (.not. fe%is_void(field_id)) ) then 
              reference_fe => fe%get_reference_fe(field_id) 
              ! Allocate field-dependent values at the first non-void FE 
              if ( .not. (allocated(dof_values) )) call memalloc( reference_fe%get_num_shape_functions(), dof_values, __FILE__, __LINE__ ) 
              ! Reallocate FE dependent arrays if necessary. Mixed topology case ..? 
              reallocate = .false.
              if (allocated(n_face_mask)) reallocate = ( size(n_face_mask,2) < fe%get_num_vefs() )                                      
              if ( (.not. allocated(n_face_mask)) .or. reallocate) then
                 if (allocated(n_face_mask)) call memfree(n_face_mask, __FILE__,__LINE__); 
                 call memalloc(this%triangulation%get_num_dims(), fe%get_num_vefs(), n_face_mask, __FILE__,__LINE__);
              end if
              reallocate = .false.
              if (allocated(function_scalar_components)) reallocate = ( size(function_scalar_components,2) < fe%get_num_vefs() )                                      
              if ( (.not. allocated(function_scalar_components)) .or. reallocate) then
                 if (allocated(function_scalar_components)) deallocate(function_scalar_components, stat=istat); check(istat==0)  
                 allocate ( function_scalar_components(this%triangulation%get_num_dims(), fe%get_num_vefs()), stat=istat); check(istat==0)
              end if

              call fe%get_field_fe_dofs(field_id,fe_dofs)

              ! Loop over all vefs in to extract scalar function components over every vef 
              n_face_mask = .false.
              do vef_lid = 1, fe%get_num_vefs() 
                 call fe%get_vef(vef_lid, vef)
                 if ( .not. vef%is_ghost() ) then
                    if ( vef%get_set_id() /= 0 .and. vef%all_coarser_cells_are_void(field_id,coarser_fe) ) then
                       local_found = .false.
                       do ielem=1, vef%get_num_cells_around()
                          call vef%get_cell_around(ielem, aux_fe)
                          if (aux_fe%is_local()) then
                             local_found = .true.
                             exit
                          end if
                       end do

                       if (  fe%is_local() .or. .not. local_found ) then
                          ! Get scalar boundary functions 
                          call this%conditions%get_components_code( vef%get_set_id(), components_code )
                          component_id = offset_component(field_id) + 1
                          do icomp=1, reference_fe%get_num_field_components()
                             if ( components_code(component_id+icomp-1) ) then
                                n_face_mask(icomp, vef_lid) = .true. 
                                ! Retreive the scalar functions corresponding to the components of the function to be projected
                                call this%conditions%get_function(vef%get_set_id(),                 &
                                                                  component_id+icomp-1,             &
                                                                  function_scalar_components(icomp, vef_lid)%p)
                             end if
                          end do
                       end if
                    end if
                 end if
              end do

              ! Evaluate moments on the FE dirichlet boundary 
                 call interpolators(field_id)%p%evaluate_function_scalar_components_moments( n_face_mask,                & 
                                                                                             fe,                         &
                                                                                             function_scalar_components, &
                                                                                             dof_values,                 &
                                                                                             time = time )

                 ! Insert nodal values on vefs at the dirichlet boundary
                 do vef_lid = 1, fe%get_num_vefs() 
                    if ( any(n_face_mask(:,vef_lid)) ) then 
                       own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(vef_lid) 
                       do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() ) 
                          idof = own_dofs_on_vef_iterator%get_current()   
                          if( fe%is_strong_dirichlet_dof(fe_dofs(idof))) then
                             fixed_dof_values_entries(-fe_dofs(idof)) = dof_values(idof) 
                          end if
                          call own_dofs_on_vef_iterator%next()  
                       end do
                    end if
                 end do
              end if
           call fe%next()
        end do
        if (allocated(dof_values)) call memfree( dof_values, __FILE__, __LINE__ )
     end if
  end do

  call this%free_fe_cell_iterator(fe)
  call this%free_fe_cell_iterator(aux_fe)
  call this%free_fe_cell_iterator(coarser_fe)
  call this%free_fe_vef_iterator(vef) 

  do field_id = 1, this%get_num_fields() 
     if ( .not. is_void_field(field_id) ) call interpolators(field_id)%p%free() 
  end do
  deallocate( interpolators, stat=istat); check(istat==0) 

  call memfree( components_code, __FILE__, __LINE__ ) 
  call memfree( offset_component, __FILE__, __LINE__ )
  call memfree( is_void_field, __FILE__, __LINE__ )
  if (allocated(function_scalar_components) ) deallocate( function_scalar_components, stat=istat); check(istat==0)
  if (allocated(n_face_mask) ) call memfree( n_face_mask, __FILE__,__LINE__)

end subroutine serial_fe_space_interpolate_dirichlet_values

subroutine serial_fe_space_project_dirichlet_values_curl_conforming (this, fe_function, time, fields_to_project)
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this
  class(fe_function_t)              , intent(inout) :: fe_function
  real(rp)                , optional, intent(in)    :: time
  integer(ip)             , optional, intent(in)    :: fields_to_project(:)

  !  Locals
  integer(ip)                  , allocatable :: fields_to_project_(:)  
  integer(ip)                                :: field_id, istat
  integer(ip)                                :: component_id
  integer(ip)                  , allocatable :: offset_component(:)
  integer(ip)                                :: num_components
  logical                      , allocatable :: components_code(:)
  type(serial_scalar_array_t)  , pointer     :: strong_dirichlet_values

  class(reference_fe_t)        , pointer     :: reference_fe

  class(fe_cell_iterator_t)     , allocatable :: fe
  class(fe_facet_iterator_t), allocatable :: fe_face

  type(i1p_t), allocatable :: fe_dofs(:)

  type(sparse_matrix_t)       :: matrix
  type(serial_scalar_array_t) :: rhs
  type(serial_scalar_array_t) :: projected_nodal_values
  integer(ip), allocatable    :: subset2global_dirichlet_dofs(:) 
  integer(ip), allocatable    :: global2subset_dirichlet_dofs(:) 
  integer(ip), allocatable    :: subset_fe_dofs(:) 
#ifdef ENABLE_MKL  
  type(direct_solver_t)           :: direct_solver
#else
  type(iterative_linear_solver_t) :: iterative_linear_solver
#endif
  real(rp), allocatable       :: elmat(:,:)
  real(rp), allocatable       :: elvec(:) 
  integer(ip)                 :: qpoint, n_q_points, ishape, jshape


  type(p_scalar_function_t), allocatable :: function_scalar_components(:)
  real(rp)                 , allocatable :: scalar_function_values(:,:)
  type(vector_field_t)     , allocatable :: vector_function_values(:,:)
  type(vector_field_t)     , allocatable :: shape_values(:,:)

  type(parameterlist_t)  :: parameter_list
  integer(ip)            :: FPLError
  integer                :: iparm(64)
  integer(ip)            :: ifield, jfield, idof, idof_subset, idof_global
  integer(ip)            :: num_subset_strong_dirichlet_dofs

  assert ( associated(this%conditions) )
  call memalloc ( this%get_num_components(), components_code, __FILE__, __LINE__ )

  call this%allocate_and_fill_fields_to_project_(fields_to_project_, &
                                                 fields_to_project)
  
  call this%allocate_and_fill_offset_component(offset_component)
  
  call memalloc ( this%get_max_num_shape_functions(), &
                  this%get_max_num_shape_functions(), &
                  elmat, __FILE__, __LINE__ )

  call memalloc ( this%get_max_num_shape_functions(), &
                  elvec, __FILE__, __LINE__ )

  call memalloc ( this%get_max_num_shape_functions(), subset_fe_dofs, __FILE__, __LINE__ )

  allocate ( vector_function_values(this%get_max_num_facet_quadrature_points(),1), & 
             stat=istat); check(istat==0);

  allocate ( scalar_function_values(this%get_max_num_facet_quadrature_points(),1), & 
             stat=istat); check(istat==0);

  allocate ( function_scalar_components(this%triangulation%get_num_dims()), & 
             stat=istat); check(istat==0);
  
  allocate( fe_dofs(this%get_num_fields()), stat=istat); check(istat==0);

  num_subset_strong_dirichlet_dofs = this%allocate_and_fill_global2subset_and_inverse(fields_to_project_, &
                                                                                         global2subset_dirichlet_dofs, &
                                                                                         subset2global_dirichlet_dofs)
  
  ! Create linear system 
  call matrix%create(num_rows_and_cols=num_subset_strong_dirichlet_dofs, &
                     symmetric_storage=.true.,       &
                     is_symmetric=.true.,            &
                     sign=SPARSE_MATRIX_SIGN_POSITIVE_DEFINITE )

  call rhs%create_and_allocate(num_subset_strong_dirichlet_dofs) 
  call rhs%init(0.0_rp)

  ! Create data structures
  call projected_nodal_values%create_and_allocate(num_subset_strong_dirichlet_dofs)
  call this%create_fe_facet_iterator(fe_face)
  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe_face%has_finished() )
     if ( fe_face%is_at_boundary() ) then
        if ( fe_face%get_set_id() /= 0 ) then
           call fe_face%update_integration() 
           call fe_face%get_cell_around(1,fe)
           call fe%get_fe_dofs(fe_dofs)
           call this%conditions%get_components_code( fe_face%get_set_id(), components_code )

           do ifield = 1, size(fields_to_project_)    
              field_id = fields_to_project_(ifield) 
              component_id = offset_component(field_id) + 1
              if (components_code(component_id)) then
                 
                 call this%get_function_scalar_components(fe_face, &
                                                          fe, &
                                                          field_id, &
                                                          component_id, &
                                                          function_scalar_components)
                 
                 call this%evaluate_vector_function_scalar_components(fe_face, &
                                                                      fe, &
                                                                      field_id, &
                                                                      function_scalar_components, &
                                                                      scalar_function_values, &
                                                                      vector_function_values, &
                                                                      time)
                 
                 call this%project_curl_conforming_compute_elmat_elvec(fe_face, &
                                                                       fe, &
                                                                       field_id, &
                                                                       vector_function_values, &
                                                                       elmat, &
                                                                       elvec, &
                                                                       shape_values)
              
              
                 ! Consecutive DOF re-numbering for the subset of Dirichlet DOFs to be projected 
                 subset_fe_dofs = 0
                 do idof = 1, size(fe_dofs(field_id)%p)
                    if ( fe%is_strong_dirichlet_dof(fe_dofs(field_id)%p(idof)) ) then 
                        subset_fe_dofs(idof) = global2subset_dirichlet_dofs( -fe_dofs(field_id)%p(idof) )
                    end if
                 end do
                 
                 reference_fe => fe%get_reference_fe(field_id)
                 call matrix%insert(num_rows = reference_fe%get_num_shape_functions(),& 
                                    num_cols = reference_fe%get_num_shape_functions(),& 
                                    ia       = subset_fe_dofs, &
                                    ja       = subset_fe_dofs, &
                                    ioffset  = 0, &
                                    joffset  = 0, & 
                                    val      = elmat)
                 call rhs%add(num_entries = reference_fe%get_num_shape_functions(),& 
                              ia          = subset_fe_dofs, &
                              ioffset     = 0, &
                              val         = elvec)
              end if
           end do
        end if
     end if
     call fe_face%next()
  end do
  call this%free_fe_facet_iterator(fe_face)
  call this%free_fe_cell_iterator(fe)
  call matrix%convert(csr_format)
      
  call parameter_list%init()
#ifdef ENABLE_MKL
  FPLError = parameter_list%set(key = direct_solver_type                  ,  value = pardiso_mkl)
  FPLError = FPLError + parameter_list%set(key = pardiso_mkl_matrix_type  ,  value = pardiso_mkl_spd)
  FPLError = FPLError + parameter_list%set(key = pardiso_mkl_message_level,  value = 0)
  iparm = 0
  FPLError = FPLError + parameter_list%set(key = pardiso_mkl_iparm,         value = iparm)
  assert(FPLError == 0)

  call direct_solver%set_type_from_pl(parameter_list)
  call direct_solver%set_parameters_from_pl(parameter_list)
  call direct_solver%set_matrix(matrix)
  call direct_solver%numerical_setup()
  call direct_solver%solve(rhs,projected_nodal_values)
  call direct_solver%free()
#else
  FPLError = parameter_list%set(key = ils_rtol, value = 1.0e-12_rp)
  FPLError = FPLError + parameter_list%set(key = ils_output_frequency, value = 30)
  assert(FPLError == 0)
  call iterative_linear_solver%create(this%get_environment())
  call iterative_linear_solver%set_type_from_string(cg_name)
  call iterative_linear_solver%set_parameters_from_pl(parameter_list)
  call iterative_linear_solver%set_operators(matrix, .identity. matrix) 
  call iterative_linear_solver%solve(rhs,projected_nodal_values)
  call iterative_linear_solver%free()
#endif
  call parameter_list%free()

  ! Insert projected nodal values into strong_dirichlet_values array 
  strong_dirichlet_values => fe_function%get_fixed_dof_values()
  call strong_dirichlet_values%insert_subvector(iblock=1, &
                                                size_indices=num_subset_strong_dirichlet_dofs, &
                                                indices=subset2global_dirichlet_dofs,             &
                                                values=projected_nodal_values%get_entries())

  call matrix%free()
  call rhs%free()
  call projected_nodal_values%free()
  call memfree (elmat, __FILE__, __LINE__)
  call memfree (elvec, __FILE__, __LINE__)
  call memfree (offset_component, __FILE__, __LINE__ )
  deallocate ( function_scalar_components, stat=istat); check(istat==0);
  deallocate ( vector_function_values, stat=istat); check(istat==0);
  deallocate ( scalar_function_values, stat=istat); check(istat==0);
  deallocate ( shape_values, stat=istat); check(istat==0);
  call memfree ( components_code, __FILE__, __LINE__ )
  call memfree ( subset2global_dirichlet_dofs, __FILE__, __LINE__ )
  call memfree ( global2subset_dirichlet_dofs, __FILE__, __LINE__ ) 
  call memfree ( fields_to_project_, __FILE__, __LINE__ )
  call memfree ( subset_fe_dofs, __FILE__, __LINE__ )
  deallocate(fe_dofs, stat=istat ); check (istat==0)
end subroutine serial_fe_space_project_dirichlet_values_curl_conforming


subroutine serial_fe_space_allocate_and_fill_fields_to_project_ (this, &
                                                                 fields_to_project_, &
                                                                 fields_to_project)
  implicit none
  class(serial_fe_space_t)    , intent(in)    :: this
  integer(ip), allocatable    , intent(inout) :: fields_to_project_(:)
  integer(ip), optional       , intent(in)    :: fields_to_project(:)
  
  integer(ip) :: ifield, jfield, field_id
  
  if (allocated(fields_to_project_)) call memfree(fields_to_project_,__FILE__,__LINE__)

  if ( present(fields_to_project) ) then 
     ! User specifies which fields will be projected 
     call memalloc ( size(fields_to_project), fields_to_project_, __FILE__, __LINE__ ) 
     fields_to_project_ = fields_to_project
  else  
     ! By default, all fields are projected ( i.e., 1-field case where no subset selection is needed) 
     call memalloc ( this%get_num_fields() , fields_to_project_, __FILE__, __LINE__ )  
     do field_id=1,this%get_num_fields() 
        fields_to_project_(field_id) = field_id
     end do
  end if
  
  ! fields_to_project_ consistency check (only in DEBUG mode)
#ifdef DEBUG
  do ifield = 1, size(fields_to_project_) 
    field_id = fields_to_project_(ifield)
    assert ( field_id >= 1 .and. field_id <= this%get_num_fields() )
    do jfield = ifield+1, size(fields_to_project_)
      assert ( fields_to_project_(ifield) /= fields_to_project_(jfield) )
    end do
  end do
#endif  
  
end subroutine serial_fe_space_allocate_and_fill_fields_to_project_

subroutine serial_fe_space_allocate_and_fill_offset_component(this, offset_component)
  implicit none
  class(serial_fe_space_t)    , intent(in)    :: this
  integer(ip), allocatable    , intent(inout) :: offset_component(:)
  integer(ip) :: field_id
  class(reference_fe_t), pointer :: reference_fe
  if (allocated(offset_component)) call memfree(offset_component, __FILE__, __LINE__ )
  ! Build offset components 
  call memalloc( this%get_num_fields(), offset_component, __FILE__, __LINE__ ) 
  offset_component(1) = 0
  do field_id = 2, this%get_num_fields() 
     reference_fe                   => this%get_reference_fe(field_id-1)
     offset_component(field_id)     =  offset_component(field_id-1) + reference_fe%get_num_field_components() 
  end do
end subroutine serial_fe_space_allocate_and_fill_offset_component

! Returns the sum of those DoFs subject to strong Dirichlet boundary conditions
! associated to the fields enumerated in the fields_to_project(:) dummy argument
function serial_fe_space_allocate_and_fill_global2subset_and_inverse(this,              &
                                                                     fields_to_project, &
                                                                     global2subset,     &
                                                                     subset2global) result(num_subset_strong_dirichlet_dofs)
  implicit none
  class(serial_fe_space_t)    , intent(in)    :: this
  integer(ip)                 , intent(in)    :: fields_to_project(:)
  integer(ip), allocatable    , intent(inout) :: global2subset(:)                 
  integer(ip), allocatable    , intent(inout) :: subset2global(:)
  integer(ip)                                 :: num_subset_strong_dirichlet_dofs

  integer(ip)              :: ifield, field_id, idof, idof_subset, idof_global
  integer(ip)              :: istat
  class(fe_cell_iterator_t), allocatable :: fe
  type(i1p_t), allocatable :: fe_dofs(:)


  if (allocated(global2subset)) call memfree(global2subset,__FILE__,__LINE__)
  if (allocated(subset2global)) call memfree(subset2global,__FILE__,__LINE__)
  
  allocate( fe_dofs(this%get_num_fields()), stat=istat); check(istat==0);
  call memalloc ( this%num_dirichlet_dofs, global2subset, __FILE__, __LINE__ ) 
  global2subset=0

  ! Count number of Dirichlet DOFs to be projected
  num_subset_strong_dirichlet_dofs = 0
  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe%has_finished())
     if ( fe%is_local() ) then
        do ifield = 1, size(fields_to_project) 
           field_id = fields_to_project(ifield) 
           if ( fe%at_strong_dirichlet_boundary(field_id) ) then 
              call fe%get_fe_dofs(fe_dofs)
              do idof = 1,size(fe_dofs(field_id)%p)
                 if ( fe%is_strong_dirichlet_dof(fe_dofs(field_id)%p(idof)) ) then 
                    if (global2subset(-fe_dofs(field_id)%p(idof))==0) then 
                       num_subset_strong_dirichlet_dofs = num_subset_strong_dirichlet_dofs + 1
                       global2subset(-fe_dofs(field_id)%p(idof)) = num_subset_strong_dirichlet_dofs 
                    end if
                 end if
              end do
           end if
        end do
     end if
     call fe%next()
  end do
  call this%free_fe_cell_iterator(fe)
  ! Allocate + compute subset2global_dirichlet_dofs from subset2global_dirichlet_dofs
  call memalloc ( num_subset_strong_dirichlet_dofs, subset2global, __FILE__, __LINE__ ) 

  idof_subset=1
  do idof_global=1, this%num_dirichlet_dofs
     if (global2subset(idof_global) /= 0) then
        subset2global(global2subset(idof_global)) = idof_global
     end if
  end do  
  deallocate(fe_dofs, stat=istat ); check (istat==0)
end function serial_fe_space_allocate_and_fill_global2subset_and_inverse

subroutine serial_fe_space_get_function_scalar_components ( this, &
                                                            fe_face, &
                                                            fe, &
                                                            field_id, &
                                                            component_id, &
                                                            function_scalar_components )
  implicit none
  class(serial_fe_space_t)    , intent(in)    :: this
  class(fe_facet_iterator_t)   , intent(in)    :: fe_face
  class(fe_cell_iterator_t)        , intent(inout) :: fe
  integer(ip)                 , intent(in)    :: field_id
  integer(ip)                 , intent(in)    :: component_id
  type(p_scalar_function_t)   , intent(inout) :: function_scalar_components(:)
  
  ! Locals
  integer(ip)                    :: icomp
  class(reference_fe_t), pointer :: reference_fe
  
  call fe_face%get_cell_around(1,fe)
  reference_fe => fe%get_reference_fe(field_id)
  
  assert ( reference_fe%get_num_field_components() <= size(function_scalar_components) )
  assert ( field_id >= 1 .and. field_id <= this%get_num_fields() )
  assert ( component_id >= 1 .and. component_id <= this%conditions%get_num_components() )
  
  ! Retreive the scalar functions corresponding to the components of the function to be projected
  do icomp=1, reference_fe%get_num_field_components()
       call this%conditions%get_function(fe_face%get_set_id(), &
                                         component_id+icomp-1, &
                                         function_scalar_components(icomp)%p)
  end do
end subroutine serial_fe_space_get_function_scalar_components

subroutine serial_fe_space_evaluate_vector_function_scalar_components(this, &
                                                                      fe_face, &
                                                                      fe, &
                                                                      field_id, &
                                                                      function_scalar_components, &
                                                                      scalar_function_values, &
                                                                      vector_function_values, &
                                                                      time)
  implicit none
  class(serial_fe_space_t) , intent(in)    :: this
  class(fe_facet_iterator_t), intent(inout) :: fe_face
  class(fe_cell_iterator_t)     , intent(inout) :: fe
  integer(ip)              , intent(in)    :: field_id
  type(p_scalar_function_t), intent(in)    :: function_scalar_components(:)
  real(rp)                 , intent(inout) :: scalar_function_values(:,:) ! Work-space
  type(vector_field_t)     , intent(inout) :: vector_function_values(:,:)
  real(rp), optional       , intent(in)    :: time

  ! Locals
  integer(ip)                    :: icomp
  class(reference_fe_t), pointer :: reference_fe
  type(quadrature_t)   , pointer :: quadrature
  type(point_t)        , pointer :: quad_coords(:)
                   
  real(rp)                       :: time_(1)
  integer(ip)                    :: qpoint, n_q_points
  
  call fe_face%get_cell_around(1,fe)
  reference_fe => fe%get_reference_fe(field_id)
  quad_coords  => fe_face%get_quadrature_points_coordinates()
  
  assert ( reference_fe%get_num_field_components() <= size(function_scalar_components) )
  assert ( field_id >= 1 .and. field_id <= this%get_num_fields() )
  
  if ( present(time) ) time_(1) = time
  
  quadrature   => fe_face%get_quadrature()
  n_q_points   = quadrature%get_num_quadrature_points()
  
  select case(reference_fe%get_field_type())
  case ( field_type_scalar )
     ! reference_fe MUST BE a vector-valued FE
     assert (.false.)
  case ( field_type_vector )
     do icomp=1, reference_fe%get_num_field_components()
        if(present(time)) then
           call function_scalar_components(icomp)%p%get_values_set_space_time(quad_coords,time_,scalar_function_values(1:n_q_points,:))
        else
           call function_scalar_components(icomp)%p%get_values_set_space(quad_coords,scalar_function_values(1:n_q_points,1))
        end if
        do qpoint = 1, n_q_points
           call vector_function_values(qpoint,1)%set(icomp,scalar_function_values(qpoint,1))
        end do
     end do
  case ( field_type_tensor )
     ! reference_fe MUST BE a vector-valued FE
     assert(.false.)
  end select
end subroutine serial_fe_space_evaluate_vector_function_scalar_components

subroutine serial_fe_space_project_curl_conforming_compute_elmat_elvec ( this, &
                                                                         fe_face, & 
                                                                         fe, &
                                                                         field_id, &
                                                                         vector_function_values, &
                                                                         elmat, &
                                                                         elvec, &
                                                                         shape_values)
  implicit none
  class(serial_fe_space_t) , intent(in)    :: this
  class(fe_facet_iterator_t), intent(inout) :: fe_face
  class(fe_cell_iterator_t)     , intent(inout) :: fe
  integer(ip)              , intent(in)    :: field_id
  type(vector_field_t)     , intent(in)    :: vector_function_values(:,:)
  real(rp)                 , intent(inout) :: elmat(:,:)
  real(rp)                 , intent(inout) :: elvec(:)
  type(vector_field_t), allocatable, intent(inout) :: shape_values(:,:)

  ! Locals
  class(reference_fe_t)  , pointer :: reference_fe
  type(quadrature_t)     , pointer :: quadrature
  integer(ip)                      :: qpoint, n_q_points
  integer(ip)                      :: ishape, jshape
  real(rp)                         :: factor
  type(vector_field_t) :: normals(2)
  type(vector_field_t) :: vector_shape_test, vector_shape_trial
  
  call fe_face%get_cell_around(1,fe)
  reference_fe      => fe%get_reference_fe(field_id)
  quadrature        => fe_face%get_quadrature()  
  n_q_points        = quadrature%get_num_quadrature_points()
  select case(reference_fe%get_field_type())
  case ( field_type_scalar )
     ! Curl-conforming projection does not make sense with scalar-valued fields
     assert(.false.)
  case ( field_type_vector )
     elmat = 0.0_rp
     elvec = 0.0_rp
     call fe_face%get_values(1,shape_values)
     do qpoint = 1, n_q_points
     call fe_face%get_normals(qpoint, normals)
        factor = fe_face%get_det_jacobian(qpoint) * quadrature%get_weight(qpoint)
        
        do ishape = 1, reference_fe%get_num_shape_functions() 
           do jshape = 1, reference_fe%get_num_shape_functions()
              elmat(ishape,jshape) = elmat(ishape,jshape) + cross_product(shape_values(ishape,qpoint),normals(1))*cross_product(shape_values(jshape,qpoint),normals(1))*factor
           end do
           elvec(ishape) = elvec(ishape) + cross_product(vector_function_values(qpoint,1),normals(1))*cross_product(shape_values(ishape,qpoint),normals(1))*factor
        end do
     end do
  case ( field_type_tensor )
     ! Curl-conforming projection does not make sense with tensor-valued fields
     assert(.false.)
  end select
end subroutine serial_fe_space_project_curl_conforming_compute_elmat_elvec

subroutine serial_fe_space_allocate_and_fill_reference_fes ( this, reference_fes )
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this
  type(p_reference_fe_t)                ,  intent(in)   :: reference_fes(:)
  integer(ip) :: i, istat

  this%reference_fes_size = size(reference_fes)
  allocate( this%reference_fes(this%reference_fes_size), stat=istat )
  check ( istat == 0 )

  do i  = 1, this%reference_fes_size
     this%reference_fes(i) = reference_fes(i)
  end do
end subroutine serial_fe_space_allocate_and_fill_reference_fes

subroutine serial_fe_space_free_reference_fes ( this )
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this
  integer(ip) :: istat
  this%reference_fes_size = 0
  if (allocated(this%reference_fes)) then
     deallocate( this%reference_fes, stat=istat )
     check ( istat == 0 )
  end if
end subroutine serial_fe_space_free_reference_fes

!========================================================================================
subroutine sfs_allocate_and_fill_set_ids_to_reference_fes(this, set_ids_to_reference_fes)
  implicit none
  class(serial_fe_space_t)           , intent(inout) :: this
  integer(ip)                        , intent(in)    :: set_ids_to_reference_fes(:,:)
  call this%free_set_ids_to_reference_fes()
  call memalloc ( size(set_ids_to_reference_fes,1), &
                  size(set_ids_to_reference_fes,2), &
                  this%set_ids_to_reference_fes, __FILE__, __LINE__ )
  this%set_ids_to_reference_fes = set_ids_to_reference_fes
end subroutine sfs_allocate_and_fill_set_ids_to_reference_fes

!========================================================================================
subroutine sfs_free_set_ids_to_reference_fes(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  if ( allocated(this%set_ids_to_reference_fes) ) then
    call memfree ( this%set_ids_to_reference_fes, __FILE__, __LINE__ )
  end if
end subroutine sfs_free_set_ids_to_reference_fes

subroutine serial_fe_space_allocate_field_cell_to_ref_fes ( this )
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this
  integer(ip) :: error, field_id
  if ( .not. allocated(this%field_cell_to_ref_fes) ) then
    allocate( this%field_cell_to_ref_fes(this%num_fields) , stat = error ); check( error == 0 )
    do field_id = 1,this%num_fields
      call this%field_cell_to_ref_fes(field_id)%resize(this%triangulation%get_num_cells())
    end do
  end if
end subroutine serial_fe_space_allocate_field_cell_to_ref_fes

subroutine serial_fe_space_free_field_cell_to_ref_fes ( this )
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this
  integer(ip) :: error, field_id
  if ( allocated(this%field_cell_to_ref_fes) ) then
    do field_id = 1,this%num_fields
      call this%field_cell_to_ref_fes(field_id)%free()
    end do
    deallocate( this%field_cell_to_ref_fes, stat = error ); check( error == 0 )
  end if
end subroutine serial_fe_space_free_field_cell_to_ref_fes

subroutine serial_fe_space_fill_field_cell_to_ref_fes_same_on_all_cells ( this )
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this
  integer(ip), pointer :: current_field_cell_to_ref_fes(:)
  integer(ip)          :: ifield
  integer(ip)          :: ife
  
  do ifield=1, this%num_fields
     current_field_cell_to_ref_fes => this%field_cell_to_ref_fes(ifield)%get_pointer()
     do ife=1, this%triangulation%get_num_cells()
        current_field_cell_to_ref_fes(ife) = ifield
     end do
  end do

end subroutine serial_fe_space_fill_field_cell_to_ref_fes_same_on_all_cells

subroutine sfes_fill_field_cell_to_ref_fes_different_ref_fes_between_cells ( this, set_ids_to_reference_fes )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip)             , intent(in)    :: set_ids_to_reference_fes(:,:)
  integer(ip)            , pointer     :: current_field_cell_to_ref_fes(:)
  integer(ip)                          :: ifield
  class(cell_iterator_t) , allocatable :: cell
  
  call this%triangulation%create_cell_iterator(cell)
  do ifield=1, this%num_fields
    call cell%first()
    current_field_cell_to_ref_fes => this%field_cell_to_ref_fes(ifield)%get_pointer()
    do while (.not. cell%has_finished())
      current_field_cell_to_ref_fes(cell%get_gid()) = set_ids_to_reference_fes(ifield,cell%get_set_id())
      call cell%next()
    end do
  end do
  call this%triangulation%free_cell_iterator(cell)

end subroutine sfes_fill_field_cell_to_ref_fes_different_ref_fes_between_cells

subroutine serial_fe_space_check_cell_vs_fe_topology_consistency(this)
  implicit none
  class(serial_fe_space_t)          , intent(in) :: this
  class(fe_cell_iterator_t), allocatable :: fe
  class(reference_fe_t), pointer :: reference_fe_unkno
  class(reference_fe_t), pointer :: reference_fe_geo
  integer(ip) :: field_id

#ifdef DEBUG
  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe%has_finished())
     reference_fe_geo => fe%get_reference_fe_geo()
     do field_id = 1, fe%get_num_fields()  
        reference_fe_unkno => fe%get_reference_fe(field_id)
        assert ( reference_fe_unkno%get_topology() == reference_fe_geo%get_topology() )
     end do
     call fe%next()
  end do
  call fe%free()
#endif

end subroutine serial_fe_space_check_cell_vs_fe_topology_consistency

subroutine serial_fe_space_allocate_and_init_cell_quadratures_degree ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%cell_quadratures_degree%resize(0)
  call this%cell_quadratures_degree%resize(this%triangulation%get_num_cells(),fe_space_default_quadrature_degree_flag)
end subroutine serial_fe_space_allocate_and_init_cell_quadratures_degree 

subroutine serial_fe_space_free_cell_quadratures_degree ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%cell_quadratures_degree%free()
end subroutine serial_fe_space_free_cell_quadratures_degree

subroutine serial_fe_space_free_max_order_reference_fe_id_x_cell ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%max_order_reference_fe_id_x_cell%free()
end subroutine serial_fe_space_free_max_order_reference_fe_id_x_cell 

subroutine serial_fe_space_compute_max_order_reference_fe_id_x_cell ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  class(fe_cell_iterator_t), allocatable :: fe
  integer(ip), pointer :: max_order_reference_fe_id_x_cell(:)
  integer(ip)          :: max_order, max_order_reference_fe_id_within_fe
  integer(ip)          :: field_id
  
  call this%max_order_reference_fe_id_x_cell%resize(this%triangulation%get_num_cells())
  max_order_reference_fe_id_x_cell => this%max_order_reference_fe_id_x_cell%get_pointer()
  
  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe%has_finished())
     max_order = -1
     do field_id=1, this%get_num_fields()
        if ( max_order <= fe%get_max_order_single_field(field_id) ) then
           max_order = fe%get_max_order_single_field(field_id)
           max_order_reference_fe_id_within_fe = fe%get_reference_fe_id(field_id)
        end if
     end do
     max_order_reference_fe_id_x_cell(fe%get_gid()) = max_order_reference_fe_id_within_fe
     call fe%next()
  end do
  call this%free_fe_cell_iterator(fe) 
end subroutine serial_fe_space_compute_max_order_reference_fe_id_x_cell 

subroutine serial_fe_space_set_up_cell_integration ( this, interpolation_duties, cell_map_duties )
  implicit none
  class(serial_fe_space_t)      , target  , intent(inout) :: this
  type(interpolation_duties_t), optional, intent(in)    :: interpolation_duties(:)
  type(cell_map_duties_t)     , optional, intent(in)    :: cell_map_duties
  type(fe_cell_iterator_t) :: fe

  integer(ip)         :: cell_quadrature_and_map_position
  integer(ip)         :: cell_integrator_position
  
  integer(ip)         :: field_id
  integer(ip)         :: max_order, max_order_reference_fe_id_within_fe
  integer(ip)         :: cell_quadrature_and_map_key
  integer(ip)         :: cell_integrators_position_key
  integer(ip)         :: istat
  
  class(reference_fe_t), pointer :: reference_fe
  integer(ip)          , pointer :: max_order_reference_fe_id_x_cell(:)

  type(quadrature_t)     , pointer :: current_quadrature
  type(cell_map_t)       , pointer :: current_cell_map
  type(cell_integrator_t), pointer :: current_cell_integrator
  type(cell_map_duties_t)          :: current_cell_map_duties
  type(interpolation_duties_t)     :: current_interpolation_duties
  logical :: compute_first_derivatives, compute_second_derivatives

  ! We need to set to .false. this member variable as the traversal over all
  ! cells below would fail if the value of this variable is .true. This can
  ! happen, e.g. if we call this%set_up_cell_integration(...) twice in a FE
  ! program
  this%cell_integration_is_set_up = .false.

  if(.not.present(cell_map_duties)) then
     ! Select higher derivatives of all inerpolations to define the mapping
     if(present(interpolation_duties)) then
        assert(size(interpolation_duties)== this%get_num_fields())
        do field_id=1, this%get_num_fields()
           call current_interpolation_duties%assign_compute_first_derivatives( &
                & current_interpolation_duties%compute_first_derivatives_is_assigned() .or.  &
                & interpolation_duties(field_id)%compute_first_derivatives_is_assigned())
           call current_interpolation_duties%assign_compute_second_derivatives( &
                & current_interpolation_duties%compute_second_derivatives_is_assigned() .or.  &
                & interpolation_duties(field_id)%compute_second_derivatives_is_assigned())
        end do
     else ! Assign default duties (those we had before duties control)
        call current_interpolation_duties%assign_compute_first_derivatives(.true.)
        call current_interpolation_duties%assign_compute_second_derivatives(.false.)
     end if
  end if
  call this%compute_max_order_reference_fe_id_x_cell()
  max_order_reference_fe_id_x_cell => this%max_order_reference_fe_id_x_cell%get_pointer()
  
  call this%cell_quadratures_and_maps_position%init()
  call this%cell_integrators_position%init()
  call this%cell_quadratures%resize(0)
  call this%cell_maps%resize(0)
  call this%cell_integrators%resize(0)
  cell_quadrature_and_map_position = 1
  cell_integrator_position = 1

  call fe%create(this)
  do while ( .not. fe%has_finished())
   
     cell_quadrature_and_map_key = this%generate_cell_quadratures_position_key(fe%get_reference_fe_geo_id(), &
                                                                               fe%get_quadrature_degree())
     
     call this%cell_quadratures_and_maps_position%put(key = cell_quadrature_and_map_key,      &
                                                      val = cell_quadrature_and_map_position, &
                                                      stat= istat)
     if (istat == now_stored) then
        ! Create quadrature and cell_map associated to current max_order_within_fe
        max_order_reference_fe_id_within_fe = max_order_reference_fe_id_x_cell(fe%get_gid()) 
        reference_fe => this%reference_fes(max_order_reference_fe_id_within_fe)%p
        call this%cell_quadratures%resize(cell_quadrature_and_map_position)
        current_quadrature => this%cell_quadratures%get_pointer(cell_quadrature_and_map_position)
        call reference_fe%create_quadrature(current_quadrature,fe%get_quadrature_degree())
        call this%cell_maps%resize(cell_quadrature_and_map_position)
        current_cell_map => this%cell_maps%get_pointer(cell_quadrature_and_map_position)
        if(present(cell_map_duties)) then
           current_cell_map_duties = cell_map_duties
        else
           ! Checck if any field needs jacobian inverse and/or derivative
           call current_cell_map_duties%assign_compute_jacobian_inverse(.false.)
           call current_cell_map_duties%assign_compute_jacobian_derivative(.false.)
           do field_id=1, this%get_num_fields()
              reference_fe => fe%get_reference_fe(field_id)
              call reference_fe%assign_cell_map_duties(current_interpolation_duties,current_cell_map_duties)
           end do
        end if
        call current_cell_map%create(current_quadrature,fe%get_reference_fe_geo(),cell_map_duties)
        cell_quadrature_and_map_position = cell_quadrature_and_map_position + 1
     end if

     do field_id=1, this%get_num_fields()
        cell_integrators_position_key = &
             this%generate_cell_integrators_position_key(fe%get_reference_fe_geo_id(), &
                                                         fe%get_quadrature_degree(),   &
                                                         this%field_cell_to_ref_fes(field_id)%get(fe%get_gid()))
        
        call this%cell_integrators_position%put(key=cell_integrators_position_key, &
                                                val=cell_integrator_position,      &
                                                stat=istat)
        if (istat == now_stored) then 
           current_quadrature => fe%get_quadrature()
           call this%cell_integrators%resize(cell_integrator_position)
           current_cell_integrator => this%cell_integrators%get_pointer(cell_integrator_position)
           if(present(interpolation_duties)) current_interpolation_duties = interpolation_duties(field_id)
           call current_cell_integrator%create(current_quadrature,fe%get_reference_fe(field_id),current_interpolation_duties)
           cell_integrator_position = cell_integrator_position + 1
        end if
     end do
     call fe%next()
  end do
  call fe%free()
  this%cell_integration_is_set_up = .true.
end subroutine serial_fe_space_set_up_cell_integration

function serial_fe_space_cell_integration_was_set_up(this)
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  logical :: serial_fe_space_cell_integration_was_set_up
  serial_fe_space_cell_integration_was_set_up = this%cell_integration_is_set_up
end function serial_fe_space_cell_integration_was_set_up

subroutine serial_fe_space_set_cell_integration_was_set_up (this, was_set_up)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  logical                 , intent(in)    :: was_set_up
  this%cell_integration_is_set_up = was_set_up
end subroutine serial_fe_space_set_cell_integration_was_set_up

subroutine serial_fe_space_free_fe_integration ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%cell_quadratures_and_maps_position%free()
  call this%cell_integrators_position%free()
  call this%cell_quadratures%free()
  call this%cell_maps%free()
  call this%cell_integrators%free()
  call this%free_cell_quadratures_degree()
  call this%free_max_order_reference_fe_id_x_cell()
  this%cell_integration_is_set_up = .false.
end subroutine serial_fe_space_free_fe_integration


! Some comments:
!   * geo_reference_fe_id can range from 1 to this%triangulation%get_num_reference_fes_geo()
!   * quadrature_degree can range from -1 to fe_space_max_quadrature_degree
function serial_fe_space_generate_cell_quadratures_position_key ( this, geo_reference_fe_id, quadrature_degree)
  implicit none
  class(serial_fe_space_t)    , intent(in) :: this
  integer(ip)                 , intent(in) :: geo_reference_fe_id
  integer(ip)                 , intent(in) :: quadrature_degree
  integer(ip) :: serial_fe_space_generate_cell_quadratures_position_key
  massert ( quadrature_degree >= -1,  "serial_fe_space_generate_cell_quadratures_position_key::Invalid quadrature degree")
  massert ( geo_reference_fe_id >= 1 .and. geo_reference_fe_id <= this%triangulation%get_num_reference_fes(), "serial_fe_space_generate_cell_quadratures_position_key::Invalid geo_reference_fe_id" )
  serial_fe_space_generate_cell_quadratures_position_key = quadrature_degree * this%triangulation%get_num_reference_fes() + geo_reference_fe_id + this%triangulation%get_num_reference_fes()
end function serial_fe_space_generate_cell_quadratures_position_key

! Some comments:
!   * geo_reference_fe_id can range from 1 to this%triangulation%get_num_reference_fes_geo()
!   * quadrature_degree can range from -1 to fe_space_max_quadrature_degree
!   * reference_fe_id can range from 1 to this%reference_fes_size
function serial_fe_space_generate_cell_integrators_position_key ( this, geo_reference_fe_id, quadrature_degree, reference_fe_id )
  implicit none
  class(serial_fe_space_t)    , intent(in) :: this
  integer(ip)                 , intent(in) :: geo_reference_fe_id
  integer(ip)                 , intent(in) :: quadrature_degree
  integer(ip)                 , intent(in) :: reference_fe_id
  integer(ip) :: serial_fe_space_generate_cell_integrators_position_key
  massert ( reference_fe_id >= 1 .and. reference_fe_id <= this%get_num_reference_fes(), "serial_fe_space_generate_cell_integrators_position_key::Invalid reference_fe_id" )
  serial_fe_space_generate_cell_integrators_position_key =  reference_fe_id + &
       this%generate_cell_quadratures_position_key(geo_reference_fe_id,quadrature_degree) * this%get_num_reference_fes()
end function serial_fe_space_generate_cell_integrators_position_key

subroutine serial_fe_space_allocate_and_init_facet_quadratures_degree ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%facet_quadratures_degree%resize(0)
  call this%facet_quadratures_degree%resize(this%facet_gids%size(),fe_space_default_quadrature_degree_flag)
end subroutine serial_fe_space_allocate_and_init_facet_quadratures_degree 

subroutine serial_fe_space_free_facet_quadratures_degree ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%facet_quadratures_degree%free()
end subroutine serial_fe_space_free_facet_quadratures_degree

subroutine serial_fe_space_free_max_order_field_cell_to_ref_fes_face  ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%max_order_field_cell_to_ref_fes_face%free()
end subroutine serial_fe_space_free_max_order_field_cell_to_ref_fes_face  

subroutine serial_fe_space_compute_max_order_field_cell_to_ref_fes_face ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  class(fe_facet_iterator_t), allocatable :: fe_face
  class(fe_cell_iterator_t)     , allocatable :: fe
  integer(ip), pointer :: max_order_field_cell_to_ref_fes_face(:)
  integer(ip)          :: max_order, max_order_reference_fe_id, reference_fe_id
  integer(ip)          :: max_order_fes_around_fe_face
  integer(ip)          :: field_id, icell_around
  
  call this%max_order_field_cell_to_ref_fes_face%resize(this%facet_gids%size())
  max_order_field_cell_to_ref_fes_face => this%max_order_field_cell_to_ref_fes_face%get_pointer()
  
  call this%create_fe_facet_iterator(fe_face)
  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe_face%has_finished())
     max_order_fes_around_fe_face = -1
     max_order_reference_fe_id    =  1 
     do icell_around = 1, fe_face%get_num_cells_around()
        call fe_face%get_cell_around(icell_around, fe)
        do field_id=1, fe%get_num_fields()
           if ( max_order_fes_around_fe_face <= fe%get_max_order_single_field(field_id) ) then
              max_order_fes_around_fe_face = fe%get_max_order_single_field(field_id)
              max_order_reference_fe_id = fe%get_reference_fe_id(field_id)
           end if
        end do
     end do
     max_order_field_cell_to_ref_fes_face(fe_face%facet_gid) = max_order_reference_fe_id 
     call fe_face%next()
  end do
  call this%free_fe_facet_iterator(fe_face)
  call this%free_fe_cell_iterator(fe)
end subroutine serial_fe_space_compute_max_order_field_cell_to_ref_fes_face  

subroutine serial_fe_space_fill_facet_gids ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  type(fe_vef_iterator_t) :: fe_vef
  call this%facet_gids%resize(0)
  call this%create_fe_vef_iterator(fe_vef)
  do while ( .not. fe_vef%has_finished() )
    if ( fe_vef%is_facet() .and. .not. fe_vef%is_ghost() .and.   &
         ( ( .not. fe_vef%is_proper() ) .or.                         &
         ( fe_vef%is_proper() .and. ( fe_vef%is_at_boundary() .or. &
           fe_vef%get_num_cells_around() > 1 ) ) ) ) then
      call this%facet_gids%push_back(fe_vef%get_gid())
    end if
    call fe_vef%next()
  end do
  call this%free_fe_vef_iterator(fe_vef)
end subroutine serial_fe_space_fill_facet_gids

subroutine serial_fe_space_free_facet_gids ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%facet_gids%free()
end subroutine serial_fe_space_free_facet_gids

subroutine serial_fe_space_compute_facet_permutation_indices ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  class(fe_facet_iterator_t)       , allocatable :: fe_face
  class(fe_cell_iterator_t)            , allocatable :: first_fe
  class(fe_cell_iterator_t)            , allocatable :: second_fe
  integer(ip) :: fe_facet_permutation_index
  
  call this%facet_permutation_indices%resize(this%facet_gids%size(),-1)
  call this%create_fe_cell_iterator(first_fe)
  call this%create_fe_cell_iterator(second_fe)
  call this%create_fe_facet_iterator(fe_face)
  do while ( .not. fe_face%has_finished() )
    if ( .not. fe_face%is_ghost() .and. fe_face%get_num_cells_around() == 2 ) then
      fe_facet_permutation_index = fe_face%compute_fe_facet_permutation_index(first_fe,second_fe)
      call this%facet_permutation_indices%set(fe_face%facet_gid,fe_facet_permutation_index)
    end if
    call fe_face%next()
  end do
  call this%free_fe_facet_iterator(fe_face)
  call this%free_fe_cell_iterator(second_fe)
  call this%free_fe_cell_iterator(first_fe)

end subroutine serial_fe_space_compute_facet_permutation_indices

subroutine serial_fe_space_free_facet_permutation_indices ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%facet_permutation_indices%free()
end subroutine serial_fe_space_free_facet_permutation_indices

subroutine serial_fe_space_set_up_facet_integration ( this )
  implicit none
  class(serial_fe_space_t), target, intent(inout) :: this

  type(fe_facet_iterator_t) :: fe_face
  type(fe_cell_iterator_t)  :: fe

  integer(ip) :: facet_quadrature_position
  integer(ip) :: facet_maps_position
  integer(ip) :: facet_integrator_position

  integer(ip)            :: max_order_fes_around_fe_face
  integer(ip)            :: reference_fes_geo_id(2)
  type(p_reference_fe_t) :: reference_fes_geo(2)

  integer(ip)            :: reference_fes_id(2)
  type(p_reference_fe_t) :: reference_fes(2)

  integer(ip) :: facet_quadratures_position_key
  integer(ip) :: facet_integrators_position_key

  integer(ip) :: field_id, istat, icell_around

  class(reference_fe_t), pointer :: reference_fe
  integer(ip)          , pointer :: max_order_field_cell_to_ref_fes_face(:)
  type(quadrature_t), pointer    :: quadrature

  type(quadrature_t)      , pointer :: current_facet_quadrature
  type(facet_maps_t)      , pointer :: current_facet_maps
  type(facet_integrator_t), pointer :: current_facet_integrator
  
  class(vef_iterator_t), allocatable :: vef
  class(triangulation_t), pointer :: triangulation
  
  call this%compute_facet_permutation_indices()
  call this%compute_max_order_field_cell_to_ref_fes_face()
  max_order_field_cell_to_ref_fes_face => this%max_order_field_cell_to_ref_fes_face%get_pointer()
  
  call this%facet_quadratures_position%init()
  call this%facet_integrators_position%init()
  call this%facet_quadratures%resize(0)
  call this%facet_maps%resize(0)
  call this%facet_integrators%resize(0)
  facet_quadrature_position = 1
  facet_maps_position = 1
  facet_integrator_position = 1

  call fe%create(this)
  
  ! Creating fe_facet_iterator_t
  triangulation => this%get_triangulation()
  call triangulation%create_vef_iterator(vef)
  call fe_face%create(this,vef)
  call triangulation%free_vef_iterator(vef)  
  do while ( .not. fe_face%has_finished() ) 
     reference_fes_geo_id(2) = 0
     nullify(reference_fes_geo(2)%p)
     do icell_around = 1, fe_face%get_num_cells_around()
        call fe_face%get_cell_around(icell_around, fe)
        reference_fes_geo_id(icell_around) =  fe%get_reference_fe_geo_id()
        reference_fes_geo(icell_around)%p  => fe%get_reference_fe_geo()
     end do

     facet_quadratures_position_key = &
          this%generate_facet_quadratures_position_key(fe_face%get_quadrature_degree(), &
                                                         reference_fes_geo_id(1), &
                                                         reference_fes_geo_id(2) )
     
     call this%facet_quadratures_position%put(key  = facet_quadratures_position_key, &
                                                val  = facet_quadrature_position, &
                                                stat = istat)  
     if (istat == now_stored) then
        reference_fe=>this%reference_fes( max_order_field_cell_to_ref_fes_face(fe_face%get_gid()) )%p
        call this%facet_quadratures%resize(facet_quadrature_position)
        current_facet_quadrature => this%facet_quadratures%get_pointer(facet_quadrature_position)
        call reference_fe%create_facet_quadrature(current_facet_quadrature,fe_face%get_quadrature_degree())
        call this%facet_maps%resize(facet_maps_position)
        current_facet_maps => this%facet_maps%get_pointer(facet_maps_position)
        quadrature => fe_face%get_quadrature()
        call current_facet_maps%create( quadrature, &
                                        reference_fes_geo(1)%p,   &
                                        reference_fes_geo(2)%p )
        facet_quadrature_position = facet_quadrature_position + 1
        facet_maps_position = facet_maps_position + 1
     end if

     do field_id=1, this%get_num_fields()
        reference_fes_id(2) = 0  
        nullify(reference_fes(2)%p)
        do icell_around = 1, fe_face%get_num_cells_around()
           call fe_face%get_cell_around(icell_around, fe)
           reference_fes_id(icell_around) = this%field_cell_to_ref_fes(field_id)%get(fe%get_gid())
           reference_fes(icell_around)%p => fe%get_reference_fe(field_id)
        end do

        facet_integrators_position_key = &
             this%generate_facet_integrators_position_key(fe_face%get_quadrature_degree(), &
                                                            reference_fes_id(1), &
                                                            reference_fes_id(2) )

        call this%facet_integrators_position%put(key=facet_integrators_position_key, &
                                                   val=facet_integrator_position, &
                                                   stat=istat)
        if (istat == now_stored) then
           call this%facet_integrators%resize(facet_integrator_position)
           current_facet_integrator => this%facet_integrators%get_pointer(facet_integrator_position)
           quadrature => fe_face%get_quadrature()
           call current_facet_integrator%create(quadrature, &
                reference_fes(1)%p, &
                reference_fes(2)%p )
           facet_integrator_position = facet_integrator_position + 1
        end if
     end do
     call fe_face%next()
  end do
  call fe%free()
  call fe_face%free()
  
end subroutine serial_fe_space_set_up_facet_integration

subroutine serial_fe_space_free_facet_integration ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip) :: i, istat

  call this%facet_quadratures_position%free()
  call this%facet_integrators_position%free()

  call this%facet_quadratures%free()
  call this%facet_maps%free()
  call this%facet_integrators%free()
  
  call this%free_facet_quadratures_degree()
  call this%free_max_order_field_cell_to_ref_fes_face()
  
  call this%free_facet_permutation_indices()
  
end subroutine serial_fe_space_free_facet_integration

! Provided the identifiers of the reference_fes_geo corresponding 
! to the cells around a fe_face, and the quadrature degree, computes a unique key 
! that is used to retrieve the position in the "this%facet_quadratures(:)" allocatable array through 
! the corresponding hash table. Some comments:
!    * [quadrature_degree >= -1]
!    * right_geo_reference_fe_id can range from 0 to num_reference_fes_geo 
!      (with 0 for boundary fe_faces)
!    * left_geo_reference_fe_id can range from 1 to num_reference_fes_geo
function serial_fe_space_facet_quadratures_position_key ( this, quadrature_degree, left_geo_reference_fe_id, right_geo_reference_fe_id )
  implicit none
  class(serial_fe_space_t)    , intent(in) :: this
  integer(ip)                 , intent(in) :: quadrature_degree
  integer(ip)                 , intent(in) :: left_geo_reference_fe_id
  integer(ip)                 , intent(in) :: right_geo_reference_fe_id
  integer(ip) :: serial_fe_space_facet_quadratures_position_key
  integer(ip) :: num_reference_fes_geo

  num_reference_fes_geo = this%triangulation%get_num_reference_fes()
  serial_fe_space_facet_quadratures_position_key = left_geo_reference_fe_id + &
       (num_reference_fes_geo)*(right_geo_reference_fe_id) + &
       (num_reference_fes_geo)*(num_reference_fes_geo+1)*(quadrature_degree+1)
end function serial_fe_space_facet_quadratures_position_key

! For a given field, provided the identifiers of the reference_fes corresponding 
! to the cells around a fe_face, and the quadrature degree to be used, computes a unique key that 
! is used to retrieve the position in the "this%facet_integrators(:)" allocatable array through the corresponding 
! hash table. Some comments:
!    * [quadrature_degree >= -1]
!    * right_reference_fe_id can range from 1 to this%reference_fes_size 
!      (with 0 for boundary fe_faces)
!    * left_reference_fe_id can range from 1 to this%reference_fes_size
function serial_fe_space_facet_integrators_position_key(this, quadrature_degree, left_reference_fe_id, right_reference_fe_id)
  implicit none
  class(serial_fe_space_t)    , intent(in) :: this
  integer(ip)                 , intent(in) :: quadrature_degree
  integer(ip)                 , intent(in) :: left_reference_fe_id
  integer(ip)                 , intent(in) :: right_reference_fe_id
  integer(ip) :: serial_fe_space_facet_integrators_position_key
  serial_fe_space_facet_integrators_position_key = left_reference_fe_id + &
       (this%reference_fes_size)*(right_reference_fe_id) + &
       (this%reference_fes_size)*(this%reference_fes_size+1)*(quadrature_degree+1)
end function serial_fe_space_facet_integrators_position_key

subroutine serial_fe_space_create_dof_values(this, dof_values)
  implicit none
  class(serial_fe_space_t)    , intent(in)    :: this
  class(vector_t), allocatable, intent(inout) :: dof_values
  integer(ip) :: istat
  
  if (allocated(dof_values)) then
     call dof_values%free()
     deallocate(dof_values, stat=istat); check(istat==0);
  end if

  if (this%block_layout%get_num_blocks() == 1) then
     allocate ( serial_scalar_array_t  :: dof_values )
     select type(dof_values)
        class is(serial_scalar_array_t)
        call dof_values%create_and_allocate(this%block_layout%get_block_num_dofs(1))
        class default
        check(.false.)
     end select
  else
     allocate ( serial_block_array_t  :: dof_values )
     select type(dof_values)
        class is(serial_block_array_t)
        call dof_values%create_and_allocate(this%block_layout%get_num_blocks(),this%block_layout%get_num_dofs_x_block())
        class default
        check(.false.)
     end select
  end if
end subroutine serial_fe_space_create_dof_values

subroutine serial_fe_space_generate_global_dof_numbering( this )
  implicit none
  class(serial_fe_space_t)    , intent(inout) :: this
  logical :: perform_numbering
  
  call this%allocate_num_dofs_x_field()
  if ( this%num_fields > 1 ) then 
    call this%count_dofs()
  end if  
  call this%list_dofs()
  call this%setup_hanging_node_constraints()
end subroutine serial_fe_space_generate_global_dof_numbering

subroutine serial_fe_space_count_dofs ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this   
  logical, allocatable :: per_field_proper_vefs_visited(:,:)
  logical, allocatable :: per_field_improper_vefs_visited(:,:)
  integer(ip) :: field_id, vef_lid, ivef, num_own_dofs_on_vef, iblock
  class(fe_cell_iterator_t), allocatable :: fe, coarser_fe, source_fe
  type(fe_vef_iterator_t) :: vef
  integer(ip) :: ielem
  logical :: local_found
  
  ! Count #DoFs per field
  this%num_dofs_x_field = 0
  
  call memalloc ( this%num_fields, this%triangulation%get_num_proper_vefs(), per_field_proper_vefs_visited,  __FILE__, __LINE__ )
  call memalloc ( this%num_fields, this%triangulation%get_num_improper_vefs(), per_field_improper_vefs_visited,  __FILE__, __LINE__ )
  per_field_proper_vefs_visited = .false.
  per_field_improper_vefs_visited = .false.

  call this%create_fe_cell_iterator(fe)
  call this%create_fe_cell_iterator(source_fe)
  call this%create_fe_vef_iterator(vef)
  call this%create_fe_cell_iterator(coarser_fe)
  do while ( .not. fe%has_finished())
     if ( fe%is_local() ) then
        do field_id=1, this%num_fields
          if ( .not. fe%is_void(field_id)) then
            this%num_dofs_x_field(field_id) = this%num_dofs_x_field(field_id) + &
                                              fe%count_own_dofs_cell(field_id)
            if ( this%fe_space_type_x_field(field_id) == fe_space_type_cg ) then
               do ivef = 1, fe%get_num_vefs()
                 call fe%get_vef(ivef,vef)
                 if ( .not. vef%all_coarser_cells_are_void(field_id,coarser_fe) ) cycle
                 vef_lid = abs(fe%get_vef_gid(ivef))
                 if ( vef%is_proper() ) then
                   if ( .not. per_field_proper_vefs_visited (field_id,vef_lid) ) then
                     num_own_dofs_on_vef = fe%count_own_dofs_vef(ivef,field_id)
                     if (num_own_dofs_on_vef>0) then
                       per_field_proper_vefs_visited (field_id,vef_lid) = .true.
                       this%num_dofs_x_field(field_id) = this%num_dofs_x_field(field_id) + &
                                                                   num_own_dofs_on_vef 
                     end if
                   end if
                 else if ( .not. per_field_improper_vefs_visited (field_id,vef_lid) ) then
                   num_own_dofs_on_vef = fe%count_own_dofs_vef(ivef,field_id)
                   if (num_own_dofs_on_vef>0) then
                     per_field_improper_vefs_visited (field_id,vef_lid) = .true.
                     this%num_dofs_x_field(field_id) = this%num_dofs_x_field(field_id) + &
                                                                 num_own_dofs_on_vef 
                   end if
                 end if
               end do
            end if
          end if
        end do
     end if
     call fe%next()
  end do
  
  call fe%first()
  do while(.not. fe%has_finished())
     if ( fe%is_ghost() ) then
         do field_id = 1, this%num_fields
           if ( .not. fe%is_void(field_id)) then
              if ( this%fe_space_type_x_field(field_id) == fe_space_type_cg ) then
                 do ivef = 1, fe%get_num_vefs()
                   call fe%get_vef(ivef, vef)
                   if ( vef%is_at_interface() ) then
                     local_found = .false.
                     ! Find local element around vef_lid in elem_id
                     do ielem=1, vef%get_num_cells_around()
                       call vef%get_cell_around(ielem, source_fe)
                       if ( source_fe%is_local() .and. (.not. source_fe%is_void(field_id)) ) then
                         local_found = .true.
                         exit
                       end if
                     end do
                     if ( .not. local_found ) then
                        vef_lid = abs(fe%get_vef_gid(ivef))
                        if ( vef%is_proper() ) then
                          if ( .not. per_field_proper_vefs_visited (field_id,vef_lid) ) then
                           num_own_dofs_on_vef = fe%count_own_dofs_vef(ivef,field_id)
                           if (num_own_dofs_on_vef>0) then
                             per_field_proper_vefs_visited (field_id,vef_lid) = .true.
                             this%num_dofs_x_field(field_id) = this%num_dofs_x_field(field_id) + &
                                                               num_own_dofs_on_vef 
                           end if
                          end if
                        else if ( .not. per_field_improper_vefs_visited (field_id,vef_lid) ) then
                           do ielem=1, vef%get_num_improper_cells_around()
                             call vef%get_improper_cell_around(ielem, coarser_fe)
                             if ( coarser_fe%is_local() .and. (.not. coarser_fe%is_void(field_id)) ) then
                               local_found = .true.
                               exit
                             end if
                           end do
                           if ( local_found ) then
                             num_own_dofs_on_vef = fe%count_own_dofs_vef(ivef,field_id)
                             if (num_own_dofs_on_vef>0) then
                               per_field_improper_vefs_visited (field_id,vef_lid) = .true.
                               this%num_dofs_x_field(field_id) = this%num_dofs_x_field(field_id) + &
                                                                  num_own_dofs_on_vef 
                             end if
                           end if
                        end if
                     end if
                   end if
                 end do
              else
                 do ivef = 1, fe%get_num_vefs()
                    call fe%get_vef(ivef, vef)
                    if ( vef%is_facet() .and. vef%is_at_interface() ) then
                      call fe%generate_dofs_facet_integration_coupling ( ivef, &
                                                                         field_id, &
                                                                         this%num_dofs_x_field(field_id) )
                    end if
                 end do  
              end if
           end if
         end do
     end if
     call fe%next()    
  end do
  
  ! Count #DoFs per block
  call this%block_layout%clear_num_dofs_x_block()
  do field_id=1, this%get_num_fields()
    iblock = this%block_layout%get_block_id(field_id) 
    call this%block_layout%add_to_block_num_dofs(iblock,this%num_dofs_x_field(field_id))     
  end do
  
  call this%free_fe_cell_iterator(coarser_fe)
  call this%free_fe_vef_iterator(vef)
  call this%free_fe_cell_iterator(fe)
  call this%free_fe_cell_iterator(source_fe)
  call memfree ( per_field_proper_vefs_visited,  __FILE__, __LINE__ )
  call memfree ( per_field_improper_vefs_visited,  __FILE__, __LINE__ )
end subroutine serial_fe_space_count_dofs 

subroutine serial_fe_space_list_dofs ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this   

  integer(ip), allocatable :: owner_cell_gid_x_field_and_proper_vef(:,:)
  integer(ip), allocatable :: owner_cell_gid_x_field_and_improper_vef(:,:)
  integer(ip), allocatable :: per_field_proper_vef_lid_in_owner_cell (:,:)
  integer(ip), allocatable :: per_field_improper_vef_lid_in_owner_cell (:,:)
  integer(ip), allocatable :: blocks_current_num_dofs(:)
  integer(ip), allocatable :: fields_current_dof(:)
  class(fe_cell_iterator_t), allocatable :: fe, source_fe, coarser_fe
  type(fe_vef_iterator_t)  :: vef
  integer(ip) :: block_id, field_id
  integer(ip) :: ivef, jvef, vef_gid
  integer(ip) :: previous_dof_block
  integer(ip) :: current_fixed_dof, previous_fixed_dof
  integer(ip) :: source_cell_id, source_vef_lid
  logical     :: is_owner, fe_is_local, add_dofs
  integer(ip) :: ielem
  integer(ip) :: ivef_in_source_fe
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t) :: own_dofs_on_vef_iterator
  type(list_iterator_t) :: n_faces_n_face_iterator
  class(reference_fe_t), pointer :: reference_fe_geo
  integer(ip) :: coarse_vef_lid
  integer(ip) :: coarse_vef_gid

  current_fixed_dof = this%num_fixed_dofs

  call memalloc ( this%get_num_fields(), & 
       this%triangulation%get_num_proper_vefs(), & 
       owner_cell_gid_x_field_and_proper_vef,  __FILE__, __LINE__ )
  owner_cell_gid_x_field_and_proper_vef = -1

  call memalloc ( this%get_num_fields(), & 
       this%triangulation%get_num_improper_vefs(), & 
       owner_cell_gid_x_field_and_improper_vef,  __FILE__, __LINE__ )
  owner_cell_gid_x_field_and_improper_vef = -1

  call memalloc ( this%get_num_fields(), &
       this%triangulation%get_num_proper_vefs(), & 
       per_field_proper_vef_lid_in_owner_cell,  __FILE__, __LINE__ )
  per_field_proper_vef_lid_in_owner_cell = -1

  call memalloc ( this%get_num_fields(), & 
       this%triangulation%get_num_improper_vefs(), &
       per_field_improper_vef_lid_in_owner_cell,  __FILE__, __LINE__ )
  per_field_improper_vef_lid_in_owner_cell = -1

  call memalloc( this%block_layout%get_num_blocks(), blocks_current_num_dofs, __FILE__, __LINE__ )
  blocks_current_num_dofs = 0

  call memalloc( this%num_fields, fields_current_dof, __FILE__, __LINE__ )
  fields_current_dof = 0

  if (this%num_fields > 1) then
     do field_id=1, this%num_fields
        block_id = this%block_layout%get_block_id(field_id)
        fields_current_dof(field_id) = fields_current_dof(field_id) + blocks_current_num_dofs(block_id)
        blocks_current_num_dofs(block_id) = blocks_current_num_dofs(block_id) + this%num_dofs_x_field(field_id)
     end do
  end if

  call this%create_fe_cell_iterator(coarser_fe)
  call this%create_fe_cell_iterator(source_fe)
  call this%create_fe_cell_iterator(fe)
  call this%create_fe_vef_iterator(vef)
  do while ( .not. fe%has_finished())
     fe_is_local = fe%is_local()
     do field_id=1, this%get_num_fields()
        if (.not. fe%is_void(field_id)) then
           ! Own cell DoFs have to be only generated for local cells
           if ( fe_is_local ) then
              call fe%generate_own_dofs_cell ( field_id, fields_current_dof(field_id) )
           end if
           do ivef= 1, fe%get_num_vefs()
              call fe%get_vef(ivef,vef)
              if ( .not. vef%is_ghost() ) then
                 if ( this%fe_space_type_x_field(field_id) == fe_space_type_cg ) then

                    vef_gid = abs(fe%get_vef_gid(ivef))

                    ! There will be (potentially) free DoFs on top of the current cell if either:
                    !  1. vef is proper
                    !  2. vef is improper, it is on a local cell, and all coarse cells are void
                    if ( vef%is_proper() .or. (fe_is_local .and. &
                         vef%all_coarser_cells_are_void(field_id,coarser_fe)) ) then
                       is_owner = .false.
                       if ( vef%is_proper() ) then
                          is_owner = ( owner_cell_gid_x_field_and_proper_vef( field_id, vef_gid ) == -1 )
                       else 
                          is_owner = ( owner_cell_gid_x_field_and_improper_vef( field_id, vef_gid ) == -1 )
                       end if

                       if ( is_owner ) then
                          previous_dof_block = fields_current_dof(field_id)
                          call fe%generate_own_dofs_vef ( ivef, &
                               field_id, &
                               fields_current_dof(field_id), &
                               free_dofs_loop=.true. )
                          if ( previous_dof_block < fields_current_dof(field_id) ) then
                             if ( vef%is_proper() ) then
                                owner_cell_gid_x_field_and_proper_vef ( field_id, vef_gid ) = fe%get_gid() 
                                per_field_proper_vef_lid_in_owner_cell ( field_id, vef_gid ) = ivef 
                             else
                                owner_cell_gid_x_field_and_improper_vef ( field_id, vef_gid ) = fe%get_gid() 
                                per_field_improper_vef_lid_in_owner_cell ( field_id, vef_gid ) = ivef 
                             end if
                          end if
                       else
                          if ( vef%is_proper() ) then
                             source_cell_id = owner_cell_gid_x_field_and_proper_vef(field_id, vef_gid)
                             source_vef_lid = per_field_proper_vef_lid_in_owner_cell(field_id,vef_gid)
                          else
                             source_cell_id = owner_cell_gid_x_field_and_improper_vef(field_id, vef_gid)
                             source_vef_lid = per_field_improper_vef_lid_in_owner_cell(field_id,vef_gid)
                          end if
                          call source_fe%set_gid( source_cell_id )
                          call fe%fetch_own_dofs_vef_from_source_fe ( ivef, source_fe, source_vef_lid, field_id ) 
                       end if
                    else
                       do ielem=1, vef%get_num_improper_cells_around()
                          call vef%get_improper_cell_around(ielem,coarser_fe)
                          if (.not. coarser_fe%is_void(field_id)) then
                             ! Generate free DoFs on top of proper coarse vef
                             coarse_vef_lid=vef%get_improper_cell_around_ivef(ielem)
                             coarse_vef_gid=coarser_fe%get_vef_gid(coarse_vef_lid)
                             call generate_dofs_on_proper_vefs_of_coarser_cell()

                             ! Generate free DoFs on top of proper coarse vefs at boundary of coarse vef
                             reference_fe_geo => coarser_fe%get_reference_fe_geo() 
                             n_faces_n_face_iterator = reference_fe_geo%create_n_faces_n_face_iterator(coarse_vef_lid)
                             do while( .not. n_faces_n_face_iterator%is_upper_bound() )
                                coarse_vef_lid=n_faces_n_face_iterator%get_current()
                                coarse_vef_gid=coarser_fe%get_vef_gid(coarse_vef_lid)
                                call generate_dofs_on_proper_vefs_of_coarser_cell()
                                call n_faces_n_face_iterator%next()
                             end do

                             ! Once all n-faces on the boundary of coarser_n_face (and coarser_n_face itself)
                             ! have been visited at least on a non-void FE, its not required to re-visit them
                             ! afterwards again
                             exit
                          end if
                       end do
                       assert ( .not. vef%is_proper() )
                       if ( owner_cell_gid_x_field_and_improper_vef( field_id, vef_gid ) == -1 ) then
                          if ( fe_is_local ) then
                             add_dofs = .true. 
                          else
                             add_dofs = .false.
                             do ielem=1, vef%get_num_improper_cells_around()
                                call vef%get_improper_cell_around(ielem, coarser_fe)
                                if ( coarser_fe%is_local() .and. (.not. coarser_fe%is_void(field_id)) ) then
                                   add_dofs = .true.
                                   exit
                                end if
                             end do
                          end if
                          if ( add_dofs ) then 
                             previous_fixed_dof = current_fixed_dof
                             call fe%generate_own_dofs_vef ( ivef, field_id, current_fixed_dof, free_dofs_loop=.false.)
                             if (previous_fixed_dof < current_fixed_dof) then
                                owner_cell_gid_x_field_and_improper_vef( field_id, vef_gid ) = fe%get_gid()
                                per_field_improper_vef_lid_in_owner_cell ( field_id, vef_gid ) = ivef 
                             end if
                          end if
                       else 
                          call source_fe%set_gid(owner_cell_gid_x_field_and_improper_vef(field_id, vef_gid))
                          call fe%fetch_own_dofs_vef_from_source_fe ( ivef,      &
                               source_fe, &
                               per_field_improper_vef_lid_in_owner_cell(field_id,vef_gid), &
                               field_id ) 
                       end if
                    end if
                 else
                    if ( vef%is_facet() .and. vef%is_at_interface() ) then
                       call fe%generate_dofs_facet_integration_coupling ( ivef, &
                            field_id, &
                            this%num_dofs_x_field(field_id) )
                    end if
                 end if
              end if
           end do
        end if

        ! has_fixed_dofs_x_fe must also be filled on ghost FEs (as the 
        ! `at_strong_dirichlet_boundary_x_fe` array), otherwise
        ! the procedures fe_function_insert/gather_nodal_values skip inserting the
        ! fixed dof values on ghost FEs (constraining dirichlet DoFs included)
        call fe%determine_has_fixed_dofs(field_id)


        ! Although the `hanging_dofs_x_fe` array (seems to be) only (currently) used 
        ! in the local assembly procedures, we also compute it for ghost FEs for the
        ! sake of correctness
        call fe%determine_has_hanging_dofs(field_id)
     end do
     call fe%next()
  end do


  ! Set #DoFs per field and block in case of single-field, single-block problem
  ! (as we did not call fe_space%count_dofs() in this case)
  if ( this%num_fields == 1 ) then
     field_id = 1
     block_id = 1
     this%num_dofs_x_field(field_id) = fields_current_dof(field_id)
     call this%block_layout%set_block_num_dofs(block_id,this%num_dofs_x_field(field_id))
  end if

  this%num_hanging_dofs = current_fixed_dof - this%num_fixed_dofs
  this%num_fixed_dofs   = current_fixed_dof

  call this%free_fe_cell_iterator(coarser_fe)
  call this%free_fe_cell_iterator(source_fe)
  call this%free_fe_cell_iterator(fe)
  call this%free_fe_vef_iterator(vef)
  call memfree( blocks_current_num_dofs, __FILE__, __LINE__ )
  call memfree( fields_current_dof     , __FILE__, __LINE__ )
  call memfree ( owner_cell_gid_x_field_and_proper_vef,  __FILE__, __LINE__ )
  call memfree ( owner_cell_gid_x_field_and_improper_vef,  __FILE__, __LINE__ )
  call memfree ( per_field_proper_vef_lid_in_owner_cell,  __FILE__, __LINE__ )
  call memfree ( per_field_improper_vef_lid_in_owner_cell,  __FILE__, __LINE__ )

contains 

  subroutine generate_dofs_on_proper_vefs_of_coarser_cell()
    implicit none
    ! Let us check whether coarser_fe is owner of coarse_vef_gid, 
    ! and generate own DoFs identifiers on top of it if this is the case
    is_owner = ( owner_cell_gid_x_field_and_proper_vef( field_id, coarse_vef_gid ) == -1 )
    if ( is_owner ) then
       previous_dof_block = fields_current_dof(field_id)
       call coarser_fe%generate_own_dofs_vef ( coarse_vef_lid, &
            field_id, &
            fields_current_dof(field_id), &
            free_dofs_loop=.true. )
       if ( previous_dof_block < fields_current_dof(field_id) ) then
          owner_cell_gid_x_field_and_proper_vef ( field_id, coarse_vef_gid ) = coarser_fe%get_gid() 
          per_field_proper_vef_lid_in_owner_cell( field_id, coarse_vef_gid ) = coarse_vef_lid
       end if
    end if
  end subroutine generate_dofs_on_proper_vefs_of_coarser_cell

end subroutine serial_fe_space_list_dofs 

subroutine serial_fe_space_allocate_num_dofs_x_field( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  if ( .not. allocated(this%num_dofs_x_field) ) & 
     call memalloc( this%get_num_fields(), this%num_dofs_x_field, __FILE__, __LINE__ )
  assert ( size(this%num_dofs_x_field) == this%get_num_fields() )
end subroutine serial_fe_space_allocate_num_dofs_x_field

subroutine serial_fe_space_renum_dofs_block (this, block_id, perm_old2new)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip)             , intent(in)    :: block_id
  integer(ip)             , intent(in)    :: perm_old2new(this%block_layout%get_block_num_dofs(block_id))
  class(fe_cell_iterator_t), allocatable :: fe

  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe%has_finished())
     call fe%renum_dofs_block ( block_id, perm_old2new )
     call fe%next()
  end do
  call this%free_fe_cell_iterator(fe)

end subroutine serial_fe_space_renum_dofs_block

function serial_fe_space_get_num_dims ( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip)                          :: serial_fe_space_get_num_dims
  class(triangulation_t), pointer :: triangulation
  triangulation => this%get_triangulation()
  serial_fe_space_get_num_dims = triangulation%get_num_dims()
end function serial_fe_space_get_num_dims

function serial_fe_space_get_num_reference_fes ( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip) :: serial_fe_space_get_num_reference_fes
  serial_fe_space_get_num_reference_fes = size(this%reference_fes)
end function serial_fe_space_get_num_reference_fes

function serial_fe_space_get_reference_fe ( this, reference_fe_id )
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  integer(ip)                     , intent(in) :: reference_fe_id
  class(reference_fe_t), pointer :: serial_fe_space_get_reference_fe
  assert ( reference_fe_id >=1 .and. reference_fe_id <= this%get_num_reference_fes() )
  serial_fe_space_get_reference_fe => this%reference_fes(reference_fe_id)%p
end function serial_fe_space_get_reference_fe

function serial_fe_space_get_field_type ( this, field_id )
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  integer(ip)                     , intent(in) :: field_id
  character(:), pointer :: serial_fe_space_get_field_type
  serial_fe_space_get_field_type => this%reference_fes(this%set_ids_to_reference_fes(field_id,1))%p%get_field_type()
end function serial_fe_space_get_field_type

function serial_fe_space_determine_fe_space_type(this, field_id)
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip)             , intent(in) :: field_id
  integer(ip)                          :: serial_fe_space_determine_fe_space_type
  class(reference_fe_t), pointer       :: reference_fe
  reference_fe => this%reference_fes(this%set_ids_to_reference_fes(field_id,1))%p
  if ( reference_fe%get_conformity() .and. reference_fe%get_continuity()  ) then
    serial_fe_space_determine_fe_space_type = fe_space_type_cg
  else if ( reference_fe%get_conformity() .and. .not. reference_fe%get_continuity() ) then
    serial_fe_space_determine_fe_space_type = fe_space_type_dg_conforming
  else 
    serial_fe_space_determine_fe_space_type = fe_space_type_dg
  end if
end function serial_fe_space_determine_fe_space_type


function serial_fe_space_get_num_components ( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip) :: serial_fe_space_get_num_components
  integer(ip) :: field_id
  serial_fe_space_get_num_components = 0
  do field_id = 1, this%get_num_fields()
     serial_fe_space_get_num_components = serial_fe_space_get_num_components + &
          this%reference_fes(this%set_ids_to_reference_fes(field_id,1))%p%get_num_field_components()
  end do
end function serial_fe_space_get_num_components

function serial_fe_space_get_max_num_shape_functions( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_max_num_shape_functions
  integer(ip) :: irefe
  serial_fe_space_get_max_num_shape_functions = 0
  do irefe = 1, this%reference_fes_size
     serial_fe_space_get_max_num_shape_functions = max(serial_fe_space_get_max_num_shape_functions, &
          this%reference_fes(irefe)%p%get_num_shape_functions())
  end do
end function serial_fe_space_get_max_num_shape_functions

function serial_fe_space_get_max_num_dofs_on_a_cell( this ) result (max_dofs)
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip) :: i, max_dofs
  class(fe_cell_iterator_t), allocatable :: fe
  
  ! If (same) set of reference FEs on top of all cells ...
  if ( size(this%set_ids_to_reference_fes,2) == 1 ) then
    max_dofs = 0
    do i=1, size(this%reference_fes) 
      max_dofs = max_dofs + this%reference_fes(i)%p%get_num_shape_functions()
    end do 
  else
    max_dofs = 0
    call this%create_fe_cell_iterator(fe)
    do while (.not. fe%has_finished())
      max_dofs = max(max_dofs,fe%get_num_dofs())
      call fe%next()
    end do
    call this%free_fe_cell_iterator(fe)
   end if
end function serial_fe_space_get_max_num_dofs_on_a_cell

function serial_fe_space_get_max_num_quadrature_points( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_max_num_quadrature_points
  type(quadrature_t), pointer :: cell_quadratures(:)
  integer(ip)                 :: iquad
  serial_fe_space_get_max_num_quadrature_points = 0
  cell_quadratures => this%cell_quadratures%get_pointer()
  do iquad = 1, size(cell_quadratures)
     serial_fe_space_get_max_num_quadrature_points =         &
          max(serial_fe_space_get_max_num_quadrature_points, &
          cell_quadratures(iquad)%get_num_quadrature_points())
  end do
end function serial_fe_space_get_max_num_quadrature_points

function serial_fe_space_get_max_num_nodal_quadrature_points( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_max_num_nodal_quadrature_points
  integer(ip) :: i
  type(quadrature_t), pointer :: nodal_quadrature

  serial_fe_space_get_max_num_nodal_quadrature_points = 0
  do i= 1, this%reference_fes_size
     if (this%reference_fes(i)%p%has_nodal_quadrature()) then
        nodal_quadrature => this%reference_fes(i)%p%get_nodal_quadrature()
        serial_fe_space_get_max_num_nodal_quadrature_points =       & 
             max(serial_fe_space_get_max_num_nodal_quadrature_points, &
             nodal_quadrature%get_num_quadrature_points())
     end if
  end do
end function serial_fe_space_get_max_num_nodal_quadrature_points

function serial_fe_space_get_max_num_facet_quadrature_points( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_max_num_facet_quadrature_points
  type(quadrature_t), pointer :: facet_quadratures(:)
  integer(ip)                 :: iquad
  serial_fe_space_get_max_num_facet_quadrature_points = 0
  facet_quadratures => this%facet_quadratures%get_pointer()
  do iquad = 1, size(facet_quadratures)
     serial_fe_space_get_max_num_facet_quadrature_points =       & 
          max(serial_fe_space_get_max_num_facet_quadrature_points, &
          facet_quadratures(iquad)%get_num_quadrature_points())
  end do
end function serial_fe_space_get_max_num_facet_quadrature_points

function serial_fe_space_get_max_order( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_max_order
  integer(ip) :: irefe
  serial_fe_space_get_max_order = 0
  do irefe = 1, this%reference_fes_size
     serial_fe_space_get_max_order = max(serial_fe_space_get_max_order, &
          this%reference_fes(irefe)%p%get_max_order())
  end do
end function serial_fe_space_get_max_order

function serial_fe_space_get_triangulation( this) result(triangulation)
  implicit none
  class(serial_fe_space_t)      , intent(in)    :: this 
  class(triangulation_t), pointer       :: triangulation
  assert ( associated(this%triangulation) )
  triangulation => this%triangulation
end function serial_fe_space_get_triangulation

subroutine serial_fe_space_set_triangulation( this, triangulation )
  implicit none
  class(serial_fe_space_t)                  , intent(inout) :: this 
  class(triangulation_t), target, intent(in)    :: triangulation
  this%triangulation => triangulation
end subroutine serial_fe_space_set_triangulation

subroutine serial_fe_space_set_environment( this, environment)
  implicit none
  class(serial_fe_space_t)                  , intent(inout) :: this 
  class(environment_t), target              , intent(in)    :: environment
  this%environment => environment
end subroutine serial_fe_space_set_environment

function serial_fe_space_get_environment(this) result(environment)
  implicit none
  class(serial_fe_space_t), intent(in)    :: this 
  class(environment_t), pointer:: environment 
  environment => this%environment
end function serial_fe_space_get_environment

function serial_fe_space_get_conditions( this) result(conditions)
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this 
  class(conditions_t), pointer :: conditions
  assert ( associated(this%conditions) )
  conditions => this%conditions
end function serial_fe_space_get_conditions

subroutine serial_fe_space_set_conditions( this, conditions )
  implicit none
  class(serial_fe_space_t)        , intent(inout) :: this 
  class(conditions_t)     , target, intent(in)    :: conditions
  this%conditions => conditions
end subroutine serial_fe_space_set_conditions

function serial_fe_space_get_ptr_dofs_per_fe(this)
  implicit none
  class(serial_fe_space_t), target, intent(in)    :: this 
  type(std_vector_integer_ip_t), pointer :: serial_fe_space_get_ptr_dofs_per_fe(:)
  serial_fe_space_get_ptr_dofs_per_fe => this%ptr_dofs_x_fe
end function serial_fe_space_get_ptr_dofs_per_fe

function serial_fe_space_get_num_fixed_dofs(this)
  implicit none
  class(serial_fe_space_t), intent(in)    :: this 
  integer(ip) :: serial_fe_space_get_num_fixed_dofs
  serial_fe_space_get_num_fixed_dofs = this%num_fixed_dofs
end function serial_fe_space_get_num_fixed_dofs

subroutine serial_fe_space_set_num_fixed_dofs(this,num_fixed_dofs)
  implicit none
  class(serial_fe_space_t), intent(inout)    :: this 
  integer(ip), intent(inout) :: num_fixed_dofs
  this%num_fixed_dofs = num_fixed_dofs
end subroutine serial_fe_space_set_num_fixed_dofs

function serial_fe_space_get_num_dirichlet_dofs(this)
  implicit none
  class(serial_fe_space_t), intent(in)    :: this 
  integer(ip) :: serial_fe_space_get_num_dirichlet_dofs
  serial_fe_space_get_num_dirichlet_dofs = this%num_dirichlet_dofs
end function serial_fe_space_get_num_dirichlet_dofs

function serial_fe_space_get_num_hanging_dofs(this)
  implicit none
  class(serial_fe_space_t), intent(in)    :: this 
  integer(ip) :: serial_fe_space_get_num_hanging_dofs
  serial_fe_space_get_num_hanging_dofs = this%num_hanging_dofs
end function serial_fe_space_get_num_hanging_dofs

subroutine serial_fe_space_set_num_hanging_dofs(this,num_hanging_dofs)
  implicit none
  class(serial_fe_space_t), intent(inout)    :: this 
  integer(ip), intent(in) :: num_hanging_dofs
  this%num_hanging_dofs = num_hanging_dofs
end subroutine serial_fe_space_set_num_hanging_dofs

function serial_fe_space_get_num_blocks( this)
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_num_blocks
  serial_fe_space_get_num_blocks = this%block_layout%get_num_blocks()
end function serial_fe_space_get_num_blocks

function serial_fe_space_get_field_blocks( this )
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  integer(ip), pointer :: serial_fe_space_get_field_blocks(:)
  class(environment_t), pointer :: environment
  environment => this%get_environment()
  nullify(serial_fe_space_get_field_blocks)
  if ( environment%am_i_l1_task() ) then
     serial_fe_space_get_field_blocks => this%block_layout%get_field_id_to_block_id()
  end if
end function serial_fe_space_get_field_blocks

function serial_fe_space_get_field_coupling( this )
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  logical, pointer :: serial_fe_space_get_field_coupling(:,:)
  class(environment_t), pointer :: environment
  environment => this%get_environment()
  nullify(serial_fe_space_get_field_coupling)
  if ( environment%am_i_l1_task() ) then
     serial_fe_space_get_field_coupling => this%block_layout%get_field_coupling()
  end if
end function serial_fe_space_get_field_coupling

! Returns the number of DoFs associated to block with identifier block_id
function serial_fe_space_get_block_num_dofs ( this, block_id )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip)          , intent(in) :: block_id
  integer(ip)                       :: serial_fe_space_get_block_num_dofs
  class(environment_t), pointer  :: environment
  environment => this%get_environment()
  serial_fe_space_get_block_num_dofs = 0
  if ( environment%am_i_l1_task() ) then 
     serial_fe_space_get_block_num_dofs  = this%block_layout%get_block_num_dofs(block_id)
  end if
end function serial_fe_space_get_block_num_dofs

! Sets the number of DoFs associated to block with identifier block_id to num_dofs
subroutine serial_fe_space_set_block_num_dofs ( this, block_id, num_dofs )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip)             , intent(in)    :: block_id
  integer(ip)             , intent(in)    :: num_dofs
  class(environment_t), pointer  :: environment
  environment => this%get_environment()
  if ( environment%am_i_l1_task() ) then 
     call this%block_layout%set_block_num_dofs(block_id,num_dofs)
  end if
end subroutine serial_fe_space_set_block_num_dofs

! Returns a pointer to the block_layout member variable
function serial_fe_space_get_block_layout ( this )
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  type(block_layout_t), pointer :: serial_fe_space_get_block_layout
  serial_fe_space_get_block_layout => this%block_layout
end function serial_fe_space_get_block_layout

function serial_fe_space_get_ptr_constraining_free_dofs(this)
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  type(std_vector_integer_ip_t), pointer :: serial_fe_space_get_ptr_constraining_free_dofs
  serial_fe_space_get_ptr_constraining_free_dofs => this%ptr_constraining_free_dofs
end function serial_fe_space_get_ptr_constraining_free_dofs

function serial_fe_space_get_ptr_constraining_dirichlet_dofs(this)
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  type(std_vector_integer_ip_t), pointer :: serial_fe_space_get_ptr_constraining_dirichlet_dofs
  serial_fe_space_get_ptr_constraining_dirichlet_dofs => this%ptr_constraining_dirichlet_dofs
end function serial_fe_space_get_ptr_constraining_dirichlet_dofs

function serial_fe_space_get_constraining_free_dofs(this)
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  type(std_vector_integer_ip_t), pointer :: serial_fe_space_get_constraining_free_dofs
  serial_fe_space_get_constraining_free_dofs => this%constraining_free_dofs
end function serial_fe_space_get_constraining_free_dofs

function serial_fe_space_get_constraining_free_dofs_coefficients(this)
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  type(std_vector_real_rp_t), pointer :: serial_fe_space_get_constraining_free_dofs_coefficients
  serial_fe_space_get_constraining_free_dofs_coefficients => this%constraining_free_dofs_coefficients
end function serial_fe_space_get_constraining_free_dofs_coefficients

function serial_fe_space_get_constraining_dirichlet_dofs(this)
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  type(std_vector_integer_ip_t), pointer :: serial_fe_space_get_constraining_dirichlet_dofs
  serial_fe_space_get_constraining_dirichlet_dofs => this%constraining_dirichlet_dofs
end function serial_fe_space_get_constraining_dirichlet_dofs

function serial_fe_space_get_constraining_dirichlet_dofs_coefficients(this)
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  type(std_vector_real_rp_t), pointer :: serial_fe_space_get_constraining_dirichlet_dofs_coefficients
  serial_fe_space_get_constraining_dirichlet_dofs_coefficients => this%constraining_dirichlet_dofs_coefficients
end function serial_fe_space_get_constraining_dirichlet_dofs_coefficients

function serial_fe_space_get_constraints_independent_term(this)
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
     type(std_vector_real_rp_t), pointer :: serial_fe_space_get_constraints_independent_term
     serial_fe_space_get_constraints_independent_term => this%constraints_independent_term
end function serial_fe_space_get_constraints_independent_term

function serial_fe_space_is_free_dof ( this, dof_lid )
  implicit none
  class(serial_fe_space_t)   , intent(in) :: this
  integer(ip)            , intent(in) :: dof_lid
  logical :: serial_fe_space_is_free_dof
  serial_fe_space_is_free_dof = dof_lid > 0
end function serial_fe_space_is_free_dof

function serial_fe_space_is_strong_dirichlet_dof ( this, dof_lid )
  implicit none
  class(serial_fe_space_t)   , intent(in) :: this
  integer(ip)            , intent(in) :: dof_lid
  logical :: serial_fe_space_is_strong_dirichlet_dof
  serial_fe_space_is_strong_dirichlet_dof = (dof_lid < 0 .and. dof_lid >= -this%num_dirichlet_dofs )
end function serial_fe_space_is_strong_dirichlet_dof

function serial_fe_space_is_fixed_dof ( this, dof_lid )
  implicit none
  class(serial_fe_space_t)   , intent(in) :: this
  integer(ip)            , intent(in) :: dof_lid
  logical :: serial_fe_space_is_fixed_dof
  serial_fe_space_is_fixed_dof = dof_lid < 0
end function serial_fe_space_is_fixed_dof

function serial_fe_space_is_hanging_dof ( this, dof_lid )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip)              , intent(in) :: dof_lid
  logical :: serial_fe_space_is_hanging_dof
  serial_fe_space_is_hanging_dof = dof_lid < -this%num_dirichlet_dofs
end function serial_fe_space_is_hanging_dof

subroutine serial_fe_space_create_fe_cell_iterator ( this, fe )
  implicit none
  class(serial_fe_space_t)         , intent(in)  :: this
  class(fe_cell_iterator_t), allocatable, intent(inout) :: fe
  integer(ip) :: istat
  call this%free_fe_cell_iterator(fe)
  allocate(fe_cell_iterator_t :: fe, stat=istat); check(istat==0)
  call fe%create(this)
end subroutine serial_fe_space_create_fe_cell_iterator

subroutine serial_fe_space_free_fe_cell_iterator ( this, fe )
  implicit none
  class(serial_fe_space_t)         , intent(in)  :: this
  class(fe_cell_iterator_t), allocatable, intent(inout) :: fe
  integer(ip) :: istat
  if(allocated(fe)) then
     call fe%free()
     deallocate(fe, stat=istat); check(istat==0)
  end if
end subroutine serial_fe_space_free_fe_cell_iterator

subroutine serial_fe_space_create_fe_vef_iterator ( this, fe_vef )
  implicit none
  class(serial_fe_space_t), target, intent(in)    :: this
  type(fe_vef_iterator_t)         , intent(inout) :: fe_vef
  class(triangulation_t), pointer :: triangulation
  class(vef_iterator_t), allocatable :: vef
  triangulation => this%get_triangulation()
  call triangulation%create_vef_iterator(vef)
  call fe_vef%free()
  call fe_vef%create(this,vef)
  call triangulation%free_vef_iterator(vef)
end subroutine serial_fe_space_create_fe_vef_iterator

subroutine serial_fe_space_create_itfc_fe_vef_iterator ( this, fe_vef )
  implicit none
  class(serial_fe_space_t), target, intent(in)    :: this
  type(fe_vef_iterator_t)         , intent(inout) :: fe_vef
  type(itfc_vef_iterator_t) :: vef
  call fe_vef%free()
  call fe_vef%create(this,vef)
end subroutine serial_fe_space_create_itfc_fe_vef_iterator

subroutine serial_fe_space_free_fe_vef_iterator ( this, fe_vef )
  implicit none
  class(serial_fe_space_t), intent(in)    :: this
  class(fe_vef_iterator_t), intent(inout) :: fe_vef
  call fe_vef%free()
end subroutine serial_fe_space_free_fe_vef_iterator

subroutine serial_fe_space_create_fe_facet_iterator ( this, fe_face )
  implicit none
  class(serial_fe_space_t) , target     , intent(in)    :: this
  class(fe_facet_iterator_t), allocatable, intent(inout) :: fe_face
  class(vef_iterator_t), allocatable :: vef
  class(triangulation_t), pointer :: triangulation
  integer(ip)          :: istat
  call this%free_fe_facet_iterator(fe_face)
  triangulation => this%get_triangulation()
  call triangulation%create_vef_iterator(vef)
  allocate(fe_facet_iterator_t :: fe_face, stat=istat); check(istat==0)
  call fe_face%create(this,vef)
  call triangulation%free_vef_iterator(vef)
end subroutine serial_fe_space_create_fe_facet_iterator

subroutine serial_fe_space_free_fe_facet_iterator ( this, fe_face )
  implicit none
  class(serial_fe_space_t)              , intent(in)    :: this
  class(fe_facet_iterator_t), allocatable, intent(inout) :: fe_face
  integer(ip) :: istat
  if (allocated(fe_face)) then
    call fe_face%free()
    deallocate(fe_face, stat=istat); check(istat==0);
  end if
end subroutine serial_fe_space_free_fe_facet_iterator

subroutine serial_fe_space_allocate_and_init_has_hanging_dofs_x_fe(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this 
  integer(ip) :: field_id, error
  if ( .not. allocated( this%has_hanging_dofs_x_fe ) ) then
    allocate( this%has_hanging_dofs_x_fe(this%num_fields), stat = error ) ; check( error == 0 )
  end if
  do field_id = 1,this%num_fields
    call this%has_hanging_dofs_x_fe(field_id)%resize(0)
    call this%has_hanging_dofs_x_fe(field_id)%resize(this%triangulation%get_num_cells(),.false.)
  end do
end subroutine serial_fe_space_allocate_and_init_has_hanging_dofs_x_fe

subroutine serial_fe_space_free_has_hanging_dofs_x_fe(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this 
  integer(ip) :: field_id, error
  if ( allocated(this%has_hanging_dofs_x_fe) ) then
    do field_id = 1,this%num_fields
      call this%has_hanging_dofs_x_fe(field_id)%free()
    end do
    deallocate( this%has_hanging_dofs_x_fe, stat = error ) ; check ( error == 0 )
  end if
end subroutine serial_fe_space_free_has_hanging_dofs_x_fe

subroutine serial_fe_space_free_ptr_constraining_free_dofs( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this 
  call this%ptr_constraining_free_dofs%free()
end subroutine serial_fe_space_free_ptr_constraining_free_dofs

subroutine serial_fe_space_free_constraining_free_dofs( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this 
  call this%constraining_free_dofs%free()  
end subroutine serial_fe_space_free_constraining_free_dofs

subroutine serial_fe_space_free_constraining_free_dofs_coefficients( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this 
  integer(ip) :: istat, block_id
  call this%constraining_free_dofs_coefficients%free()   
end subroutine serial_fe_space_free_constraining_free_dofs_coefficients

subroutine serial_fe_space_free_ptr_constraining_dirichlet_dofs( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this 
  call this%ptr_constraining_dirichlet_dofs%free()
end subroutine serial_fe_space_free_ptr_constraining_dirichlet_dofs

subroutine serial_fe_space_free_constraining_dirichlet_dofs( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this 
  call this%constraining_dirichlet_dofs%free()  
end subroutine serial_fe_space_free_constraining_dirichlet_dofs

subroutine serial_fe_space_free_constraining_dirichlet_dofs_coefficients( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this 
  integer(ip) :: istat, block_id
  call this%constraining_dirichlet_dofs_coefficients%free()   
end subroutine serial_fe_space_free_constraining_dirichlet_dofs_coefficients

subroutine serial_fe_space_free_constraints_independent_term( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this 
  integer(ip) :: istat, block_id
  call this%constraints_independent_term%free()   
end subroutine serial_fe_space_free_constraints_independent_term

subroutine serial_fe_space_setup_hanging_node_constraints ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this 
  class(fe_cell_iterator_t), allocatable :: fe
  class(fe_cell_iterator_t), allocatable :: coarser_fe
  type(fe_vef_iterator_t) :: fe_vef, fe_vef_bis, coarser_vef
  type(list_iterator_t) :: fe_own_dofs_on_vef_iterator
  type(list_iterator_t) :: fe_dofs_on_vef_iterator 
  type(list_iterator_t) :: coarser_fe_dofs_on_vef_iterator
  integer(ip) :: improper_vef_lid
  integer(ip) :: block_id, field_id
  class(reference_fe_t), pointer :: reference_fe, coarser_reference_fe
  integer(ip), pointer :: fe_dofs(:), coarser_fe_fe_dofs(:)
  integer(ip) :: istat, i, icell, min_cell_gid
  integer(ip) :: improper_dof_lid, hanging_dof_lid
  integer(ip) :: improper_vef_ivef, coarser_fe_ivef, coarse_fe_subvef
  integer(ip), pointer :: field_blocks(:)
  integer(ip) :: qpoint, ishape_fe, ishape_coarser_fe, subcell_id 
  type(interpolation_t), pointer :: h_refinement_interpolation
  integer(ip), pointer :: h_refinement_subedge_permutation(:,:,:)
  integer(ip), pointer :: h_refinement_subfacet_permutation(:,:,:)
  integer(ip), pointer :: h_refinement_subcell_permutation(:,:,:)
  real(rp) :: coefficient
  integer(ip) :: num_cell_vertices, num_cell_edges, num_cell_faces
  integer(ip) :: num_subedges_x_edge, num_subfaces_x_face
  integer(ip) :: vef_lid, facet_lid
  type(list_t), pointer :: facets_n_face
  type(list_iterator_t) :: facets_n_face_iterator
  type(list_iterator_t) :: dofs_n_facet_iterator
  integer(ip) :: facet_dof

  logical :: local_found
  
  ! Re-size to 0 to force re-initialization during second resize (to the actual/correct size)
  call this%ptr_constraining_free_dofs%resize(0)
  call this%ptr_constraining_dirichlet_dofs%resize(0)
  call this%constraining_free_dofs%resize(0)
  call this%constraining_free_dofs_coefficients%resize(0)
  call this%constraining_dirichlet_dofs%resize(0)
  call this%constraining_dirichlet_dofs_coefficients%resize(0)
  call this%constraints_independent_term%resize(0)

  call this%ptr_constraining_free_dofs%resize(this%num_hanging_dofs+1,0)
  call this%ptr_constraining_dirichlet_dofs%resize(this%num_hanging_dofs+1,0)
  call this%constraining_free_dofs%resize(this%num_hanging_dofs)
  call this%constraining_free_dofs_coefficients%resize(this%num_hanging_dofs)
  call this%constraining_dirichlet_dofs%resize(this%num_hanging_dofs)
  call this%constraining_dirichlet_dofs_coefficients%resize(this%num_hanging_dofs)
  call this%constraints_independent_term%resize(this%num_hanging_dofs)

  if ( this%num_hanging_dofs == 0 ) return
    
  field_blocks => this%get_field_blocks()
  call this%create_fe_cell_iterator(fe)
  call this%create_fe_cell_iterator(coarser_fe)
  call this%create_fe_vef_iterator(fe_vef)
  call this%create_fe_vef_iterator(fe_vef_bis)
  call this%create_fe_vef_iterator(coarser_vef)

  reference_fe => fe%get_reference_fe(1)
  num_cell_vertices = reference_fe%get_num_vertices()
  if  (this%triangulation%get_num_dims() == 3) then
     num_cell_edges       = reference_fe%get_num_n_faces_of_dim(1)
     num_subfaces_x_face  = 4
     num_subedges_x_edge  = 2 
  else
     num_cell_edges       = 0
     num_subfaces_x_face  = 2
  end if
  num_cell_faces = reference_fe%get_num_facets()

  allocate(fe_dofs(this%get_num_fields()), stat=istat); check(istat==0);
  allocate(coarser_fe_fe_dofs(this%get_num_fields()), stat=istat); check(istat==0);

  ! Computation of constraints     
  do improper_vef_lid = 1, this%triangulation%get_num_improper_vefs()
     call fe_vef%set_gid(-improper_vef_lid)

     if ( fe_vef%is_ghost() ) cycle 
     
     do field_id=1, this%get_num_fields()

        ! Retrieve all data related to the current improper vef 
        ! and one of the cells that owns it
        local_found = .false.
        do icell = 1,fe_vef%get_num_cells_around()
           call fe_vef%get_cell_around(icell,fe)
           if ( fe%is_local() .and. .not. fe%is_void(field_id) ) then 
             local_found = .true.
             exit
           end if
        end do
        if ( .not. local_found ) then
          do icell = 1,fe_vef%get_num_cells_around()
            call fe_vef%get_cell_around(icell,fe)
            if ( fe%is_ghost() .and. .not. fe%is_void(field_id) ) exit
          end do
        end if
        if ( fe%is_void(field_id) ) cycle
        improper_vef_ivef = fe%get_vef_lid_from_gid(fe_vef%get_gid())
        call fe%get_field_fe_dofs(field_id,fe_dofs)

        ! Retrieve all data related to the first improper cell around current improper vef
        do icell = 1,fe_vef%get_num_improper_cells_around()
           call fe_vef%get_improper_cell_around(icell,coarser_fe)
           if ( .not. ( coarser_fe%is_void(field_id) .or. ( fe%is_ghost() .and. coarser_fe%is_ghost() ) ) ) exit
        end do
        if ( coarser_fe%is_void(field_id) .or. ( fe%is_ghost() .and. coarser_fe%is_ghost() ) ) cycle
        coarser_fe_ivef = fe_vef%get_improper_cell_around_ivef(icell)
        call coarser_fe%get_field_fe_dofs(field_id,coarser_fe_fe_dofs)

        reference_fe => fe%get_reference_fe(field_id)
        coarser_reference_fe  => coarser_fe%get_reference_fe(field_id)
        block_id = field_blocks(field_id)
        fe_own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(improper_vef_ivef)
        do while (.not. fe_own_dofs_on_vef_iterator%is_upper_bound() )
           improper_dof_lid = fe_dofs(fe_own_dofs_on_vef_iterator%get_current())
           ishape_fe = fe_own_dofs_on_vef_iterator%get_current()

           if ( fe%is_free_dof(improper_dof_lid) ) exit

           improper_dof_lid = abs(improper_dof_lid)
           hanging_dof_lid  = improper_dof_lid - this%num_dirichlet_dofs

           coarser_fe_dofs_on_vef_iterator = coarser_reference_fe%create_dofs_on_n_face_iterator(coarser_fe_ivef)
           do while (.not. coarser_fe_dofs_on_vef_iterator%is_upper_bound() )
              ishape_coarser_fe = coarser_fe_dofs_on_vef_iterator%get_current()

              if ( coarser_reference_fe%get_fe_type() == fe_type_lagrangian ) then
                if ( coarser_reference_fe%get_component_node(ishape_coarser_fe) /= reference_fe%get_component_node(ishape_fe) ) then
                  call coarser_fe_dofs_on_vef_iterator%next()
                  cycle
                end if
              end if

              if ( fe%is_strong_dirichlet_dof( coarser_fe_fe_dofs(coarser_fe_dofs_on_vef_iterator%get_current()) ) ) then
                call this%ptr_constraining_dirichlet_dofs%set(hanging_dof_lid+1, &
                     this%ptr_constraining_dirichlet_dofs%get(hanging_dof_lid+1)+1)
              else
                call this%ptr_constraining_free_dofs%set(hanging_dof_lid+1, &
                     this%ptr_constraining_free_dofs%get(hanging_dof_lid+1)+1)
              end if

              call coarser_fe_dofs_on_vef_iterator%next()
           end do
           call fe_own_dofs_on_vef_iterator%next() 
        end do
     end do
  end do


  call this%ptr_constraining_free_dofs%transform_length_to_header()
  call this%constraining_free_dofs%resize(this%ptr_constraining_free_dofs%get(this%ptr_constraining_free_dofs%size())-1)
  call this%constraining_free_dofs_coefficients%resize(this%ptr_constraining_free_dofs%get(this%ptr_constraining_free_dofs%size())-1)
  call this%ptr_constraining_dirichlet_dofs%transform_length_to_header()

  call this%constraining_dirichlet_dofs%resize(this%ptr_constraining_dirichlet_dofs%get(this%ptr_constraining_dirichlet_dofs%size())-1)
  call this%constraining_dirichlet_dofs_coefficients%resize(this%ptr_constraining_dirichlet_dofs%get(this%ptr_constraining_dirichlet_dofs%size())-1)

  ! Computation of constraints     
  do improper_vef_lid = 1, this%triangulation%get_num_improper_vefs()
     call fe_vef%set_gid(-improper_vef_lid)

     if ( fe_vef%is_ghost() ) cycle 
     
     do field_id=1, this%get_num_fields()

        ! Retrieve all data related to the current improper vef 
        ! and one of the cells that owns it
        local_found = .false.
        do icell = 1,fe_vef%get_num_cells_around()
           call fe_vef%get_cell_around(icell,fe)
           if ( fe%is_local() .and. .not. fe%is_void(field_id) ) then 
             local_found = .true.
             exit
           end if
        end do
        if ( .not. local_found ) then
          do icell = 1,fe_vef%get_num_cells_around()
            call fe_vef%get_cell_around(icell,fe)
            if ( fe%is_ghost() .and. .not. fe%is_void(field_id) ) exit
          end do
        end if
        if ( fe%is_void(field_id) ) cycle
        improper_vef_ivef = fe%get_vef_lid_from_gid(fe_vef%get_gid())
        call fe%get_field_fe_dofs(field_id,fe_dofs)

        ! Retrieve all data related to the first improper cell around current improper vef
        do icell = 1,fe_vef%get_num_improper_cells_around()
           call fe_vef%get_improper_cell_around(icell,coarser_fe)
           if ( .not. ( coarser_fe%is_void(field_id) .or. ( fe%is_ghost() .and. coarser_fe%is_ghost() ) ) ) exit
        end do
        if ( coarser_fe%is_void(field_id) .or. ( fe%is_ghost() .and. coarser_fe%is_ghost() ) ) cycle
        coarser_fe_ivef  = fe_vef%get_improper_cell_around_ivef(icell)
        coarse_fe_subvef = fe_vef%get_improper_cell_around_subvef(icell)

        call coarser_fe%get_field_fe_dofs(field_id,coarser_fe_fe_dofs)
        call coarser_fe%get_vef(coarser_fe_ivef,coarser_vef)

        reference_fe => fe%get_reference_fe(field_id)
        coarser_reference_fe => coarser_fe%get_reference_fe(field_id)

        h_refinement_subedge_permutation  => coarser_reference_fe%get_h_refinement_subedge_permutation()
        h_refinement_subfacet_permutation => coarser_reference_fe%get_h_refinement_subfacet_permutation() 

        block_id = field_blocks(field_id)
        fe_own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(improper_vef_ivef)
        fe_dofs_on_vef_iterator = reference_fe%create_dofs_on_n_face_iterator(improper_vef_ivef)
        do while (.not. fe_own_dofs_on_vef_iterator%is_upper_bound() )
           ishape_fe = fe_own_dofs_on_vef_iterator%get_current()
           improper_dof_lid = fe_dofs(ishape_fe)
           assert ( fe%is_fixed_dof(improper_dof_lid) )
           improper_dof_lid = abs(improper_dof_lid)
           hanging_dof_lid  = improper_dof_lid - this%num_dirichlet_dofs

           call fe_dofs_on_vef_iterator%begin() 
           do while (.not. fe_dofs_on_vef_iterator%is_upper_bound() )
              if ( fe_dofs_on_vef_iterator%get_current() == ishape_fe ) exit
              call fe_dofs_on_vef_iterator%next() 
           end do
           assert (.not. fe_dofs_on_vef_iterator%is_upper_bound() )

              if ( fe_vef%get_dim() == 0 ) then ! vef is a corner (2D/3D)
                 if ( coarser_vef%get_dim()  == 1 .and. this%triangulation%get_num_dims() == 3) then
                    qpoint = h_refinement_subedge_permutation(coarser_fe_ivef-num_cell_vertices,num_subedges_x_edge,1)
                 else
                    qpoint = h_refinement_subfacet_permutation(coarser_fe_ivef-num_cell_vertices-num_cell_edges,num_subfaces_x_face,1)
                 end if
              else if ( fe_vef%get_dim()  == 1 .and. this%triangulation%get_num_dims() == 3 .and. coarse_fe_subvef > 0 ) then 
                 qpoint = h_refinement_subedge_permutation(coarser_fe_ivef-num_cell_vertices, &
                      coarse_fe_subvef, &
                      fe_dofs_on_vef_iterator%get_distance_to_lower_bound())
              else if ( fe_vef%get_dim()  == 1 .and. this%triangulation%get_num_dims() == 3 .and. coarse_fe_subvef < 0 ) then
                 assert ( fe_vef%get_num_cells_around() == 2 )
                 ! Go over cells around fe_vef(), and find the one with the minimum global identifier
                 call fe_vef%get_cell_around(1,fe)
                 min_cell_gid=fe%get_gid()
                 call fe_vef%get_cell_around(2,fe)
                 min_cell_gid=min(fe%get_gid(),min_cell_gid)
                 call fe%set_gid(min_cell_gid)

                 call fe%get_field_fe_dofs(field_id,fe_dofs)

                 reference_fe  => fe%get_reference_fe(field_id)    
                 facets_n_face => reference_fe%get_facets_n_face()      

                 ! Go over faces around fe_vef in cell with minimum global identifier
                 facet_loop: do facet_lid = reference_fe%get_first_facet_id(), &
                      reference_fe%get_first_facet_id() + reference_fe%get_num_facets()-1
                    call fe_vef_bis%set_gid(fe%get_vef_gid(facet_lid))
                    if (.not. fe_vef_bis%is_proper()) then
                       facets_n_face_iterator = facets_n_face%create_iterator(facet_lid)
                       do while (.not. facets_n_face_iterator%is_upper_bound())
                          if (fe%get_vef_gid(facets_n_face_iterator%get_current()) == fe_vef%get_gid() ) then
                             exit facet_loop
                          end if
                          call facets_n_face_iterator%next()
                       end do
                    end if
                 end do facet_loop

                 assert(facet_lid<=reference_fe%get_first_facet_id() + reference_fe%get_num_facets()-1)

                 ! Go over DoFs on facet, and locate the facet dof LID corresponding to the edge DoF 
                 facet_dof=1
                 dofs_n_facet_iterator = reference_fe%create_dofs_n_face_iterator(facet_lid)
                 do while (.not. dofs_n_facet_iterator%is_upper_bound())
                    if (fe_dofs(dofs_n_facet_iterator%get_current()) == -improper_dof_lid) then
                       exit
                    end if
                    call dofs_n_facet_iterator%next()
                    facet_dof = facet_dof+1
                 end do
                 assert (.not. dofs_n_facet_iterator%is_upper_bound())

                 qpoint = h_refinement_subfacet_permutation(coarser_fe_ivef-num_cell_vertices-num_cell_edges,&
                      abs(coarse_fe_subvef),&
                      facet_dof)              
              else if (fe_vef%get_dim() == this%triangulation%get_num_dims()-1) then ! vef is a face (2D/3D)
                 qpoint = h_refinement_subfacet_permutation(coarser_fe_ivef-num_cell_vertices-num_cell_edges, &
                      coarse_fe_subvef, &
                      fe_dofs_on_vef_iterator%get_distance_to_lower_bound())
              end if

              coarser_fe_dofs_on_vef_iterator = coarser_reference_fe%create_dofs_on_n_face_iterator(coarser_fe_ivef)
           do while (.not. coarser_fe_dofs_on_vef_iterator%is_upper_bound() )
              ishape_coarser_fe = coarser_fe_dofs_on_vef_iterator%get_current() 

              ! In Lagrangian FEs the constraints are component by component (i.e., a DOF in component x will never constrain a DOF
              ! in component y or z)
              if ( coarser_reference_fe%get_fe_type() == fe_type_lagrangian ) then
                if ( coarser_reference_fe%get_component_node(ishape_coarser_fe) /= reference_fe%get_component_node(ishape_fe) ) then
                  call coarser_fe_dofs_on_vef_iterator%next()
                  cycle
                end if
              end if

              ! Evaluate coefficient
              call coarser_reference_fe%get_h_refinement_coefficient(ishape_fe,ishape_coarser_fe,qpoint,coefficient)

              ! Set dependency and coefficient into the corresponding std_vector data structure
              if ( fe%is_strong_dirichlet_dof( coarser_fe_fe_dofs(ishape_coarser_fe) ) ) then
                call this%constraining_dirichlet_dofs%set(this%ptr_constraining_dirichlet_dofs%get(hanging_dof_lid),&
                     coarser_fe_fe_dofs(ishape_coarser_fe))
                call this%constraining_dirichlet_dofs_coefficients%set(this%ptr_constraining_dirichlet_dofs%get(hanging_dof_lid),&
                     coefficient)
                call this%ptr_constraining_dirichlet_dofs%set(hanging_dof_lid, &
                     this%ptr_constraining_dirichlet_dofs%get(hanging_dof_lid)+1)
              else
                call this%constraining_free_dofs%set(this%ptr_constraining_free_dofs%get(hanging_dof_lid),&
                     coarser_fe_fe_dofs(ishape_coarser_fe))
                call this%constraining_free_dofs_coefficients%set(this%ptr_constraining_free_dofs%get(hanging_dof_lid),&
                     coefficient)
                call this%ptr_constraining_free_dofs%set(hanging_dof_lid, &
                     this%ptr_constraining_free_dofs%get(hanging_dof_lid)+1)
              end if

              call coarser_fe_dofs_on_vef_iterator%next()
           end do
           call fe_own_dofs_on_vef_iterator%next() 
        end do
     end do
  end do

  do i=this%ptr_constraining_free_dofs%size(),2,-1
     call this%ptr_constraining_free_dofs%set(i, this%ptr_constraining_free_dofs%get(i-1))
  end do
  call this%ptr_constraining_free_dofs%set(1,1)

  do i=this%ptr_constraining_dirichlet_dofs%size(),2,-1
     call this%ptr_constraining_dirichlet_dofs%set(i, this%ptr_constraining_dirichlet_dofs%get(i-1))
  end do
  call this%ptr_constraining_dirichlet_dofs%set(1,1)

  call this%free_fe_cell_iterator(coarser_fe)
  call this%free_fe_cell_iterator(fe)
  call this%free_fe_vef_iterator(fe_vef)
  call this%free_fe_vef_iterator(fe_vef_bis)
  call this%free_fe_vef_iterator(coarser_vef)
end subroutine serial_fe_space_setup_hanging_node_constraints

subroutine serial_fe_space_project_field_cell_to_ref_fes(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  class(triangulation_t)       , pointer     :: triangulation
  type(std_vector_integer_ip_t), pointer     :: refinement_and_coarsening_flags
  class(fe_cell_iterator_t)    , allocatable :: new_fe
  class(reference_fe_t)        , pointer     :: reference_fe
  type(std_vector_integer_ip_t)              :: old_field_cell_to_ref_fes
  integer(ip)                                :: num_children_x_cell
  integer(ip)                                :: subcell_id, old_cell_lid, new_cell_lid
  integer(ip)                                :: field_id
  integer(ip)                                :: transformation_flag
  integer(ip)                                :: old_reference_fe_id
  integer(ip)                                :: old_num_local_cells, old_num_ghost_cells
  class(p4est_base_triangulation_t), pointer :: p4est_triangulation 
 
#ifdef ENABLE_P4EST  
  triangulation => this%get_triangulation()
  select type(triangulation)
  class is (p4est_base_triangulation_t)
    refinement_and_coarsening_flags => triangulation%get_refinement_and_coarsening_flags()
    p4est_triangulation             => triangulation
  class default
    assert(.false.)
  end select
  
  call this%create_fe_cell_iterator(new_fe)
  reference_fe => new_fe%get_reference_fe_geo()
  num_children_x_cell = reference_fe%get_num_n_faces_of_dim(0)
  old_num_local_cells = p4est_triangulation%get_previous_num_local_cells()
  old_num_ghost_cells = p4est_triangulation%get_previous_num_ghost_cells()
  do field_id = 1,this%num_fields
    old_cell_lid = 1
    new_cell_lid = 1
    call old_field_cell_to_ref_fes%copy(this%field_cell_to_ref_fes(field_id))
    call this%field_cell_to_ref_fes(field_id)%resize(0)
    call this%field_cell_to_ref_fes(field_id)%resize(this%triangulation%get_num_cells(),1)
    do while ( old_cell_lid .le. old_num_local_cells )
      transformation_flag = refinement_and_coarsening_flags%get(old_cell_lid)
      old_reference_fe_id  = old_field_cell_to_ref_fes%get(old_cell_lid)
      call new_fe%set_gid(new_cell_lid)
      if ( transformation_flag == do_nothing ) then
        call new_fe%set_reference_fe_id(field_id,old_reference_fe_id)
        new_cell_lid = new_cell_lid + 1
      else if ( transformation_flag == refinement ) then
        do subcell_id = 0,num_children_x_cell-1
          call new_fe%set_reference_fe_id(field_id,old_reference_fe_id)
          new_cell_lid = new_cell_lid + 1
          call new_fe%set_gid(new_cell_lid)
        end do
      else if ( transformation_flag == coarsening ) then
        do subcell_id = 1,num_children_x_cell-1
          old_cell_lid = old_cell_lid + 1
          if ( old_reference_fe_id /= old_field_cell_to_ref_fes%get(old_cell_lid) ) then
            massert(.false.,'Coarsened subcells do not have the same reference FE id')
          end if
        end do
        call new_fe%set_reference_fe_id(field_id,old_reference_fe_id)
        new_cell_lid = new_cell_lid + 1
      else
        massert(.false.,'Unrecognised refinement and coarsening flag')
      end if
      old_cell_lid = old_cell_lid + 1
    end do
  end do
  
  massert ( (new_cell_lid - 1) == this%triangulation%get_num_local_cells(), 'Loop in old cells failed to visit all new cells' )
  call this%free_fe_cell_iterator(new_fe)
  call old_field_cell_to_ref_fes%free()
#else  
  call this%not_enabled_error()
#endif  
end subroutine serial_fe_space_project_field_cell_to_ref_fes

subroutine serial_fe_space_project_fe_integration_arrays(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  ! if allocated, FE integration arrays not projected
#ifdef ENABLE_P4EST  
#else  
  call this%not_enabled_error()
#endif  
end subroutine serial_fe_space_project_fe_integration_arrays

subroutine serial_fe_space_project_facet_integration_arrays(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  ! if allocated, FE face integration arrays not projected
#ifdef ENABLE_P4EST  
#else  
  call this%not_enabled_error()
#endif  
end subroutine serial_fe_space_project_facet_integration_arrays

subroutine serial_fe_space_refine_and_coarsen_single_fe_function( this, fe_function )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  type(fe_function_t)     , intent(inout) :: fe_function
  class(triangulation_t), pointer     :: triangulation
  type(fe_function_t)                             :: transformed_fe_function
  type(std_vector_integer_ip_t)     , pointer     :: refinement_and_coarsening_flags
  type(std_vector_integer_ip_t)     , allocatable :: old_ptr_dofs_x_fe(:)
  type(std_vector_integer_ip_t)                   :: old_lst_dofs_gids
  integer(ip)                       , pointer     :: old_field_fe_dofs(:)
  integer(ip)                                     :: num_children_x_cell
  integer(ip)                                     :: transformation_flag
  integer(ip)                                     :: subcell_id, old_cell_lid, new_cell_lid
  integer(ip)                                     :: current_old_cell_lid, current_new_cell_lid
  integer(ip)                                     :: old_num_cells
  integer(ip)                                     :: field_id
  class(fe_cell_iterator_t)         , allocatable :: new_fe
  real(rp)                          , allocatable :: old_nodal_values(:,:)
  real(rp)                          , allocatable :: new_nodal_values(:)
  class(reference_fe_t)             , pointer     :: reference_fe
  integer(ip)                                     :: num_nodes_field
  type(block_layout_t)                            :: block_layout
  integer(ip)                                     :: error
  
#ifdef ENABLE_P4EST  
  triangulation => this%get_triangulation()
  select type(triangulation)
  class is (p4est_serial_triangulation_t)
    refinement_and_coarsening_flags => triangulation%get_refinement_and_coarsening_flags()
  class default
    assert(.false.)
  end select
  
  old_num_cells = refinement_and_coarsening_flags%size()
  
  call this%copy_ptr_lst_dofs(old_ptr_dofs_x_fe,old_lst_dofs_gids)
  massert ( old_num_cells == (old_ptr_dofs_x_fe(1)%size()-1), 'Incorrect size of refinement_and_coarsening_flags' )
  
  call this%project_field_cell_to_ref_fes()
  !call this%check_cell_vs_fe_topology_consistency()
  call this%fill_facet_gids()
  call this%project_fe_integration_arrays()
  call this%project_facet_integration_arrays()
  call this%allocate_and_init_ptr_lst_dofs_gids()
  call this%allocate_and_init_at_strong_dirichlet_bound()
  call this%allocate_and_init_has_fixed_dofs()
  call this%allocate_and_init_has_hanging_dofs_x_fe()
  call this%set_up_strong_dirichlet_bcs()
  
  ! Force that a new DoF numbering is generated for the refined/coarsened triangulation
  call this%generate_global_dof_numbering()
  
  call this%create_fe_cell_iterator(new_fe)
  reference_fe => new_fe%get_reference_fe_geo()
  num_children_x_cell = reference_fe%get_num_n_faces_of_dim(0)
  call memalloc(num_children_x_cell, &
                this%get_max_num_shape_functions(),old_nodal_values,__FILE__,__LINE__)
  call memalloc(this%get_max_num_shape_functions(),new_nodal_values,__FILE__,__LINE__)
  
  call transformed_fe_function%create(this)
  
  old_cell_lid = 1
  new_cell_lid = 1
  do while ( old_cell_lid .le. old_num_cells )
    transformation_flag = refinement_and_coarsening_flags%get(old_cell_lid)
    do field_id = 1,this%get_num_fields()
      call new_fe%set_gid(new_cell_lid)
      current_old_cell_lid = old_cell_lid
      current_new_cell_lid = new_cell_lid
      reference_fe => new_fe%get_reference_fe(field_id) ! Only h-adaptivity
      num_nodes_field = reference_fe%get_num_shape_functions()
      old_field_fe_dofs => get_field_fe_dofs()
      call fe_function%gather_nodal_values( field_id,                & 
                                            old_field_fe_dofs,      &
                                            num_nodes_field,      & 
                                            this%get_field_blocks(), &
                                            old_nodal_values(1,1:num_nodes_field) )
      if ( transformation_flag == do_nothing ) then
        call transformed_fe_function%insert_nodal_values( new_fe,   &
                                                          field_id, &
                                                          old_nodal_values(1,1:num_nodes_field) )
        current_new_cell_lid = current_new_cell_lid + 1
      else if ( transformation_flag == refinement ) then
         do subcell_id = 0,num_children_x_cell-1
            if ( .not. new_fe%is_void(field_id) ) then 
               call reference_fe%interpolate_nodal_values_on_subcell( subcell_id,                            & 
                                                                      old_nodal_values(1,1:num_nodes_field), &
                                                                      new_nodal_values(1:num_nodes_field) )
               call transformed_fe_function%insert_nodal_values( new_fe,   &
                                                                 field_id, &
                                                                 new_nodal_values(1:num_nodes_field) )
            end if
            current_new_cell_lid = current_new_cell_lid + 1
            call new_fe%set_gid(current_new_cell_lid)
         end do
      else if ( transformation_flag == coarsening ) then
        do subcell_id = 1,num_children_x_cell-1
          current_old_cell_lid = current_old_cell_lid + 1
          old_field_fe_dofs => get_field_fe_dofs()
          call fe_function%gather_nodal_values( field_id,                & 
                                                old_field_fe_dofs,      &
                                                num_nodes_field,      & 
                                                this%get_field_blocks(), &
                                                old_nodal_values(subcell_id+1,1:num_nodes_field) )
        end do
        if ( .not. new_fe%is_void(field_id) ) then 
           call reference_fe%project_nodal_values_on_cell( old_nodal_values(:,1:num_nodes_field), &
                                                           new_nodal_values(1:num_nodes_field) )
           call transformed_fe_function%insert_nodal_values( new_fe,   &
                                                             field_id, &
                                                             new_nodal_values(1:num_nodes_field) )
        end if
        current_new_cell_lid = current_new_cell_lid + 1
      else
        massert(.false.,'Unrecognised refinement and coarsening flag')
      end if
    end do
    old_cell_lid = current_old_cell_lid
    new_cell_lid = current_new_cell_lid
    old_cell_lid = old_cell_lid + 1
  end do

  massert ( new_cell_lid - 1 == this%triangulation%get_num_cells(), 'Loop in old cells failed to visit all new cells' )
  
  call fe_function%create(this)
  fe_function = transformed_fe_function
  call this%update_hanging_dof_values(fe_function)
    
  select type(triangulation)
  class is (p4est_serial_triangulation_t)
    call triangulation%clear_refinement_and_coarsening_flags()
  class default
    assert(.false.)
  end select
  
  call this%free_fe_cell_iterator(new_fe)
  call transformed_fe_function%free()
  call memfree(old_nodal_values,__FILE__,__LINE__)
  call memfree(new_nodal_values,__FILE__,__LINE__)
  do field_id = 1,this%num_fields
    call old_ptr_dofs_x_fe(field_id)%free()
  end do
  deallocate( old_ptr_dofs_x_fe, stat = error ); check( error == 0 )
  call old_lst_dofs_gids%free()
  
contains
  
  function get_field_fe_dofs()
    implicit none
    integer(ip), pointer     :: get_field_fe_dofs(:)
    integer(ip)              :: spos, epos
    spos = old_ptr_dofs_x_fe(field_id)%get(current_old_cell_lid)
    if ( field_id == this%get_num_fields() ) then
      epos = old_ptr_dofs_x_fe(1)%get(current_old_cell_lid+1)-1
    else
      epos = old_ptr_dofs_x_fe(field_id+1)%get(current_old_cell_lid)-1
    end if
    get_field_fe_dofs => old_lst_dofs_gids%get_pointer(spos,epos)
  end function get_field_fe_dofs
#else  
  call this%not_enabled_error()
#endif    
end subroutine serial_fe_space_refine_and_coarsen_single_fe_function

subroutine serial_fe_space_refine_and_coarsen_fe_function_array( this, fe_functions )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  type(p_fe_function_t)   , intent(inout) :: fe_functions(:)
  class(triangulation_t), pointer     :: triangulation
  type(fe_function_t)                             :: transformed_fe_function
  type(std_vector_integer_ip_t)     , pointer     :: refinement_and_coarsening_flags
  type(std_vector_integer_ip_t)     , allocatable :: old_ptr_dofs_x_fe(:)
  type(std_vector_integer_ip_t)                   :: old_lst_dofs_gids
  integer(ip)                       , pointer     :: old_field_fe_dofs(:)
  integer(ip)                                     :: num_children_x_cell
  integer(ip)                                     :: transformation_flag
  integer(ip)                                     :: subcell_id, old_cell_lid, new_cell_lid
  integer(ip)                                     :: current_old_cell_lid, current_new_cell_lid
  integer(ip)                                     :: old_num_cells
  integer(ip)                                     :: field_id
  class(fe_cell_iterator_t)         , allocatable :: new_fe
  real(rp)                          , allocatable :: old_nodal_values(:,:)
  real(rp)                          , allocatable :: new_nodal_values(:)
  class(reference_fe_t)             , pointer     :: reference_fe
  integer(ip)                                     :: num_nodes_field
  type(block_layout_t)                            :: block_layout
  integer(ip)                                     :: ifunc
  integer(ip)                                     :: error
  
#ifdef ENABLE_P4EST  
    triangulation => this%get_triangulation()
  select type(triangulation)
  class is (p4est_serial_triangulation_t)
    refinement_and_coarsening_flags => triangulation%get_refinement_and_coarsening_flags()
  class default
    assert(.false.)
  end select
  
  old_num_cells = refinement_and_coarsening_flags%size()
  
  call this%copy_ptr_lst_dofs(old_ptr_dofs_x_fe,old_lst_dofs_gids)
  massert ( old_num_cells == (old_ptr_dofs_x_fe(1)%size()-1), 'Incorrect size of refinement_and_coarsening_flags' )
  
  call this%project_field_cell_to_ref_fes()
  !call this%check_cell_vs_fe_topology_consistency()
  call this%fill_facet_gids()
  call this%project_fe_integration_arrays()
  call this%project_facet_integration_arrays()
  call this%allocate_and_init_ptr_lst_dofs_gids()
  call this%allocate_and_init_at_strong_dirichlet_bound()
  call this%allocate_and_init_has_fixed_dofs()
  call this%allocate_and_init_has_hanging_dofs_x_fe()
  call this%set_up_strong_dirichlet_bcs()
  
  ! Force that a new DoF numbering is generated for the refined/coarsened triangulation
  call this%generate_global_dof_numbering()
  
  call this%create_fe_cell_iterator(new_fe)
  reference_fe => new_fe%get_reference_fe_geo()
  num_children_x_cell = reference_fe%get_num_n_faces_of_dim(0)
  call memalloc(num_children_x_cell, &
                this%get_max_num_shape_functions(),old_nodal_values,__FILE__,__LINE__)
  call memalloc(this%get_max_num_shape_functions(),new_nodal_values,__FILE__,__LINE__)
  
  do ifunc = 1, size(fe_functions)
    
    call transformed_fe_function%create(this)
    
    old_cell_lid = 1
    new_cell_lid = 1
    do while ( old_cell_lid .le. old_num_cells )
      transformation_flag = refinement_and_coarsening_flags%get(old_cell_lid)
      do field_id = 1,this%get_num_fields()
        call new_fe%set_gid(new_cell_lid)
        current_old_cell_lid = old_cell_lid
        current_new_cell_lid = new_cell_lid
        reference_fe => new_fe%get_reference_fe(field_id) ! Only h-adaptivity
        num_nodes_field = reference_fe%get_num_shape_functions()
        old_field_fe_dofs => get_field_fe_dofs()
        call fe_functions(ifunc)%p%gather_nodal_values( field_id,                &
                                                        old_field_fe_dofs,       &
                                                        num_nodes_field,         &
                                                        this%get_field_blocks(), &
                                                        old_nodal_values(1,1:num_nodes_field) )
        if ( transformation_flag == do_nothing ) then
          call transformed_fe_function%insert_nodal_values( new_fe,   &
                                                            field_id, &
                                                            old_nodal_values(1,1:num_nodes_field) )
          current_new_cell_lid = current_new_cell_lid + 1
        else if ( transformation_flag == refinement ) then
          do subcell_id = 0,num_children_x_cell-1
             if (.not. new_fe%is_void(field_id) ) then 
              call reference_fe%interpolate_nodal_values_on_subcell( subcell_id,                               & 
                                                                     old_nodal_values(1,1:num_nodes_field), &
                                                                     new_nodal_values(1:num_nodes_field) )
              call transformed_fe_function%insert_nodal_values( new_fe,   &
                                                                field_id, &
                                                                new_nodal_values(1:num_nodes_field) )
           end if
            current_new_cell_lid = current_new_cell_lid + 1
            call new_fe%set_gid(current_new_cell_lid)
          end do
        else if ( transformation_flag == coarsening ) then
          do subcell_id = 1,num_children_x_cell-1
            current_old_cell_lid = current_old_cell_lid + 1
            old_field_fe_dofs => get_field_fe_dofs()
            call fe_functions(ifunc)%p%gather_nodal_values( field_id,                & 
                                                            old_field_fe_dofs,      &
                                                            num_nodes_field,      & 
                                                            this%get_field_blocks(), &
                                                            old_nodal_values(subcell_id+1,1:num_nodes_field) )
          end do
          if (.not. new_fe%is_void(field_id) ) then
            call reference_fe%project_nodal_values_on_cell( old_nodal_values(:,1:num_nodes_field), &
                                                            new_nodal_values(1:num_nodes_field) )
            call transformed_fe_function%insert_nodal_values( new_fe,   &
                                                              field_id, &
                                                              new_nodal_values(1:num_nodes_field) )
         end if
          current_new_cell_lid = current_new_cell_lid + 1
        else
          massert(.false.,'Unrecognised refinement and coarsening flag')
        end if
      end do
      old_cell_lid = current_old_cell_lid
      new_cell_lid = current_new_cell_lid
      old_cell_lid = old_cell_lid + 1
    end do

    massert ( new_cell_lid - 1 == this%triangulation%get_num_cells(), 'Loop in old cells failed to visit all new cells' )
    
    call fe_functions(ifunc)%p%create(this)
    call fe_functions(ifunc)%p%copy(transformed_fe_function)
    call this%update_hanging_dof_values(fe_functions(ifunc)%p)
  
  end do
  
  select type(triangulation)
  class is (p4est_serial_triangulation_t)
    call triangulation%clear_refinement_and_coarsening_flags()
  class default
    assert(.false.)
  end select
  
  call this%free_fe_cell_iterator(new_fe)
  call transformed_fe_function%free()
  call memfree(old_nodal_values,__FILE__,__LINE__)
  call memfree(new_nodal_values,__FILE__,__LINE__)
  do field_id = 1,this%num_fields
    call old_ptr_dofs_x_fe(field_id)%free()
  end do
  deallocate( old_ptr_dofs_x_fe, stat = error ); check( error == 0 )
  call old_lst_dofs_gids%free()
  
contains
  
  function get_field_fe_dofs()
    implicit none
    integer(ip), pointer     :: get_field_fe_dofs(:)
    integer(ip)              :: spos, epos
    spos = old_ptr_dofs_x_fe(field_id)%get(current_old_cell_lid)
    if ( field_id == this%get_num_fields() ) then
      epos = old_ptr_dofs_x_fe(1)%get(current_old_cell_lid+1)-1
    else
      epos = old_ptr_dofs_x_fe(field_id+1)%get(current_old_cell_lid)-1
    end if
    get_field_fe_dofs => old_lst_dofs_gids%get_pointer(spos,epos)
  end function get_field_fe_dofs
#else  
  call this%not_enabled_error()
#endif  
    
end subroutine serial_fe_space_refine_and_coarsen_fe_function_array

subroutine serial_fe_space_update_hanging_dof_values (this, fe_function )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  class(fe_function_t)    , intent(inout) :: fe_function
  
  type(serial_scalar_array_t), pointer :: fixed_dof_values
  real(rp)                   , pointer :: fixed_dof_values_entries(:)
  
  integer(ip) :: i_gid, spos, epos, pos, k_gid
  real(rp) :: weight, free_dof_value(1)
  
  fixed_dof_values         => fe_function%get_fixed_dof_values()
  fixed_dof_values_entries => fixed_dof_values%get_entries()
  fixed_dof_values_entries(this%num_dirichlet_dofs+1:this%num_fixed_dofs) = 0.0_rp
  
  do i_gid = 1, this%num_hanging_dofs
    spos = this%ptr_constraining_free_dofs%get(i_gid)
    epos = this%ptr_constraining_free_dofs%get(i_gid+1)-1
    do pos=spos, epos 
      k_gid = this%constraining_free_dofs%get(pos)
      weight = this%constraining_free_dofs_coefficients%get(pos)
         call fe_function%free_dof_values%extract_subvector ( iblock = 1, &
                                             size_indices = 1, &
                                             indices = [k_gid], &
                                             values = free_dof_value )
      fixed_dof_values_entries(i_gid+this%num_dirichlet_dofs) = &
         & fixed_dof_values_entries(i_gid+this%num_dirichlet_dofs) +  &
         & weight*free_dof_value(1)
    end do
    spos = this%ptr_constraining_dirichlet_dofs%get(i_gid)
    epos = this%ptr_constraining_dirichlet_dofs%get(i_gid+1)-1
    do pos=spos, epos 
      k_gid = this%constraining_dirichlet_dofs%get(pos)
      weight = this%constraining_dirichlet_dofs_coefficients%get(pos)
      fixed_dof_values_entries(i_gid+this%num_dirichlet_dofs) = &
         & fixed_dof_values_entries(i_gid+this%num_dirichlet_dofs) + &
         & weight*fixed_dof_values_entries(abs(k_gid))
    end do
  end do
end subroutine serial_fe_space_update_hanging_dof_values 

#ifndef ENABLE_P4EST
  subroutine serial_fe_space_not_enabled_error(this)
    class(serial_fe_space_t), intent(in) :: this
    write (stderr,*) 'Error: FEMPAR was not compiled with -DENABLE_P4EST.'
    write (stderr,*) "Error: You must activate this CPP macro in order to use P4EST"
    check(.false.)
  end subroutine serial_fe_space_not_enabled_error
#endif


