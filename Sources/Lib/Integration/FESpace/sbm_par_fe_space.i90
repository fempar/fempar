! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
subroutine par_fe_space_serial_create_with_parameter_list( this,          &
                                                           triangulation, &
                                                           parameters,    &
                                                           conditions, &
                                                           generate_global_dof_numbering )
  implicit none
  class(par_fe_space_t)                                , intent(inout)  :: this
  class(triangulation_t)                       , target, intent(in)     :: triangulation
  type(ParameterList_t)                                , intent(inout)  :: parameters
  class(strong_boundary_conditions_t), optional, target,  intent(inout) :: conditions
  logical                            , optional        , intent(in)     :: generate_global_dof_numbering
  assert(.false.)
end subroutine par_fe_space_serial_create_with_parameter_list

subroutine par_fe_space_serial_create_same_reference_fes_on_all_cells( this,          &
                                                                       triangulation, &
                                                                       reference_fes, &
                                                                       conditions,    &
                                                                       field_blocks,  &
                                                                       field_coupling, &
                                                                       generate_global_dof_numbering )
                                                                      
  implicit none
  class(par_fe_space_t)                       , intent(inout) :: this
  class(triangulation_t)    , target          , intent(in)    :: triangulation
  type(p_reference_fe_t)                      , intent(in)    :: reference_fes(:)
  class(conditions_t)       , target, optional, intent(in)    :: conditions
  integer(ip)                       , optional, intent(in)    :: field_blocks(:)
  logical                           , optional, intent(in)    :: field_coupling(:,:)
  logical                           , optional, intent(in)    :: generate_global_dof_numbering
  assert(.false.)
end subroutine par_fe_space_serial_create_same_reference_fes_on_all_cells

subroutine par_fe_space_serial_create_different_ref_fes_between_cells( this,                     &
                                                               triangulation,            &
                                                               reference_fes,            &
                                                               set_ids_to_reference_fes, &
                                                               conditions,               &
                                                               field_blocks,             &
                                                               field_coupling, &
                                                               generate_global_dof_numbering )
  implicit none
  class(par_fe_space_t)                       , intent(inout) :: this
  class(triangulation_t), target  , intent(in)    :: triangulation
  type(p_reference_fe_t)                      , intent(in)    :: reference_fes(:)
  integer(ip)                                 , intent(in)    :: set_ids_to_reference_fes(:,:)
  class(conditions_t)       , target, optional, intent(in)    :: conditions
  integer(ip)                       , optional, intent(in)    :: field_blocks(:)
  logical                           , optional, intent(in)    :: field_coupling(:,:)
  logical                           , optional, intent(in)   :: generate_global_dof_numbering
  check(.false.)
end subroutine par_fe_space_serial_create_different_ref_fes_between_cells

subroutine par_fe_space_create_with_parameter_list( this,               &
                                                    triangulation,      &
                                                    coarse_fe_handlers, &
                                                    parameters,         &
                                                    conditions,         &
                                                    generate_global_dof_numbering )
  implicit none
  class(par_fe_space_t)                                , intent(inout) :: this
  class(triangulation_t)                       , target, intent(in)    :: triangulation
  type(p_l1_coarse_fe_handler_t)                       , intent(in)    :: coarse_fe_handlers(:)
  type(ParameterList_t)                                , intent(inout) :: parameters
  class(strong_boundary_conditions_t), optional, target, intent(inout) :: conditions
  logical                            , optional        , intent(in)    :: generate_global_dof_numbering
  type(environment_t), pointer :: environment 
  integer(ip)                  :: field_id
  integer(ip), allocatable :: field_blocks(:)
  
  call this%free()
  
  ! This is a little bit DIRTY. Many type(par_fe_space_t) TBPs require that 
  ! coarse-grid tasks also associate this (superclass') member variable to a 
  ! target
  this%triangulation     => triangulation
  this%environment       => triangulation%get_environment()
  environment    => this%get_environment()
  if ( environment%am_i_l1_task() ) then
     call this%serial_fe_space_t%create( triangulation, &
                                         parameters, &
                                         conditions, &
                                         generate_global_dof_numbering = .false. )
  else
     ! This is a little bit DIRTY. mlbddc_t%create() requires that coarse-grid
     ! tasks also know how many fields there are
     call this%get_fe_space_num_fields_from_pl(parameters,this%num_fields)
     
     ! This is a little bit DIRTY. fe_function%create(fe_space)
     ! requires that num_fixed_dofs is initialize
     this%num_fixed_dofs = 0
     
     ! This is a little bit DIRTY, force initialization of variable.
     this%num_total_free_dofs  = 0
     this%num_total_free_ghost_dofs = 0
     
     ! This is a little bit DIRTY. Other data type relying on par_fe_space_t
     ! require that this%block_layout is created on all processes
     call this%get_fe_space_field_blocks_from_pl(parameters,field_blocks)
     call this%block_layout%create(this%get_num_fields(), field_blocks)
     call memfree(field_blocks,__FILE__,__LINE__)
  end if
  call this%allocate_and_fill_coarse_fe_handlers(coarse_fe_handlers) 
  if ( present(generate_global_dof_numbering) ) then
    if ( generate_global_dof_numbering ) then
      call this%generate_global_dof_numbering()
    end if 
  else
    call this%generate_global_dof_numbering()
  end if
  
  
end subroutine par_fe_space_create_with_parameter_list


subroutine par_fe_space_create_same_reference_fes_on_all_cells( this,               &
                                                                triangulation,      &
                                                                reference_fes,      &
                                                                coarse_fe_handlers, &
                                                                conditions,         &
                                                                field_blocks,       &
                                                                field_coupling, &
                                                                generate_global_dof_numbering ) 
  implicit none
  class(par_fe_space_t)                     , intent(inout)  :: this
  class(triangulation_t), target, intent(in)     :: triangulation
  type(p_reference_fe_t)                    , intent(in)     :: reference_fes(:)
  type(p_l1_coarse_fe_handler_t)            , intent(in)     :: coarse_fe_handlers(:)
  class(conditions_t)             , optional, intent(in)     :: conditions
  integer(ip)                     , optional , intent(in)    :: field_blocks(:)
  logical                         , optional , intent(in)    :: field_coupling(:,:)
  logical                         , optional , intent(in)   :: generate_global_dof_numbering
  type(environment_t), pointer :: environment 
  integer(ip)                  :: field_id

  call this%free()
  
  ! This is a little bit DIRTY. Many type(par_fe_space_t) TBPs require that 
  ! coarse-grid tasks also associate this (superclass') member variable to a 
  ! target
  this%triangulation     => triangulation
  this%environment       => triangulation%get_environment()
  environment    => this%get_environment()
  if ( environment%am_i_l1_task() ) then
     call this%serial_fe_space_t%create( triangulation, &
                                         reference_fes, &
                                         conditions, &
                                         field_blocks, &
                                         field_coupling, &
                                         .false. )
  else
     ! This is a little bit DIRTY. mlbddc_t%create() requires that coarse-grid
     ! tasks also know how many fields there are
     this%num_fields = size(reference_fes)
     
     ! This is a little bit DIRTY. fe_function%create(fe_space)
     ! requires that num_fixed_dofs is initialize
     this%num_fixed_dofs = 0
     
     ! This is a little bit DIRTY, force initialization of variable.
     this%num_total_free_dofs  = 0
     this%num_total_free_ghost_dofs = 0
     
     ! This is a little bit DIRTY. Other data type relying on par_fe_space_t
     ! require that this%block_layout is created on all processes
     call this%block_layout%create(this%get_num_fields(), field_blocks, field_coupling)
  end if
  call this%allocate_and_fill_coarse_fe_handlers(coarse_fe_handlers) 
  if ( present(generate_global_dof_numbering) ) then
    if ( generate_global_dof_numbering ) then
      call this%generate_global_dof_numbering()
    end if 
  else
    call this%generate_global_dof_numbering()
  end if
end subroutine par_fe_space_create_same_reference_fes_on_all_cells

subroutine par_fe_space_create_different_ref_fes_between_cells( this,                     &
                                                                triangulation,            &
                                                                reference_fes,            &
                                                                set_ids_to_reference_fes, &
                                                                coarse_fe_handlers,       &
                                                                conditions,               &
                                                                field_blocks,             &
                                                                field_coupling, &
                                                                generate_global_dof_numbering )  
  implicit none
  class(par_fe_space_t)                     , intent(inout)  :: this
  class(triangulation_t)            , target, intent(in)     :: triangulation
  type(p_reference_fe_t)                    , intent(in)     :: reference_fes(:)
  integer(ip)                               , intent(in)     :: set_ids_to_reference_fes(:,:)
  type(p_l1_coarse_fe_handler_t)            , intent(in)     :: coarse_fe_handlers(:)
  class(conditions_t)             , optional, intent(in)     :: conditions
  integer(ip)                       , optional, intent(in)   :: field_blocks(:)
  logical                           , optional, intent(in)   :: field_coupling(:,:)
  logical                           , optional , intent(in)   :: generate_global_dof_numbering

  type(environment_t), pointer :: environment
  integer(ip)                  :: field_id

  call this%free()

  ! This is a little bit DIRTY. Many type(par_fe_space_t) TBPs require that
  ! coarse-grid tasks also associate this (superclass') member variable to a
  ! target
  this%triangulation     => triangulation
  this%environment       => triangulation%get_environment()
  environment    => this%get_environment()
  if ( environment%am_i_l1_task() ) then
     call this%serial_fe_space_t%create( triangulation,            &
                                         reference_fes,            &
                                         set_ids_to_reference_fes, &
                                         conditions,               &
                                         field_blocks,             &
                                         field_coupling,           &
                                         .false. )
  else
     ! This is a little bit DIRTY. mlbddc_t%create() requires that coarse-grid
     ! tasks also know how many fields there are
     this%num_fields = size(set_ids_to_reference_fes,1)

     ! This is a little bit DIRTY. fe_function%create(fe_space)
     ! requires that num_fixed_dofs is initialize
     this%num_fixed_dofs = 0
     
     ! This is a little bit DIRTY, force initialization of variable.
     this%num_total_free_dofs  = 0
     this%num_total_free_ghost_dofs = 0
     
     ! This is a little bit DIRTY. Other data type relying on par_fe_space_t
     ! require that this%block_layout is created on all processes
     call this%block_layout%create(this%get_num_fields(), field_blocks, field_coupling)
  end if
  call this%allocate_and_fill_coarse_fe_handlers(coarse_fe_handlers)
  if ( present(generate_global_dof_numbering) ) then
    if ( generate_global_dof_numbering ) then
      call this%generate_global_dof_numbering()
    end if 
  else
    call this%generate_global_dof_numbering()
  end if 
end subroutine par_fe_space_create_different_ref_fes_between_cells

subroutine par_fe_space_free( this )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip) :: i, istat
  type(environment_t), pointer :: environment
  
  if ( associated (this%triangulation) ) then
     environment => this%get_environment()
     if ( environment%am_i_l1_task() ) then
        call this%max_part_id_vefs%free()
        call this%my_part_id_vefs%free()
        call this%rcv_my_part_id_vefs%free()
        call this%ptr_dofs_field%free()
        call this%lst_dofs_ggids%free()
        call this%ptr_ghosts_per_local_cell%free()
        call this%lst_ghosts_per_local_cell%free()
        call this%num_cells_to_send_x_local_cell%free()
        call this%snd_ptrs_complete_itfc_couplings%free()
        call this%snd_leids_complete_itfc_couplings%free()
        call this%rcv_ptrs_complete_itfc_couplings%free()
        call this%ptr_ghosts_per_ghost_cell%free()
        call this%lst_ghosts_per_ghost_cell%free()
        call this%rcv_my_part_id_vefs_complete_itfc_couplings%free()
        call this%free_lst_parts_around_itfc_dofs()
        call this%num_parts_dofs_cell_wise%free()
        call this%snd_ptrs_lst_parts_cell_wise%free()
        call this%rcv_ptrs_lst_parts_cell_wise%free()
        call this%lst_parts_pack_idx_cell_wise%free()
        call this%ptrs_to_rcv_lst_parts_dofs_cell_wise%free()
        call this%lst_parts_dofs_cell_wise%free()
        call this%rcv_lst_parts_dofs_cell_wise%free()
        call this%old_fe_function_nodal_values%free()
        call this%new_fe_function_nodal_values%free()
        call this%free_blocks_dof_import()
        call this%free_coarse_fe_space_l1_data()
        call this%serial_fe_space_t%free()
     else
        ! This is a little bit DIRTY. mlbddc%create() requires that the number of
        ! fields is also set on coarse-grid tasks
        this%num_fields = 0
        
        ! This is a little bit DIRTY, force initialization of variable.
        this%num_total_free_dofs  = 0
        this%num_total_free_ghost_dofs = 0
        
        ! This is a little bit DIRTY. fe_function%create(fe_space)
        ! requires that num_fixed_dofs is initialize
        this%num_fixed_dofs = 0
        
        ! This is a little bit DIRTY. this%block_layout is required by some
        ! other data types to be created on all processes
        call this%block_layout%free()
        
        call this%free_coarse_fe_space_lgt1_data()
        
        if ( allocated( this%blocks_dof_import ) ) then
          deallocate(this%blocks_dof_import, stat=istat)
          check (istat==0)
        end if
     end if
     nullify(this%triangulation)
     nullify(this%environment)
     nullify(this%parameter_list)
     call this%free_coarse_fe_handlers()
     call this%set_coarse_fe_space_is_set_up(.false.) 
  end if
  
end subroutine par_fe_space_free

subroutine par_fe_space_free_coarse_fe_space_l1_data(this)
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  type(environment_t), pointer :: environment
  if ( associated (this%triangulation) ) then
     environment => this%get_environment()
     if ( environment%am_i_l1_task() ) then
        call this%free_faces_object()
        call this%free_coarse_dofs()
        nullify(this%coarse_fe_space)
     end if
  end if
end subroutine par_fe_space_free_coarse_fe_space_l1_data

recursive subroutine par_fe_space_free_coarse_fe_space_lgt1_data(this)
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  type(environment_t), pointer :: environment
  integer(ip) :: istat
  if ( associated (this%triangulation) ) then
     environment => this%get_environment()
     if ( environment%am_i_lgt1_task() ) then
        if ( associated(this%coarse_fe_space) ) then
          call this%coarse_fe_space%free()
          deallocate (this%coarse_fe_space, stat=istat)
          check (istat==0)
        end if
        nullify(this%coarse_fe_space)
     end if
  end if
end subroutine par_fe_space_free_coarse_fe_space_lgt1_data

subroutine par_fe_space_compute_faces_object(this)
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  type(fe_object_iterator_t) :: fe_object
  type(fe_vef_iterator_t)    :: fe_vef
  integer(ip)                :: ivef_within_fe_object
  type(list_iterator_t)      :: faces_object_iterator
  integer(ip)                :: facet_gid
  integer(ip)                :: vef_gid
  integer(ip), allocatable   :: proper_fe_vef_facet_gid(:)
  integer(ip), allocatable   :: improper_fe_vef_facet_gid(:)

  integer(ip) :: i
  
  call memalloc ( this%triangulation%get_num_proper_vefs(), &
                  proper_fe_vef_facet_gid, __FILE__, __LINE__ )
  
  call memalloc ( this%triangulation%get_num_improper_vefs(), &
                  improper_fe_vef_facet_gid, __FILE__, __LINE__ )
  
  proper_fe_vef_facet_gid = -1
  do i=1, this%facet_gids%size()
    vef_gid = this%facet_gids%get(i)
    if ( vef_gid > 0 ) then
      proper_fe_vef_facet_gid(vef_gid) = i
    else
      improper_fe_vef_facet_gid(abs(vef_gid)) = i
    end if
  end do
  
  call this%faces_object%create(n=this%triangulation%get_num_objects())
  
  call this%create_fe_object_iterator(fe_object)
  call this%create_fe_vef_iterator(fe_vef)
  
  do while ( .not. fe_object%has_finished() )
    do ivef_within_fe_object = 1,fe_object%get_num_vefs()
      call fe_object%get_vef(ivef_within_fe_object,fe_vef)
      if ( fe_vef%is_proper()) then
         if ( proper_fe_vef_facet_gid(fe_vef%get_gid()) /= -1 ) then 
            call this%faces_object%sum_to_pointer_index(fe_object%get_gid(), 1)
         end if
      else
         if ( improper_fe_vef_facet_gid(abs(fe_vef%get_gid())) /= -1 ) then 
            call this%faces_object%sum_to_pointer_index(fe_object%get_gid(), 1)
         end if
      end if 
    end do
    call fe_object%next()
  end do
  
  call this%faces_object%calculate_header()
  call this%faces_object%allocate_list_from_pointer()
  
  call fe_object%first()
  do while ( .not. fe_object%has_finished() )
    faces_object_iterator = fe_object%create_faces_object_iterator()
    do ivef_within_fe_object = 1,fe_object%get_num_vefs()
      call fe_object%get_vef(ivef_within_fe_object,fe_vef)
      if ( fe_vef%is_proper() ) then
        facet_gid = proper_fe_vef_facet_gid(fe_vef%get_gid())
      else
        facet_gid = improper_fe_vef_facet_gid(abs(fe_vef%get_gid())) 
      end if 
      if ( facet_gid /= -1  ) then
        call faces_object_iterator%set_current(facet_gid)
        call faces_object_iterator%next() 
      end if
    end do
    call fe_object%next()
  end do
  
  call faces_object_iterator%free()
  call this%free_fe_vef_iterator(fe_vef)
  call this%free_fe_object_iterator(fe_object)
  call memfree ( proper_fe_vef_facet_gid, __FILE__, __LINE__ )
  call memfree ( improper_fe_vef_facet_gid, __FILE__, __LINE__ )
end subroutine par_fe_space_compute_faces_object

subroutine par_fe_space_free_faces_object(this)
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  call this%faces_object%free()
end subroutine par_fe_space_free_faces_object

subroutine par_fe_space_print ( this )
  class(par_fe_space_t), intent(in) :: this 
  integer(ip) :: i,j
  type(environment_t), pointer :: environment
  environment => this%get_environment()
  if ( environment%am_i_l1_task() ) then
     call this%serial_fe_space_t%print()
     !do i = 1, this%num_blocks
     !  call this%blocks_dof_import(i)%print(6)
     !end do
  end if
end subroutine par_fe_space_print

subroutine par_fe_space_allocate_and_fill_coarse_fe_handlers ( this, coarse_fe_handlers )
  implicit none
  class(par_fe_space_t)         , intent(inout) :: this
  type(p_l1_coarse_fe_handler_t),  intent(in)   :: coarse_fe_handlers(:)
  integer(ip) :: i, istat
  
  call this%free_coarse_fe_handlers()
  
  assert(size(coarse_fe_handlers) == this%num_fields)
  allocate( this%coarse_fe_handlers(this%num_fields), stat=istat )

  check ( istat == 0 )
  do i  = 1, this%num_fields
     this%coarse_fe_handlers(i) = coarse_fe_handlers(i)
  end do
end subroutine par_fe_space_allocate_and_fill_coarse_fe_handlers

subroutine par_fe_space_free_coarse_fe_handlers ( this )
  implicit none
  class(par_fe_space_t)          , intent(inout) :: this
  integer(ip) :: istat
  if (allocated(this%coarse_fe_handlers)) then
     deallocate( this%coarse_fe_handlers, stat=istat )
     check ( istat == 0 )
  end if
end subroutine par_fe_space_free_coarse_fe_handlers

subroutine par_fe_space_generate_global_dof_numbering( this )
  implicit none
  class(par_fe_space_t)       , intent(inout)  :: this 

  type(environment_t), pointer :: environment 
  integer(ip)                  :: istat
  
  environment => this%get_environment()
  if ( environment%am_i_l1_task() ) then
     call this%serial_fe_space_t%generate_global_dof_numbering()
     call this%compute_blocks_dof_import()
     ! Step required by the MLBDDC preconditioner
     call this%renum_dofs_first_interior_then_interface()
  else
     ! This is a little bit DIRTY. par_fe_space_t%create_assembler()
     ! requires that this%blocks_dof_import is allocated 
     if ( .not. allocated ( this%blocks_dof_import ) ) then
       allocate ( this%blocks_dof_import( this%block_layout%get_num_blocks()), stat=istat ) 
       check (istat==0)
     end if
  end if
end subroutine par_fe_space_generate_global_dof_numbering

subroutine par_fe_space_renum_dofs_first_interior_then_interface( this )
  implicit none
  class(par_fe_space_t), intent(inout) :: this 
  integer(ip) :: iblock
  integer(ip), allocatable :: perm_old2new_block(:)
  type(environment_t), pointer :: environment
  integer(ip) :: i, constraining_free_dof_gid
  environment => this%get_environment()
  if ( environment%am_i_l1_task() ) then
    do iblock=1, this%block_layout%get_num_blocks()
      call memalloc (this%block_layout%get_block_num_dofs(iblock), perm_old2new_block, __FILE__, __LINE__)
      call this%blocks_dof_import(iblock)%fill_first_I_then_G_renumbering(perm_old2new_block)
      call this%renum_dofs_block(iblock, perm_old2new_block)
      call this%blocks_dof_import(iblock)%renum_dofs(perm_old2new_block)

      do i=1, this%constraining_free_dofs%size()
       constraining_free_dof_gid = this%constraining_free_dofs%get(i)
       if ( this%is_free_dof(constraining_free_dof_gid) ) then
         call this%constraining_free_dofs%set(i, perm_old2new_block(constraining_free_dof_gid))
       end if
      end do 

      call memfree (perm_old2new_block, __FILE__, __LINE__)
    end do
  end if
end subroutine par_fe_space_renum_dofs_first_interior_then_interface

 subroutine par_fe_space_compute_num_global_dofs_and_their_ggids ( this, num_global_dofs, dofs_gids )
    implicit none
    class(par_fe_space_t)    , intent(in)    :: this
    integer(igp)             , intent(inout) :: num_global_dofs
    integer(igp), allocatable, intent(inout) :: dofs_gids(:) 

    integer(ip)                  :: num_rcv
    integer(ip), allocatable     :: list_rcv(:)    
    integer(ip), allocatable     :: rcv_ptrs(:)
    integer(ip), allocatable     :: unpack_idx(:)
    
    integer(ip)                  :: num_snd
    integer(ip), allocatable     :: list_snd(:)    
    integer(ip), allocatable     :: snd_ptrs(:)
    integer(ip), allocatable     :: pack_idx(:)
   
    integer(ip)                  :: num_local_dofs_with_gid
    integer(ip), allocatable     :: local_dofs_with_gid(:)
    integer(igp), allocatable    :: per_rank_dofs_with_gid(:)
    integer(igp)                 :: start_dof_gid
    integer(ip)                  :: part_id, my_part_id, num_parts
    integer(ip)                  :: i, idof, dof_gid, istat, ivef, min_part_id, ielem
    class(reference_fe_t), pointer :: reference_fe
    
    integer(ip)                  :: dummy_integer_array(1)
    integer(igp)                 :: dummy_integer_array_igp(1)
    type(environment_t), pointer :: environment
    class(fe_cell_iterator_t), allocatable :: fe 
    type(fe_vef_iterator_t) :: vef
    integer(ip) :: field_id
    type(i1p_t), allocatable :: fe_dofs(:)
    type(list_iterator_t) :: own_dofs_on_vef_iterator
    integer(igp), allocatable :: tmp_gids(:)

    environment => this%get_environment()

    assert ( environment%am_i_l1_task() )
    assert ( this%get_num_fields() == 1 )
    
    my_part_id   = environment%get_l1_rank()  + 1 
    num_parts = environment%get_l1_size()
    
    ! 1. Count/list how many local DoFs I am responsible to assign a global ID
    call memalloc ( this%blocks_dof_import(1)%get_num_dofs(), local_dofs_with_gid, __FILE__, __LINE__ )
    
    num_local_dofs_with_gid = 0
    do dof_gid=1, this%blocks_dof_import(1)%get_num_interior_dofs()
      num_local_dofs_with_gid = num_local_dofs_with_gid + 1
      local_dofs_with_gid(num_local_dofs_with_gid) = dof_gid
    end do
    
    allocate ( fe_dofs(this%num_fields), stat=istat ) 
    check (istat==0)
    
    field_id = 1
  
    ! Traverse vefs on the interface
    call this%create_itfc_fe_vef_iterator(vef)
    call this%create_fe_cell_iterator(fe) 
    do while(.not. vef%has_finished())
       min_part_id = my_part_id
       do ielem=1, vef%get_num_cells_around()
          call vef%get_cell_around(ielem,fe)
          part_id = fe%get_my_part()
          min_part_id = min(part_id, min_part_id)
       end do
    
       if (.not. min_part_id == my_part_id) then
         call vef%next()
         cycle
       end if
    
       call vef%get_cell_around(1,fe)
       ivef = fe%get_vef_lid_from_gid(vef%get_gid())
       call fe%get_fe_dofs( fe_dofs )
       reference_fe => fe%get_reference_fe(field_id)
       
       own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
       do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
           idof    =  own_dofs_on_vef_iterator%get_current()
           dof_gid = fe_dofs(field_id)%p(idof)
           if ( .not. this%is_free_dof(dof_gid) ) then
             call own_dofs_on_vef_iterator%next()
             cycle
           end if
           num_local_dofs_with_gid = num_local_dofs_with_gid + 1
           local_dofs_with_gid(num_local_dofs_with_gid) = dof_gid
           call own_dofs_on_vef_iterator%next()
       end do
       call vef%next()   
    end do
    call this%free_fe_cell_iterator(fe)
    call this%free_fe_vef_iterator(vef)
    deallocate(fe_dofs, stat=istat ) 
    check (istat==0)
    
    ! 2. Gather + Scatter
    if ( environment%am_i_l1_root() ) then
      call memalloc( num_parts+1, per_rank_dofs_with_gid, __FILE__,__LINE__ )
      call environment%l1_gather (input_data=int(num_local_dofs_with_gid,igp), &
                                      output_data=per_rank_dofs_with_gid(2:) ) 
       ! Transform length to header
       per_rank_dofs_with_gid(1)=1 
       do i=1, num_parts
          per_rank_dofs_with_gid(i+1) = per_rank_dofs_with_gid(i) + per_rank_dofs_with_gid(i+1) 
       end do
       num_global_dofs = per_rank_dofs_with_gid(num_parts+1)-1 
    else
      call environment%l1_gather (input_data=int(num_local_dofs_with_gid,igp), &
                                      output_data=dummy_integer_array_igp ) 
    end if
    
    call environment%l1_bcast (data = num_global_dofs )
    
    if ( environment%am_i_l1_root() ) then
      call environment%l1_scatter (input_data=per_rank_dofs_with_gid, &
                                       output_data=start_dof_gid) 
      call memfree( per_rank_dofs_with_gid, __FILE__,__LINE__ )
    else
      call environment%l1_scatter (input_data=dummy_integer_array_igp, &
                                       output_data=start_dof_gid) 
    end if
    
    
    call memalloc (this%blocks_dof_import(1)%get_num_dofs(), dofs_gids)
    call memalloc (this%blocks_dof_import(1)%get_num_dofs(), tmp_gids)
    dofs_gids = -1
    do i=1, num_local_dofs_with_gid
      dofs_gids ( local_dofs_with_gid(i) ) = start_dof_gid
      start_dof_gid = start_dof_gid + 1 
    end do
    
    tmp_gids = dofs_gids
    call environment%l1_neighbours_exchange ( this%blocks_dof_import(1)%get_num_rcv(), &
                                                  this%blocks_dof_import(1)%get_list_rcv(),&
                                                  this%blocks_dof_import(1)%get_rcv_ptrs(),&
                                                  this%blocks_dof_import(1)%get_unpack_idx(),&
                                                  this%blocks_dof_import(1)%get_num_snd(),&
                                                  this%blocks_dof_import(1)%get_list_snd(),&
                                                  this%blocks_dof_import(1)%get_snd_ptrs(),&
                                                  this%blocks_dof_import(1)%get_pack_idx(),&
                                                  tmp_gids, &
                                                  tmp_gids, &
                                                  mask = -1_igp)
    
    
    do i=1, size(dofs_gids)
      if ( tmp_gids(i) /= -1 ) dofs_gids(i) = tmp_gids(i)
    end do
    

    tmp_gids = dofs_gids
    call environment%l1_neighbours_exchange ( this%blocks_dof_import(1)%get_num_snd(), &
                                                  this%blocks_dof_import(1)%get_list_snd(),&
                                                  this%blocks_dof_import(1)%get_snd_ptrs(),&
                                                  this%blocks_dof_import(1)%get_pack_idx(),&
                                                  this%blocks_dof_import(1)%get_num_rcv(),&
                                                  this%blocks_dof_import(1)%get_list_rcv(),&
                                                  this%blocks_dof_import(1)%get_rcv_ptrs(),&
                                                  this%blocks_dof_import(1)%get_unpack_idx(),&
                                                  tmp_gids,&
                                                  tmp_gids,&
                                                  mask = -1_igp)
    
    do i=1, size(dofs_gids)
      if ( tmp_gids(i) /= -1 ) dofs_gids(i) = tmp_gids(i)
    end do    
    
    call memfree ( local_dofs_with_gid, __FILE__, __LINE__ )
    call memfree ( tmp_gids, __FILE__, __LINE__ )
  end subroutine par_fe_space_compute_num_global_dofs_and_their_ggids

  
 subroutine par_fe_space_set_up_cell_integration ( this, interpolation_duties, cell_map_duties )
  implicit none
  class(par_fe_space_t), target, intent(inout) :: this
  type(interpolation_duties_t), optional, intent(in)    :: interpolation_duties(:)
  type(cell_map_duties_t)     , optional, intent(in)    :: cell_map_duties
  type(environment_t), pointer :: environment   
  environment => this%get_environment()
  if ( environment%am_i_l1_task() ) then
    call this%serial_fe_space_t%set_up_cell_integration(interpolation_duties, cell_map_duties )
  end if 
 end subroutine  par_fe_space_set_up_cell_integration
 
 subroutine par_fe_space_set_up_facet_integration ( this )
  implicit none
  class(par_fe_space_t), target, intent(inout) :: this
  type(environment_t), pointer :: environment 
  environment => this%get_environment()
  if ( environment%am_i_l1_task() ) then
    call this%serial_fe_space_t%set_up_facet_integration()
  end if 
 end subroutine  par_fe_space_set_up_facet_integration 
  
subroutine par_fe_space_compute_blocks_dof_import ( this )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)                          :: iblock, istat
  class(triangulation_t), pointer :: triangulation
  
  call this%free_blocks_dof_import()
  allocate ( this%blocks_dof_import(this%block_layout%get_num_blocks()), stat=istat ) 
  check (istat==0)
  
  triangulation => this%get_triangulation()
  do iblock=1, this%block_layout%get_num_blocks()
   if (triangulation%is_conforming() ) then
     call this%compute_dof_import(iblock)
   else
     !call this%compute_dof_import_non_conforming_mesh(iblock)
     call this%compute_dof_import_non_conforming_mesh_revisited(iblock)
   end if
  end do
end subroutine par_fe_space_compute_blocks_dof_import

subroutine par_fe_space_compute_dof_import ( this, iblock )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: iblock

  ! Local raw data
  integer(igp), allocatable    :: raw_interface_data(:,:)
  integer(ip) , allocatable    :: dofs_gid(:)
  integer(ip)                  :: total_ubound_num_itfc_couplings
  integer(ip)                  :: total_num_itfc_couplings
  integer(ip), allocatable     :: ubound_num_itfc_couplings(:)
  integer(ip)                  :: num_fe_spaces_in_iblock
  integer(ip)                  :: i, field_id
  type(environment_t), pointer :: environment
  
  assert ( iblock >= 1 .and. iblock <= this%block_layout%get_num_blocks() )

  num_fe_spaces_in_iblock = 0
  do field_id = 1, this%num_fields
     if ( this%block_layout%get_block_id(field_id) == iblock ) then
        num_fe_spaces_in_iblock = num_fe_spaces_in_iblock + 1
     end if
  end do

  call memalloc ( num_fe_spaces_in_iblock, ubound_num_itfc_couplings, __FILE__, __LINE__ )
  total_ubound_num_itfc_couplings = 0 
  ubound_num_itfc_couplings = 0
  i = 1
  do field_id = 1, this%num_fields
     if ( this%block_layout%get_block_id(field_id) == iblock ) then
        if ( this%fe_space_type_x_field(field_id) == fe_space_type_cg ) then
           ubound_num_itfc_couplings (i) = ubound_num_itfc_couplings (i) + &
                                           this%compute_ubound_num_itfc_couplings_by_continuity(field_id)
        else if ( this%fe_space_type_x_field(field_id) == fe_space_type_dg ) then
           ubound_num_itfc_couplings (i) = ubound_num_itfc_couplings (i) + &
                this%compute_ubound_num_itfc_couplings_by_facet_integ(field_id)
        end if
        total_ubound_num_itfc_couplings = total_ubound_num_itfc_couplings + ubound_num_itfc_couplings (i)
        i=i+1                                  
     end if
  end do

  call memalloc ( num_rows_raw_interface_data, &
                  total_ubound_num_itfc_couplings, &
                  raw_interface_data, __FILE__, __LINE__ )

  call memalloc ( total_ubound_num_itfc_couplings, dofs_gid, __FILE__, __LINE__)

  total_num_itfc_couplings = 0
  i = 1
  do field_id = 1, this%num_fields
     if ( this%block_layout%get_block_id(field_id) == iblock ) then
        if ( this%fe_space_type_x_field(field_id) == fe_space_type_cg ) then
           total_num_itfc_couplings = &
                this%compute_raw_interface_data_by_continuity(field_id, &
                                                              total_num_itfc_couplings, &
                                                              ubound_num_itfc_couplings(i),&
                                                              dofs_gid,&
                                                              raw_interface_data )
        else if ( this%fe_space_type_x_field(field_id) == fe_space_type_dg ) then
           total_num_itfc_couplings = &
                this%compute_raw_interface_data_by_facet_integ(field_id, &
                                                              total_num_itfc_couplings, &
                                                              ubound_num_itfc_couplings(i),&
                                                              dofs_gid,&
                                                              raw_interface_data )      
        end if

        i=i+1                                  
     end if
  end do

  environment => this%get_environment()
  call this%blocks_dof_import(iblock)%create(environment%get_l1_rank()+1, &
                                             environment%get_l1_size(), &
                                             this%block_layout%get_block_num_dofs(iblock), &
                                             total_num_itfc_couplings, &
                                             dofs_gid, &
                                             raw_interface_data )

  call memfree ( ubound_num_itfc_couplings, __FILE__, __LINE__ )                
  call memfree ( raw_interface_data, __FILE__, __LINE__ )
  call memfree ( dofs_gid, __FILE__, __LINE__ )
end subroutine par_fe_space_compute_dof_import


subroutine par_fe_space_compute_dof_import_non_conforming_mesh ( this, iblock )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: iblock

  ! Local raw data
  integer(igp), allocatable    :: raw_interface_data(:,:)
  integer(ip) , allocatable    :: dofs_gid(:)
  integer(ip)                  :: total_ubound_num_itfc_couplings
  integer(ip)                  :: total_num_itfc_couplings
  integer(ip), allocatable     :: ubound_num_itfc_couplings(:)
  integer(ip)                  :: num_fe_spaces_in_iblock
  integer(ip)                  :: i, field_id
  type(environment_t), pointer :: environment
  
  assert ( iblock >= 1 .and. iblock <= this%block_layout%get_num_blocks() )

  num_fe_spaces_in_iblock = 0
  do field_id = 1, this%num_fields
     if ( this%block_layout%get_block_id(field_id) == iblock ) then
        num_fe_spaces_in_iblock = num_fe_spaces_in_iblock + 1
     end if
  end do

  call memalloc ( num_fe_spaces_in_iblock, ubound_num_itfc_couplings, __FILE__, __LINE__ )
  total_ubound_num_itfc_couplings = 0 
  ubound_num_itfc_couplings = 0
  i = 1
  do field_id = 1, this%num_fields
     if ( this%block_layout%get_block_id(field_id) == iblock ) then
        if ( this%fe_space_type_x_field(field_id) == fe_space_type_cg ) then
           call this%compute_max_part_id_my_part_id_and_dofs_ggids_field(field_id)
           call this%compute_exchange_control_data_to_complete_itfc_couplings(field_id)
           ubound_num_itfc_couplings (i) = ubound_num_itfc_couplings (i) + &
                                           this%compute_ubound_num_itfc_couplings_by_continuity_nc_mesh(field_id)
        else if ( this%fe_space_type_x_field(field_id) == fe_space_type_dg ) then
           ubound_num_itfc_couplings (i) = ubound_num_itfc_couplings (i) + &
                this%compute_ubound_num_itfc_couplings_by_facet_integ(field_id)
        end if
        total_ubound_num_itfc_couplings = total_ubound_num_itfc_couplings + ubound_num_itfc_couplings (i)
        i=i+1                                  
     end if
  end do

  call memalloc ( num_rows_raw_interface_data, &
                  total_ubound_num_itfc_couplings, &
                  raw_interface_data, __FILE__, __LINE__ )

  call memalloc ( total_ubound_num_itfc_couplings, dofs_gid, __FILE__, __LINE__)

  total_num_itfc_couplings = 0
  i = 1
  do field_id = 1, this%num_fields
     if ( this%block_layout%get_block_id(field_id) == iblock ) then
        if ( this%fe_space_type_x_field(field_id) == fe_space_type_cg ) then
           total_num_itfc_couplings = &
                this%compute_raw_interface_data_by_continuity_non_conforming_mesh(field_id, &
                                                              total_num_itfc_couplings, &
                                                              ubound_num_itfc_couplings(i),&
                                                              dofs_gid,&
                                                              raw_interface_data )
        else if ( this%fe_space_type_x_field(field_id) == fe_space_type_dg ) then
           total_num_itfc_couplings = &
                this%compute_raw_interface_data_by_facet_integ(field_id, &
                                                              total_num_itfc_couplings, &
                                                              ubound_num_itfc_couplings(i),&
                                                              dofs_gid,&
                                                              raw_interface_data )      
        end if

        i=i+1                                  
     end if
  end do

  environment => this%get_environment()
  call this%blocks_dof_import(iblock)%create(environment%get_l1_rank()+1, &
                                             environment%get_l1_size(), &
                                             this%block_layout%get_block_num_dofs(iblock), &
                                             total_num_itfc_couplings, &
                                             dofs_gid, &
                                             raw_interface_data )

  call memfree ( ubound_num_itfc_couplings, __FILE__, __LINE__ )                
  call memfree ( raw_interface_data, __FILE__, __LINE__ )
  call memfree ( dofs_gid, __FILE__, __LINE__ )
end subroutine par_fe_space_compute_dof_import_non_conforming_mesh

subroutine pfs_compute_dof_import_non_conforming_mesh_revisited ( this, iblock )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: iblock

  ! Local raw data
  type(allocatable_array_igp2_t) :: raw_interface_data
  type(std_vector_integer_ip_t)  :: dofs_gid
  integer(ip)                    :: total_num_itfc_couplings
  integer(ip)                    :: i, field_id
  type(environment_t), pointer   :: environment
  integer(ip), pointer           :: p_dofs_gid(:)
  
  assert ( iblock >= 1 .and. iblock <= this%block_layout%get_num_blocks() )

  call raw_interface_data%create(num_rows_raw_interface_data, 0)
  call dofs_gid%resize(0)

  total_num_itfc_couplings = 0
  do field_id = 1, this%num_fields
     if ( this%block_layout%get_block_id(field_id) == iblock ) then
        if ( this%fe_space_type_x_field(field_id) == fe_space_type_cg ) then
           call this%compute_lst_parts_around_itfc_dofs(field_id)
           call this%compute_max_part_id_dofs_ggids_field(field_id)
           call this%fetch_num_parts_dofs_cell_wise(field_id)
           call this%compute_near_neigh_ctrl_data_lst_parts(field_id)
           call this%compute_ptrs_to_rcv_lst_parts_dofs_cell_wise(field_id)
           call this%fetch_lst_parts_dofs_cell_wise(field_id)
           total_num_itfc_couplings = &
                this%compute_raw_interface_data_by_continuity_nc_mesh_rev(field_id, &
                                                              total_num_itfc_couplings, &
                                                              dofs_gid,&
                                                              raw_interface_data )
        else if ( this%fe_space_type_x_field(field_id) == fe_space_type_dg ) then
           mcheck(.false., "compute_dof_import_non_conforming_mesh() NOT implemented for DG spaces")
        end if
     end if
  end do

  environment => this%get_environment()
  p_dofs_gid  => dofs_gid%get_pointer()
  call this%blocks_dof_import(iblock)%create(environment%get_l1_rank()+1, &
                                             environment%get_l1_size(), &
                                             this%block_layout%get_block_num_dofs(iblock), &
                                             total_num_itfc_couplings, &
                                             p_dofs_gid, &
                                             raw_interface_data%a(:,1:total_num_itfc_couplings) )
           
  call raw_interface_data%free()
  call dofs_gid%free()
end subroutine pfs_compute_dof_import_non_conforming_mesh_revisited


function pfs_compute_ubound_num_itfc_couplings_by_continuity( this, field_id )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: field_id
  integer(ip)                          :: pfs_compute_ubound_num_itfc_couplings_by_continuity

  integer(ip)  :: mypart_id, part_id, local_part_id
  integer(ip)  :: ivef, ielem

  integer(ip)                            :: result
  logical, allocatable                   :: touched_neighbours(:)

  type(environment_t)      , pointer :: environment
  class(triangulation_t), pointer :: triangulation
  type(cell_import_t)       , pointer :: cell_import
  class(reference_fe_t)        , pointer :: reference_fe
  type(fe_vef_iterator_t)      :: vef
  class(fe_cell_iterator_t), allocatable :: fe
  integer(ip)                  :: result_previous
  
  environment   => this%get_environment()
  triangulation => this%get_triangulation()
  cell_import       => triangulation%get_cell_import()
  assert ( environment%am_i_l1_task() )

  mypart_id = environment%get_l1_rank() + 1 

  call memalloc ( cell_import%get_num_neighbours(), &
                  touched_neighbours, &
                  __FILE__, __LINE__ )

  ! Traverse vefs on the interface
  call this%create_itfc_fe_vef_iterator(vef)
  call this%create_fe_cell_iterator(fe) 
  result = 0 
  do while(.not. vef%has_finished())
     touched_neighbours = .false.
     do ielem=1, vef%get_num_cells_around()
        call vef%get_cell_around(ielem,fe)
        part_id = fe%get_my_part()
        if ( part_id /= mypart_id ) then
           local_part_id = cell_import%get_local_neighbour_id(part_id)
           if (.not. touched_neighbours (local_part_id)) then
              ivef = fe%get_vef_lid_from_gid(vef%get_gid())
              reference_fe => fe%get_reference_fe(field_id)
              result_previous = result
              result = result + reference_fe%get_num_own_dofs_n_face(ivef)
              if (result>result_previous) touched_neighbours (local_part_id) = .true.
           end if
        end if
     end do
     call vef%next()
  end do
  pfs_compute_ubound_num_itfc_couplings_by_continuity = result
  call this%free_fe_cell_iterator(fe) 
  call this%free_fe_vef_iterator(vef)
  call memfree ( touched_neighbours, __FILE__, __LINE__ )
end function pfs_compute_ubound_num_itfc_couplings_by_continuity

function pfs_compute_ubound_num_itfc_couplings_by_continuity_nc_mesh( this, field_id )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: field_id
  integer(ip)                          :: pfs_compute_ubound_num_itfc_couplings_by_continuity_nc_mesh

  integer(ip)  :: mypart_id, part_id, local_part_id
  integer(ip)  :: ivef, ielem

  integer(ip)                            :: result
  logical, allocatable                   :: touched_neighbours(:)

  type(environment_t)      , pointer :: environment
  class(triangulation_t), pointer :: triangulation
  type(cell_import_t)       , pointer :: cell_import
  class(reference_fe_t)        , pointer :: reference_fe
  type(fe_vef_iterator_t)      :: vef
  class(fe_cell_iterator_t), allocatable :: fe, coarser_fe
  integer(ip)                  :: result_previous
  integer(ip), pointer :: p_ptr_ghosts_per_local_cell(:)
  integer(ip), pointer :: p_ptr_ghosts_per_ghost_cell(:)
  
  environment   => this%get_environment()
  triangulation => this%get_triangulation()
  cell_import       => triangulation%get_cell_import()
  assert ( environment%am_i_l1_task() )

  mypart_id = environment%get_l1_rank() + 1 

  call memalloc ( cell_import%get_num_neighbours(), &
                  touched_neighbours, &
                  __FILE__, __LINE__ )

  p_ptr_ghosts_per_local_cell => this%ptr_ghosts_per_local_cell%get_pointer()
  p_ptr_ghosts_per_ghost_cell => this%ptr_ghosts_per_ghost_cell%get_pointer()
  
  ! Traverse vefs on the interface
  call this%create_itfc_fe_vef_iterator(vef)
  call this%create_fe_cell_iterator(fe)
  call this%create_fe_cell_iterator(coarser_fe)
  result = 0 
  do while(.not. vef%has_finished())
     if ( vef%all_coarser_cells_are_void(field_id,coarser_fe) ) then
       touched_neighbours = .false.
       do ielem=1, vef%get_num_cells_around()
          reference_fe => fe%get_reference_fe(field_id)
          call vef%get_cell_around(ielem,fe)
          ivef = fe%get_vef_lid_from_gid(vef%get_gid())
          part_id = fe%get_my_part()
          if ( part_id /= mypart_id ) then
             local_part_id = cell_import%get_local_neighbour_id(part_id)
             if (.not. touched_neighbours (local_part_id)) then
                result_previous = result
                result = result + reference_fe%get_num_own_dofs_n_face(ivef)
                if (result>result_previous) touched_neighbours (local_part_id) = .true.
             end if
          end if
          
          !if (reference_fe%get_num_own_dofs_n_face(ivef) > 0) then
             if ( fe%is_local() ) then 
               result = result + (p_ptr_ghosts_per_local_cell(fe%get_gid()+1)-&
                                  p_ptr_ghosts_per_local_cell(fe%get_gid()))*reference_fe%get_num_own_dofs_n_face(ivef)
             else
               result = result + (p_ptr_ghosts_per_ghost_cell(fe%get_gid()+1-triangulation%get_num_local_cells())-&
                                 p_ptr_ghosts_per_ghost_cell(fe%get_gid()-triangulation%get_num_local_cells()))*reference_fe%get_num_own_dofs_n_face(ivef)
             end if
          !end if          
       end do
     end if
     call vef%next()
  end do
  pfs_compute_ubound_num_itfc_couplings_by_continuity_nc_mesh = result
  call this%free_fe_cell_iterator(coarser_fe) 
  call this%free_fe_cell_iterator(fe) 
  call this%free_fe_vef_iterator(vef)
  call memfree ( touched_neighbours, __FILE__, __LINE__ )
end function pfs_compute_ubound_num_itfc_couplings_by_continuity_nc_mesh

function pfs_compute_ubound_num_itfc_couplings_by_facet_integ( this, field_id )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: field_id
  integer(ip)                          :: pfs_compute_ubound_num_itfc_couplings_by_facet_integ

  integer(ip)  :: elem_gid
  integer(ip)  :: ivef_itfc, ielem, vef_gid
  integer(ip) :: result

  !assert ( associated (this%par_triangulation) )
  !assert ( environment%am_i_l1_task() )

  !result = 0 
  !! Traverse vefs on the interface
  !do ivef_itfc = 1, this%par_triangulation%num_itfc_vefs 
  !   vef_gid = this%par_triangulation%lst_itfc_vefs(ivef_itfc)
  !   ! Is current vef_gid a face ?
  !   if ( this%triangulation%vefs(vef_gid)%dime == this%triangulation%num_dims-1 ) then
  !      do ielem=1, this%triangulation%vefs(vef_gid)%num_elems_around
  !         elem_gid = this%triangulation%vefs(vef_gid)%elems_around(ielem)
  !         finite_element => this%get_finite_element(elem_gid)
  !         !if ( .not. finite_element%reference_fe_phy(fe_space_id)%p%get_continuity() .and. &
  !         !     .not. finite_element%reference_fe_phy(fe_space_id)%p%get_conformity() ) then
  !         result = result + finite_element%reference_fe_phy(field_id)%p%get_facet_integration_coupling_num_nodes_face( )
  !         !end if
  !      end do
  !   end if
  !   new_parfespace_compute_ubound_num_itfc_couplings_by_facet_integ = result
  !end do

end function pfs_compute_ubound_num_itfc_couplings_by_facet_integ

function par_fe_space_generate_non_consecutive_dof_ggid (cell_ggid, lpos_dof_fe_dofs, field_id) result(dof_gid)
  implicit none
  integer(igp), intent(in) :: cell_ggid
  integer(ip) , intent(in) :: lpos_dof_fe_dofs
  integer(ip) , intent(in) :: field_id
  integer(igp)             :: dof_gid
  assert ( cell_ggid_shift >= 1  )
  assert ( dofs_x_reference_fe_shift >= 1  )
  assert ( num_fields_shift >= 1 )
  assert ( cell_ggid < ISHFT(int(1,igp),int(cell_ggid_shift,igp) ) ) 
  assert ( lpos_dof_fe_dofs < ISHFT(int(1,igp),int(dofs_x_reference_fe_shift,igp) ) )
  assert ( field_id < ISHFT(int(1,igp),int(num_fields_shift,igp) ) )
  dof_gid = (cell_ggid-1) + &
            ISHFT(int(lpos_dof_fe_dofs-1,igp),int(cell_ggid_shift,igp)) + &
            ISHFT(int(field_id-1,igp),int(cell_ggid_shift+dofs_x_reference_fe_shift,igp))
end function par_fe_space_generate_non_consecutive_dof_ggid


subroutine par_fe_space_compute_boundary_dof_import ( this, &
                                                      fields_to_project, &
                                                      num_subset_strong_dirichlet_dofs, &
                                                      global2subset_strong_dirichlet_dofs, &
                                                      dof_import )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: fields_to_project(:)
  integer(ip)          , intent(in)    :: num_subset_strong_dirichlet_dofs
  integer(ip)          , intent(in)    :: global2subset_strong_dirichlet_dofs(:)
  type(dof_import_t)   , intent(inout) :: dof_import

  ! Local raw data
  integer(igp), allocatable    :: raw_interface_data(:,:)
  integer(ip) , allocatable    :: dofs_gid(:)
  integer(ip)                  :: total_ubound_boundary_num_itfc_couplings
  integer(ip)                  :: total_boundary_num_itfc_couplings
  integer(ip), allocatable     :: ubound_boundary_num_itfc_couplings(:)
  integer(ip)                  :: num_fe_spaces_in_subset
  integer(ip)                  :: ifield, field_id
  type(environment_t), pointer :: environment
  
  assert ( size(fields_to_project) >= 1 .and. size(fields_to_project) <= this%get_num_fields() )
  assert ( size(global2subset_strong_dirichlet_dofs) == this%num_fixed_dofs )
  
  environment => this%get_environment()
  assert ( environment%am_i_l1_task() )
  
  num_fe_spaces_in_subset = size(fields_to_project)
  
  call memalloc ( num_fe_spaces_in_subset, ubound_boundary_num_itfc_couplings, __FILE__, __LINE__ )
  total_ubound_boundary_num_itfc_couplings = 0 
  ubound_boundary_num_itfc_couplings = 0
  do ifield = 1, num_fe_spaces_in_subset
    field_id = fields_to_project(ifield)
    if ( this%fe_space_type_x_field(field_id) == fe_space_type_cg ) then
        ubound_boundary_num_itfc_couplings (ifield) = ubound_boundary_num_itfc_couplings (ifield) + &
                                             this%compute_ubound_boundary_num_itfc_couplings_by_continuity(field_id)
    else if ( this%fe_space_type_x_field(field_id) == fe_space_type_dg ) then
        check(.false.) ! Not implemented yet
        !ubound_boundary_num_itfc_couplings (ifield) = ubound_boundary_num_itfc_couplings (ifield) + &
        !        this%compute_ubound_boundary_num_itfc_couplings_by_facet_integ(field_id)
    end if
    total_ubound_boundary_num_itfc_couplings = total_ubound_boundary_num_itfc_couplings + ubound_boundary_num_itfc_couplings (ifield)
  end do

  call memalloc ( num_rows_raw_interface_data, &
                  total_ubound_boundary_num_itfc_couplings, &
                  raw_interface_data, __FILE__, __LINE__ )

  call memalloc ( total_ubound_boundary_num_itfc_couplings, dofs_gid, __FILE__, __LINE__)

  total_boundary_num_itfc_couplings = 0
  do ifield = 1, num_fe_spaces_in_subset
      field_id = fields_to_project(ifield)
        if ( this%fe_space_type_x_field(field_id) == fe_space_type_cg ) then
           total_boundary_num_itfc_couplings = total_boundary_num_itfc_couplings + & 
                this%compute_boundary_raw_interface_data_by_continuity(field_id, &
                                                                       total_boundary_num_itfc_couplings, &
                                                                       ubound_boundary_num_itfc_couplings(field_id),&
                                                                       num_subset_strong_dirichlet_dofs, &
                                                                       global2subset_strong_dirichlet_dofs, &
                                                                       dofs_gid,&
                                                                       raw_interface_data )
        else if ( this%fe_space_type_x_field(field_id) == fe_space_type_dg ) then
          check(.false.) ! Not implemented yet 
          !total_boundary_num_itfc_couplings = total_boundary_num_itfc_couplings + & 
                ! this%compute_raw_interface_data_by_facet_integ(field_id, &
                !                                              total_boundary_num_itfc_couplings, &
                !                                              ubound_boundary_num_itfc_couplings(field_id),&
                !                                              dofs_gid,&
                !                                              raw_interface_data )      
        end if
  end do

  environment => this%get_environment()
  call dof_import%create(environment%get_l1_rank()+1, &
                         environment%get_l1_size(), &
                         num_subset_strong_dirichlet_dofs, &
                         total_boundary_num_itfc_couplings, &
                         dofs_gid, &
                         raw_interface_data )

  call memfree ( ubound_boundary_num_itfc_couplings, __FILE__, __LINE__ )                
  call memfree ( raw_interface_data, __FILE__, __LINE__ )
  call memfree ( dofs_gid, __FILE__, __LINE__ )
end subroutine par_fe_space_compute_boundary_dof_import

function pfs_compute_ubound_boundary_num_itfc_couplings_by_continuity( this, field_id )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: field_id
  integer(ip)                          :: pfs_compute_ubound_boundary_num_itfc_couplings_by_continuity

  integer(ip)  :: mypart_id, part_id, local_part_id
  integer(ip)  :: ivef, ielem

  integer(ip)                            :: result
  logical, allocatable                   :: touched_neighbours(:)
  logical                                :: vef_active

  type(environment_t)      , pointer :: environment
  class(triangulation_t), pointer :: triangulation
  type(cell_import_t)       , pointer :: cell_import
  class(reference_fe_t)        , pointer :: reference_fe
  type(fe_vef_iterator_t)      :: vef
  class(fe_cell_iterator_t), allocatable :: fe
  
  environment   => this%get_environment()
  triangulation => this%get_triangulation()
  cell_import       => triangulation%get_cell_import()
  assert ( environment%am_i_l1_task() )

  mypart_id = environment%get_l1_rank() + 1 

  call memalloc ( cell_import%get_num_neighbours(), &
                  touched_neighbours, &
                  __FILE__, __LINE__ )

  ! Traverse vefs on the interface
  call this%create_itfc_fe_vef_iterator(vef)
  call this%create_fe_cell_iterator(fe) 
  result = 0 
  do while(.not. vef%has_finished())
     if ( vef%is_at_boundary() .and. vef%is_at_interface() ) then
        touched_neighbours = .false.
        do ielem=1, vef%get_num_cells_around()
           call vef%get_cell_around(ielem,fe)
           part_id = fe%get_my_part()
           if ( part_id /= mypart_id ) then
              local_part_id = cell_import%get_local_neighbour_id(part_id)
              if (.not. touched_neighbours (local_part_id)) then
                 touched_neighbours (local_part_id) = .true.
                 ivef = fe%get_vef_lid_from_gid(vef%get_gid())
                 reference_fe => fe%get_reference_fe(field_id)
                 result = result + reference_fe%get_num_own_dofs_n_face(ivef)
              end if
           end if
        end do
     end if
     call vef%next()
  end do
  pfs_compute_ubound_boundary_num_itfc_couplings_by_continuity = result
  call this%free_fe_cell_iterator(fe) 
  call memfree ( touched_neighbours, __FILE__, __LINE__ )
end function pfs_compute_ubound_boundary_num_itfc_couplings_by_continuity

function par_fe_space_compute_boundary_raw_interface_data_by_continuity (  this, &
                                                                           field_id, &
                                                                           offset, &
                                                                           ubound_num_itfc_couplings, &
                                                                           num_subset_strong_dirichlet_dofs, &
                                                                           global2subset_strong_dirichlet_dofs, &
                                                                           dofs_gid, &
                                                                           raw_interface_data ) result(num_itfc_couplings)
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: field_id
  integer(ip)          , intent(in)    :: offset
  integer(ip)          , intent(in)    :: ubound_num_itfc_couplings
  integer(ip)          , intent(in)    :: num_subset_strong_dirichlet_dofs
  integer(ip)          , intent(in)    :: global2subset_strong_dirichlet_dofs(:)
  integer(ip)          , intent(inout) :: dofs_gid(:)
  integer(igp)         , intent(inout) :: raw_interface_data(:, :)
  integer(ip)                          :: num_itfc_couplings

  ! Locals
  integer(ip)  :: istat
  integer(ip)  :: ivef, ivef_itfc, ielem, vef_gid
  integer(igp) :: elem_ggid
  integer(ip)  :: mypart_id, part_id
  integer(ip)  :: ivef_in_elem_id
  integer(ip)  :: idof, idof_interior, dof_gid
  integer(ip)  :: num_dofs_current_vef
  integer(ip)  :: col, init_col, current_col
  integer(ip)  :: num_parts, local_part_id, ipart

  integer(igp)              :: max_elem_ggid
  integer(ip)               :: max_part_id
  integer(ip) , allocatable :: local_idof(:)  
  integer(ip) , allocatable :: lst_dofs_current_vef(:)
  integer(ip) , allocatable :: dofs_max_part_id(:)
  logical     , allocatable :: touched_neighbours(:)
  integer(ip), allocatable  :: parts_visited(:)

  type(environment_t)      , pointer :: environment
  class(triangulation_t), pointer :: triangulation
  type(cell_import_t)       , pointer :: cell_import
  class(reference_fe_t)        , pointer :: reference_fe
  type(list_iterator_t)                  :: own_dofs_on_vef_iterator
  type(fe_vef_iterator_t)                :: vef
  class(fe_cell_iterator_t), allocatable :: fe
  type(i1p_t)              , allocatable :: fe_dofs(:)

  environment   => this%get_environment()
  triangulation     => this%get_triangulation()
  cell_import       => triangulation%get_cell_import()
  assert ( environment%am_i_l1_task() )
  assert ( size(global2subset_strong_dirichlet_dofs) == this%num_fixed_dofs ) 

  ! Allocate touch arrays (we could reduce memory consumption by using hash tables here)
  call memalloc ( num_subset_strong_dirichlet_dofs, local_idof, __FILE__, __LINE__ )
  call memalloc ( num_subset_strong_dirichlet_dofs, lst_dofs_current_vef, __FILE__, __LINE__ )
  call memalloc ( ubound_num_itfc_couplings, dofs_max_part_id, __FILE__, __LINE__ )

  call memalloc ( cell_import%get_num_neighbours(), &
                  touched_neighbours, &
                  __FILE__, __LINE__ )

  call memalloc ( cell_import%get_num_neighbours(), &
                  parts_visited, &
                  __FILE__, __LINE__ )
  
  allocate ( fe_dofs(this%num_fields), stat=istat ) 
  check (istat==0)
  
  mypart_id = environment%get_l1_rank() + 1
  
  current_col  = offset + 1
  local_idof   = 0

  ! Traverse vefs on the interface
  call this%create_itfc_fe_vef_iterator(vef)
  call this%create_fe_cell_iterator(fe) 
  do while(.not. vef%has_finished())
     if ( vef%is_at_boundary() .and. vef%is_at_interface() ) then

        touched_neighbours = .false.
        num_parts = 0
        max_part_id = mypart_id
        max_elem_ggid = 0

        num_dofs_current_vef = 0
        ! Identify the total set of dofs in current vef
        do ielem=1, vef%get_num_cells_around()
           call vef%get_cell_around(ielem,fe)
           !if ( finite_element%reference_fe_phy(fe_space_id)%p%get_continuity() ) then
           part_id = fe%get_my_part()
           elem_ggid = fe%get_ggid()
           ivef = fe%get_vef_lid_from_gid(vef%get_gid())
           call fe%get_fe_dofs( fe_dofs )
           reference_fe => fe%get_reference_fe(field_id)
           own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
           do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
              idof =  own_dofs_on_vef_iterator%get_current()
              dof_gid = fe_dofs(field_id)%p(idof)
              if ( dof_gid == 0 .or. this%is_free_dof(dof_gid) ) then
                 call own_dofs_on_vef_iterator%next()
                 cycle
              end if
              dof_gid = global2subset_strong_dirichlet_dofs(-dof_gid)
              assert ( dof_gid > 0 )
              if ( elem_ggid >= max_elem_ggid ) then
                 max_elem_ggid = elem_ggid
                 if ( local_idof(dof_gid) == 0 ) then
                    num_dofs_current_vef = num_dofs_current_vef + 1    
                    lst_dofs_current_vef (num_dofs_current_vef) = dof_gid
                 end if
                 local_idof(dof_gid) = idof
              end if
              if ( part_id /= mypart_id ) then 
                 local_part_id = cell_import%get_local_neighbour_id(part_id)
                 if ( .not. touched_neighbours(local_part_id) ) then
                    touched_neighbours (local_part_id) = .true.
                    num_parts = num_parts + 1
                    parts_visited (num_parts) = part_id
                    max_part_id = max(part_id, max_part_id)
                 end if
              end if
              call own_dofs_on_vef_iterator%next()
           end do
           !end if
        end do

        init_col = current_col
        do idof=1, num_dofs_current_vef
           dof_gid = lst_dofs_current_vef(idof)
           do ipart=1, num_parts
              part_id = parts_visited(ipart)
              dofs_gid ( current_col ) = dof_gid 
              dofs_max_part_id ( current_col-offset ) = max_part_id
              raw_interface_data(neighbor_part_id_row, current_col) = part_id
              raw_interface_data(dof_gid_row, current_col) = this%generate_non_consecutive_dof_ggid(max_elem_ggid, &
                                                                                                   local_idof(dof_gid), &
                                                                                                   field_id)
              raw_interface_data(owner_flag_row, current_col) = num_parts + 1
              current_col = current_col + 1
           end do
        end do
     end if
     call vef%next()
  end do
  call this%free_fe_cell_iterator(fe) 
  deallocate(fe_dofs, stat=istat ) 
  check (istat==0)
  
  ! Free touch arrays
  call memfree ( local_idof, __FILE__, __LINE__ )
  call memfree ( lst_dofs_current_vef, __FILE__, __LINE__ )
  call memfree ( parts_visited, __FILE__, __LINE__ )
  call memfree ( touched_neighbours, __FILE__, __LINE__ )

  call this%raw_interface_data_by_continuity_decide_owner (offset, &
                                                           current_col-1, &
                                                           raw_interface_data,&
                                                           dofs_max_part_id,&
                                                           dofs_gid)

  call memfree ( dofs_max_part_id, __FILE__, __LINE__ )

  num_itfc_couplings = current_col-1 
end function par_fe_space_compute_boundary_raw_interface_data_by_continuity


function par_fe_space_get_num_dims ( this )
  implicit none
  class(par_fe_space_t), intent(in) :: this
  integer(ip)                       :: par_fe_space_get_num_dims
  type(environment_t), pointer :: environment
  environment => this%get_environment()
  if ( environment%am_i_l1_task() ) then
     par_fe_space_get_num_dims = this%serial_fe_space_t%get_num_dims()
  end if
end function par_fe_space_get_num_dims

function par_fe_space_get_num_fe_objects ( this )
  implicit none
  class(par_fe_space_t), intent(in) :: this
  integer(ip) :: par_fe_space_get_num_fe_objects
  par_fe_space_get_num_fe_objects = this%triangulation%get_num_objects()
end function par_fe_space_get_num_fe_objects 

subroutine pfs_compute_max_part_id_my_part_id_and_dofs_ggids_field ( this, field_id )
  implicit none
  class(par_fe_space_t)        , intent(inout) :: this
  integer(ip)                  , intent(in)    :: field_id
  
  class(environment_t)  , pointer :: environment
  class(triangulation_t), pointer :: triangulation
  type(cell_import_t)   , pointer :: cell_import
  class(reference_fe_t) , pointer :: reference_fe
  type(list_iterator_t) :: own_dofs_on_vef_iterator
  type(fe_vef_iterator_t) :: vef
  class(fe_cell_iterator_t), allocatable :: fe, coarser_fe

  integer(ip), pointer :: fe_dofs(:)
  logical, allocatable :: touched_neighbours(:)
  integer(ip) :: ielem, part_id, ivef, dof_gid
  integer(ip) :: mypart_id, max_part_id, idof
  integer(ip) :: local_part_id
  logical :: all_ghosts
  logical :: free_dofs 
  integer(ip) :: cell_gid
  integer(ip) :: num_vefs
  integer(ip) :: num_dofs
  integer(ip) :: base_pos, base_pos_dofs
  integer(ip), pointer :: p_max_part_id_vefs(:)
  integer(igp), pointer :: p_lst_dofs_ggids(:)
  integer(ip)  :: i
  integer(igp) :: elem_ggid
  integer(igp) :: max_elem_ggid
  integer(ip)  :: max_elem_gid
  integer(ip)  :: max_idof
  type(std_vector_integer_ip_t) :: dofs_gids
  type(std_vector_integer_ip_t) :: dofs_lids
  integer(ip), pointer :: snd_ptrs(:)
  integer(ip), pointer :: snd_leids(:)
  integer(ip), pointer :: p_rcv_my_part_id_vefs(:)
  integer(ip), pointer :: p_my_part_id_vefs(:)
  integer(ip), pointer :: p_lst_ghosts_per_local_cell(:) 
  integer(ip), pointer :: p_ptr_ghosts_per_local_cell(:)
  integer(ip), allocatable :: local_idof(:)
  
  
  triangulation => this%get_triangulation()
  environment   => triangulation%get_environment()
  cell_import   => triangulation%get_cell_import()
  
  call memalloc ( this%block_layout%get_block_num_dofs(this%block_layout%get_block_id(field_id)), &
                  local_idof, __FILE__, __LINE__ )
 
  ! TO-DO: this code is assuming that the number of DoFs per cell 
  !        is equivalent for all cells. We should re-think how should
  !        it be modified in order to have variable DoFs per cell  
  num_dofs = this%get_max_num_dofs_on_a_cell()
 
  ! Initialization of DoFs data structures
  call this%ptr_dofs_field%resize(1)
  call this%ptr_dofs_field%set(1,1)
  i=2
  call this%create_fe_cell_iterator(fe)
  call this%create_fe_cell_iterator(coarser_fe)

  do while ( .not. fe%has_finished() )
    call this%ptr_dofs_field%push_back(this%ptr_dofs_field%get(i-1)+num_dofs)  
    call fe%next()
    i=i+1
  end do
  call this%lst_dofs_ggids%resize(0)
  call this%lst_dofs_ggids%resize(this%ptr_dofs_field%get(triangulation%get_num_cells()+1)-1,-1_igp)
  
  call fe%first()
  if ( .not. fe%has_finished() ) then
    num_vefs = fe%get_num_vefs()
  else
    num_vefs = 0
  end if   
  
  call this%max_part_id_vefs%resize(0) 
  call this%max_part_id_vefs%resize(triangulation%get_num_cells()*num_vefs,0) 
 
  call this%my_part_id_vefs%resize(0)
  call this%my_part_id_vefs%resize(triangulation%get_num_cells()*num_vefs,0) 
 
  call memalloc ( cell_import%get_num_neighbours(), &
                  touched_neighbours, __FILE__, __LINE__ )
  
  mypart_id = environment%get_l1_rank()+1
    
  ! Traverse vefs on the interface
  call this%create_itfc_fe_vef_iterator(vef)
  do while(.not. vef%has_finished())
    if ( vef%all_coarser_cells_are_void(field_id,coarser_fe) ) then
      touched_neighbours = .false.
      all_ghosts = .true.
      free_dofs = .false. 
      max_part_id = 0
      max_elem_ggid = 0
      do ielem=1, vef%get_num_cells_around()
        call vef%get_cell_around(ielem,fe)
        elem_ggid = fe%get_ggid()
        part_id = fe%get_my_part()
        ivef = fe%get_vef_lid_from_gid(vef%get_gid())
        cell_gid = fe%get_gid()
        base_pos = (cell_gid-1)*num_vefs
        call fe%get_field_fe_dofs( field_id, fe_dofs )
        reference_fe => fe%get_reference_fe(field_id)
        own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
        do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
           idof = own_dofs_on_vef_iterator%get_current()
           dof_gid = fe_dofs(idof)
           if ( dof_gid == 0 .or. this%is_strong_dirichlet_dof(dof_gid) ) then
             call own_dofs_on_vef_iterator%next()
             cycle
           end if
           free_dofs = .true.
           if ( fe%is_local() ) then 
             all_ghosts = .false.
           else
             call this%my_part_id_vefs%set(base_pos+ivef, mypart_id)
           end if
           if ( elem_ggid >= max_elem_ggid ) then
             max_elem_ggid = elem_ggid
             max_elem_gid  = fe%get_gid()
             local_idof(dof_gid) = idof
           end if
           if ( part_id /= mypart_id ) then
              local_part_id = cell_import%get_local_neighbour_id(part_id)
              if ( .not. touched_neighbours(local_part_id) ) then
                 touched_neighbours (local_part_id) = .true.
                 max_part_id = max(part_id, max_part_id)
              end if
           else
              max_part_id = max(mypart_id, max_part_id)
           end if
           call own_dofs_on_vef_iterator%next()
        end do
      end do
      
      ! If all parts around a given proper vef are ghost, then 
      ! mypart_id CANNOT become the owner of the DoFs on top of it
      if ( all_ghosts .and. free_dofs ) then
         call vef%next()
         cycle
      else if ( .not. free_dofs ) then     
         call vef%next()
         cycle
      end if  
      
      do ielem=1, vef%get_num_cells_around()
        call vef%get_cell_around(ielem,fe)
        
        ! Compute this%max_part_id_vefs
        ivef = fe%get_vef_lid_from_gid(vef%get_gid())
        cell_gid = fe%get_gid()
        base_pos = (cell_gid-1)*num_vefs
        
        ! Compute this%lst_dofs_ggids
        ivef = fe%get_vef_lid_from_gid(vef%get_gid())
        call fe%get_field_fe_dofs( field_id, fe_dofs )
        reference_fe => fe%get_reference_fe(field_id)
        own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
        do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
           idof    = own_dofs_on_vef_iterator%get_current()
           dof_gid = fe_dofs(idof)
           if ( dof_gid == 0 .or. this%is_strong_dirichlet_dof(dof_gid) ) then
             call own_dofs_on_vef_iterator%next()
             cycle
           end if
           call this%max_part_id_vefs%set(base_pos+ivef, max_part_id)
                      
           base_pos_dofs = this%ptr_dofs_field%get(fe%get_gid())-1
           call this%lst_dofs_ggids%set(base_pos_dofs+idof, this%generate_non_consecutive_dof_ggid(max_elem_ggid, &
                                                                                                   local_idof(dof_gid), &
                                                                                                   field_id))
           call own_dofs_on_vef_iterator%next()
        end do
      end do  
    end if
    call vef%next()
  end do
  
  p_max_part_id_vefs => this%max_part_id_vefs%get_pointer()
  call environment%l1_neighbours_exchange ( cell_import%get_num_neighbours(), &
                                            cell_import%get_neighbours_ids(),&
                                            cell_import%get_rcv_ptrs(),&
                                            cell_import%get_rcv_leids(),&
                                            cell_import%get_num_neighbours(), &
                                            cell_import%get_neighbours_ids(),&
                                            cell_import%get_snd_ptrs(),&
                                            cell_import%get_snd_leids(),&
                                            p_max_part_id_vefs, & 
                                            p_max_part_id_vefs, &
                                            num_vefs)
  
  p_lst_dofs_ggids => this%lst_dofs_ggids%get_pointer()
  call environment%l1_neighbours_exchange ( cell_import%get_num_neighbours(), &
                                            cell_import%get_neighbours_ids(),&
                                            cell_import%get_rcv_ptrs(),&
                                            cell_import%get_rcv_leids(),&
                                            cell_import%get_num_neighbours(), &
                                            cell_import%get_neighbours_ids(),&
                                            cell_import%get_snd_ptrs(),&
                                            cell_import%get_snd_leids(),&
                                            p_lst_dofs_ggids, & 
                                            p_lst_dofs_ggids, &
                                            num_dofs) 


  snd_ptrs => cell_import%get_snd_ptrs()
  call this%rcv_my_part_id_vefs%resize(0)
  call this%rcv_my_part_id_vefs%resize((snd_ptrs(cell_import%get_num_neighbours()+1)-1)*num_vefs,0)
  p_rcv_my_part_id_vefs => this%rcv_my_part_id_vefs%get_pointer() 
  p_my_part_id_vefs     => this%my_part_id_vefs%get_pointer() 
  call environment%l1_neighbours_exchange ( num_rcv    = cell_import%get_num_neighbours(), &
                                            list_rcv   = cell_import%get_neighbours_ids(),&
                                            rcv_ptrs   = cell_import%get_snd_ptrs(),&
                                            rcv_buf    = p_rcv_my_part_id_vefs, &
                                            num_snd    = cell_import%get_num_neighbours(), &
                                            list_snd   = cell_import%get_neighbours_ids(),&
                                            snd_ptrs   = cell_import%get_rcv_ptrs(),&
                                            pack_idx   = cell_import%get_rcv_leids(),&
                                            x          = p_my_part_id_vefs, &
                                            chunk_size = num_vefs)

  call this%ptr_ghosts_per_local_cell%resize(0)
  call this%ptr_ghosts_per_local_cell%resize(triangulation%get_num_local_cells()+1,0)
  p_ptr_ghosts_per_local_cell => this%ptr_ghosts_per_local_cell%get_pointer() 

  snd_leids => cell_import%get_snd_leids()
  do i=1, size(snd_leids)
    p_ptr_ghosts_per_local_cell(snd_leids(i)+1) = p_ptr_ghosts_per_local_cell(snd_leids(i)+1)+1  
  end do
  p_ptr_ghosts_per_local_cell(1)=1
  do i=1, triangulation%get_num_local_cells()
    p_ptr_ghosts_per_local_cell(i+1) = p_ptr_ghosts_per_local_cell(i+1)+p_ptr_ghosts_per_local_cell(i) 
  end do 
  
  call this%lst_ghosts_per_local_cell%resize(0)
  call this%lst_ghosts_per_local_cell%resize(p_ptr_ghosts_per_local_cell(triangulation%get_num_local_cells()+1)-1,0)
  p_lst_ghosts_per_local_cell => this%lst_ghosts_per_local_cell%get_pointer()

  do i=1, size(snd_leids)
    p_lst_ghosts_per_local_cell(p_ptr_ghosts_per_local_cell(snd_leids(i)))=i
    p_ptr_ghosts_per_local_cell(snd_leids(i))=p_ptr_ghosts_per_local_cell(snd_leids(i))+1 
  end do

  do i=triangulation%get_num_local_cells(),2,-1
    p_ptr_ghosts_per_local_cell(i) = p_ptr_ghosts_per_local_cell(i-1)
  end do
  p_ptr_ghosts_per_local_cell(1)=1 
  
  call this%free_fe_cell_iterator(coarser_fe)
  call this%free_fe_cell_iterator(fe)
  call this%free_fe_vef_iterator(vef)
  call memfree ( touched_neighbours, __FILE__, __LINE__ )
  call memfree ( local_idof, __FILE__, __LINE__ )
end subroutine pfs_compute_max_part_id_my_part_id_and_dofs_ggids_field 


subroutine pfs_compute_exchange_control_data_to_complete_itfc_couplings ( this, field_id ) 
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in):: field_id
  class(triangulation_t), pointer :: triangulation
  class(environment_t), pointer :: environment 
  type(cell_import_t)   , pointer :: cell_import
  integer(ip), pointer :: p_ptr_ghosts_per_local_cell(:)
  integer(ip), pointer :: p_lst_ghosts_per_local_cell(:)
  integer(ip), pointer :: p_num_cells_to_send_x_local_cell(:)
  integer(ip) :: i, j, k, l, icell, current 
  integer(ip), pointer :: snd_ptrs(:)
  integer(ip), pointer :: snd_leids(:)
  integer(ip), pointer :: rcv_ptrs(:)
  integer(ip), pointer :: rcv_leids(:)
  integer(ip), pointer :: p_snd_ptrs_complete_itfc_couplings(:)
  integer(ip), pointer :: p_rcv_ptrs_complete_itfc_couplings(:)
  integer(ip), pointer :: p_rcv_my_part_id_vefs(:)
  integer(ip), pointer :: p_ptr_ghosts_per_ghost_cell(:)
  integer(ip), pointer :: p_lst_ghosts_per_ghost_cell(:)
  integer(ip), pointer :: p_rcv_my_part_id_vefs_complete_itfc_couplings(:)
  integer(ip), pointer :: p_snd_leids_complete_itfc_couplings(:)
  class(fe_cell_iterator_t), allocatable :: fe
  integer(ip) :: num_vefs
  
  triangulation => this%get_triangulation()
  environment   => triangulation%get_environment()
  cell_import   => triangulation%get_cell_import()

  call this%num_cells_to_send_x_local_cell%resize(0)
  call this%num_cells_to_send_x_local_cell%resize(triangulation%get_num_cells(),0)

  p_ptr_ghosts_per_local_cell => this%ptr_ghosts_per_local_cell%get_pointer()
  do icell=1, triangulation%get_num_local_cells()
    call this%num_cells_to_send_x_local_cell%set(icell, p_ptr_ghosts_per_local_cell(icell+1)-&
                                                        p_ptr_ghosts_per_local_cell(icell))
  end do 

  p_num_cells_to_send_x_local_cell => this%num_cells_to_send_x_local_cell%get_pointer() 
  call environment%l1_neighbours_exchange ( cell_import%get_num_neighbours(), &
                                            cell_import%get_neighbours_ids(),&
                                            cell_import%get_rcv_ptrs(),&
                                            cell_import%get_rcv_leids(),&
                                            cell_import%get_num_neighbours(), &
                                            cell_import%get_neighbours_ids(),&
                                            cell_import%get_snd_ptrs(),&
                                            cell_import%get_snd_leids(),&
                                            p_num_cells_to_send_x_local_cell, & 
                                            p_num_cells_to_send_x_local_cell)
    
  snd_ptrs  => cell_import%get_snd_ptrs()
  snd_leids => cell_import%get_snd_leids() 
   
  p_ptr_ghosts_per_local_cell => this%ptr_ghosts_per_local_cell%get_pointer()
  p_lst_ghosts_per_local_cell => this%lst_ghosts_per_local_cell%get_pointer()
  
  ! Init send data structures
  call this%snd_ptrs_complete_itfc_couplings%resize(0)
  call this%snd_ptrs_complete_itfc_couplings%resize(cell_import%get_num_neighbours()+1,0)
  p_snd_ptrs_complete_itfc_couplings => this%snd_ptrs_complete_itfc_couplings%get_pointer()
  call this%snd_leids_complete_itfc_couplings%resize(0)
  
  ! Compute send data structures 
  do i=1, cell_import%get_num_neighbours()
     do j=snd_ptrs(i), snd_ptrs(i+1)-1
        k=snd_leids(j)
        p_snd_ptrs_complete_itfc_couplings(i+1) = p_snd_ptrs_complete_itfc_couplings(i+1) + & 
                             p_ptr_ghosts_per_local_cell(k+1)-p_ptr_ghosts_per_local_cell(k)
                             
        do l=p_ptr_ghosts_per_local_cell(k), & 
             p_ptr_ghosts_per_local_cell(k+1)-1
             call this%snd_leids_complete_itfc_couplings%push_back(p_lst_ghosts_per_local_cell(l))
        end do
     end do 
  end do 
  
  p_snd_ptrs_complete_itfc_couplings(1)=1
  do i=1, cell_import%get_num_neighbours()
    p_snd_ptrs_complete_itfc_couplings(i+1) = p_snd_ptrs_complete_itfc_couplings(i+1) + &
                                              p_snd_ptrs_complete_itfc_couplings(i)
  end do 
  
  ! Init recv data structures
  call this%rcv_ptrs_complete_itfc_couplings%resize(0)
  call this%rcv_ptrs_complete_itfc_couplings%resize(cell_import%get_num_neighbours()+1,0)
  p_rcv_ptrs_complete_itfc_couplings => this%rcv_ptrs_complete_itfc_couplings%get_pointer()
  call this%ptr_ghosts_per_ghost_cell%resize(0)
  call this%ptr_ghosts_per_ghost_cell%resize(triangulation%get_num_ghost_cells()+1,0)
  p_ptr_ghosts_per_ghost_cell => this%ptr_ghosts_per_ghost_cell%get_pointer()
  
  ! Compute recv data structures
  rcv_ptrs  => cell_import%get_rcv_ptrs()
  rcv_leids => cell_import%get_rcv_leids()
  do i=1, size(rcv_leids)
    k=rcv_leids(i)
    p_ptr_ghosts_per_ghost_cell(k+1-triangulation%get_num_local_cells()) = & 
      p_ptr_ghosts_per_ghost_cell(k+1-triangulation%get_num_local_cells())+p_num_cells_to_send_x_local_cell(k)  
  end do
  p_ptr_ghosts_per_ghost_cell(1)=1
  do i=1, triangulation%get_num_ghost_cells()
    p_ptr_ghosts_per_ghost_cell(i+1) = p_ptr_ghosts_per_ghost_cell(i+1)+p_ptr_ghosts_per_ghost_cell(i) 
  end do 
  
  call this%lst_ghosts_per_ghost_cell%resize(0)
  call this%lst_ghosts_per_ghost_cell%resize(p_ptr_ghosts_per_ghost_cell(triangulation%get_num_ghost_cells()+1)-1,0)
  p_lst_ghosts_per_ghost_cell => this%lst_ghosts_per_ghost_cell%get_pointer()

  current = 1 
  do i=1, cell_import%get_num_neighbours()
     do j=rcv_ptrs(i), rcv_ptrs(i+1)-1
        k=rcv_leids(j)
        p_rcv_ptrs_complete_itfc_couplings(i+1) = p_rcv_ptrs_complete_itfc_couplings(i+1) + & 
                                                  p_num_cells_to_send_x_local_cell(k)
                                                  
        do l=1, p_num_cells_to_send_x_local_cell(k)                                      
          p_lst_ghosts_per_ghost_cell(p_ptr_ghosts_per_ghost_cell(k-triangulation%get_num_local_cells()))=current
          p_ptr_ghosts_per_ghost_cell(k-triangulation%get_num_local_cells())=&
            p_ptr_ghosts_per_ghost_cell(k-triangulation%get_num_local_cells())+1
          current = current + 1 
        end do
     end do 
  end do
  do i=triangulation%get_num_ghost_cells(),2,-1
    p_ptr_ghosts_per_ghost_cell(i) = p_ptr_ghosts_per_ghost_cell(i-1)
  end do
  p_ptr_ghosts_per_ghost_cell(1)=1
  
  p_rcv_ptrs_complete_itfc_couplings(1)=1
  do i=1, cell_import%get_num_neighbours()
    p_rcv_ptrs_complete_itfc_couplings(i+1) = p_rcv_ptrs_complete_itfc_couplings(i+1) + &
                                              p_rcv_ptrs_complete_itfc_couplings(i)
  end do 
  
  call this%create_fe_cell_iterator(fe)
  if ( .not. fe%has_finished() ) then
    num_vefs = fe%get_num_vefs()
  else
    num_vefs = 0
  end if  
  call this%free_fe_cell_iterator(fe)
  
  call this%rcv_my_part_id_vefs_complete_itfc_couplings%resize(0)
  call this%rcv_my_part_id_vefs_complete_itfc_couplings%resize(&
     (p_rcv_ptrs_complete_itfc_couplings(cell_import%get_num_neighbours()+1)-1)*num_vefs,0)
  
  p_rcv_my_part_id_vefs_complete_itfc_couplings => & 
      this%rcv_my_part_id_vefs_complete_itfc_couplings%get_pointer()
  
  p_snd_leids_complete_itfc_couplings => this%snd_leids_complete_itfc_couplings%get_pointer()    
  p_rcv_my_part_id_vefs               => this%rcv_my_part_id_vefs%get_pointer()
  call environment%l1_neighbours_exchange ( num_rcv    = cell_import%get_num_neighbours(), &
                                            list_rcv   = cell_import%get_neighbours_ids(),&
                                            rcv_ptrs   = p_rcv_ptrs_complete_itfc_couplings,&
                                            rcv_buf    = p_rcv_my_part_id_vefs_complete_itfc_couplings, &
                                            num_snd    = cell_import%get_num_neighbours(), &
                                            list_snd   = cell_import%get_neighbours_ids(),&
                                            snd_ptrs   = p_snd_ptrs_complete_itfc_couplings,&
                                            pack_idx   = p_snd_leids_complete_itfc_couplings,&
                                            x          = p_rcv_my_part_id_vefs, &
                                            chunk_size = num_vefs)  
end subroutine pfs_compute_exchange_control_data_to_complete_itfc_couplings



function par_fe_space_compute_raw_interface_data_by_continuity (  this, &
                                                                      field_id, &
                                                                      offset, &
                                                                      ubound_num_itfc_couplings, &
                                                                      dofs_gid, &
                                                                      raw_interface_data ) result(num_itfc_couplings)
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: field_id
  integer(ip)          , intent(in)    :: offset
  integer(ip)          , intent(in)    :: ubound_num_itfc_couplings
  integer(ip)          , intent(inout) :: dofs_gid(:)
  integer(igp)         , intent(inout) :: raw_interface_data(:, :)
  integer(ip)                          :: num_itfc_couplings

  ! Locals
  integer(ip)  :: istat
  integer(ip)  :: ivef, ivef_itfc, ielem, vef_gid
  integer(igp) :: elem_ggid
  integer(ip)  :: mypart_id, part_id
  integer(ip)  :: ivef_in_elem_id
  integer(ip)  :: idof, idof_interior, dof_gid
  integer(ip)  :: num_dofs_current_vef
  integer(ip)  :: col, init_col, current_col
  integer(ip)  :: num_parts, local_part_id, ipart

  integer(igp)              :: max_elem_ggid
  integer(ip)               :: max_part_id
  integer(ip) , allocatable :: local_idof(:)  
  integer(ip) , allocatable :: lst_dofs_current_vef(:)
  integer(ip) , allocatable :: dofs_max_part_id(:)
  logical     , allocatable :: touched_neighbours(:)
  integer(ip), allocatable  :: parts_visited(:)

  type(environment_t)      , pointer :: environment
  class(triangulation_t), pointer :: triangulation
  type(cell_import_t)       , pointer :: cell_import
  class(reference_fe_t)        , pointer :: reference_fe
  type(list_iterator_t)                  :: own_dofs_on_vef_iterator
  type(fe_vef_iterator_t)                :: vef
  class(fe_cell_iterator_t), allocatable :: fe
  type(i1p_t)              , allocatable :: fe_dofs(:)


  environment   => this%get_environment()
  triangulation     => this%get_triangulation()
  cell_import       => triangulation%get_cell_import()
  assert ( environment%am_i_l1_task() )

  ! Allocate touch arrays (we could reduce memory consumption by using hash tables here)
  call memalloc ( this%block_layout%get_block_num_dofs(this%block_layout%get_block_id(field_id)), local_idof, __FILE__, __LINE__ )
  call memalloc ( this%block_layout%get_block_num_dofs(this%block_layout%get_block_id(field_id)), lst_dofs_current_vef, __FILE__, __LINE__ )
  call memalloc ( ubound_num_itfc_couplings, dofs_max_part_id, __FILE__, __LINE__ )

  call memalloc ( cell_import%get_num_neighbours(), &
                  touched_neighbours, &
                  __FILE__, __LINE__ )

  call memalloc ( cell_import%get_num_neighbours(), &
                  parts_visited, &
                  __FILE__, __LINE__ )
  
  allocate ( fe_dofs(this%num_fields), stat=istat ) 
  check (istat==0)
  
  mypart_id = environment%get_l1_rank() + 1
  
  current_col  = offset + 1
  local_idof   = 0

  ! Traverse vefs on the interface
  call this%create_itfc_fe_vef_iterator(vef)
  call this%create_fe_cell_iterator(fe) 
  do while(.not. vef%has_finished())
     touched_neighbours = .false.
     num_parts = 0
     max_part_id = mypart_id
     max_elem_ggid = 0

     num_dofs_current_vef = 0
     ! Identify the total set of dofs in current vef
     do ielem=1, vef%get_num_cells_around()
        call vef%get_cell_around(ielem,fe)
        !if ( finite_element%reference_fe_phy(fe_space_id)%p%get_continuity() ) then
        part_id = fe%get_my_part()
        elem_ggid = fe%get_ggid()
        ivef = fe%get_vef_lid_from_gid(vef%get_gid())
        call fe%get_fe_dofs( fe_dofs )
        reference_fe => fe%get_reference_fe(field_id)
        own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
        do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
           idof =  own_dofs_on_vef_iterator%get_current()
           dof_gid = fe_dofs(field_id)%p(idof)
           if ( .not. this%is_free_dof(dof_gid) ) then
             call own_dofs_on_vef_iterator%next()
             cycle
           end if
           if ( elem_ggid >= max_elem_ggid ) then
              max_elem_ggid = elem_ggid
              if ( local_idof(dof_gid) == 0 ) then
                 num_dofs_current_vef = num_dofs_current_vef + 1    
                 lst_dofs_current_vef (num_dofs_current_vef) = dof_gid
              end if
              local_idof(dof_gid) = idof
           end if
           if ( part_id /= mypart_id ) then 
              local_part_id = cell_import%get_local_neighbour_id(part_id)
              if ( .not. touched_neighbours(local_part_id) ) then
                 touched_neighbours (local_part_id) = .true.
                 num_parts = num_parts + 1
                 parts_visited (num_parts) = part_id
                 max_part_id = max(part_id, max_part_id)
              end if
           end if
           call own_dofs_on_vef_iterator%next()
        end do
        !end if
     end do

     init_col = current_col
     do idof=1, num_dofs_current_vef
        dof_gid = lst_dofs_current_vef(idof)
        do ipart=1, num_parts
           part_id = parts_visited(ipart)
           dofs_gid ( current_col ) = dof_gid 
           dofs_max_part_id ( current_col-offset ) = max_part_id
           raw_interface_data(neighbor_part_id_row, current_col) = part_id
           raw_interface_data(dof_gid_row, current_col) = this%generate_non_consecutive_dof_ggid(max_elem_ggid, &
                                                                                                local_idof(dof_gid), &
                                                                                                field_id)
           raw_interface_data(owner_flag_row, current_col) = num_parts + 1
           current_col = current_col + 1
        end do
     end do
     call vef%next()
  end do
  call this%free_fe_cell_iterator(fe)
  call this%free_fe_vef_iterator(vef)
  deallocate(fe_dofs, stat=istat ) 
  check (istat==0)
  
  ! Free touch arrays
  call memfree ( local_idof, __FILE__, __LINE__ )
  call memfree ( lst_dofs_current_vef, __FILE__, __LINE__ )
  call memfree ( parts_visited, __FILE__, __LINE__ )
  call memfree ( touched_neighbours, __FILE__, __LINE__ )

  call this%raw_interface_data_by_continuity_decide_owner (offset, &
                                                           current_col-1, &
                                                           raw_interface_data,&
                                                           dofs_max_part_id,&
                                                           dofs_gid)

  call memfree ( dofs_max_part_id, __FILE__, __LINE__ )

  num_itfc_couplings = current_col-1 
end function par_fe_space_compute_raw_interface_data_by_continuity

function pfs_compute_raw_itfc_data_by_continuity_nc_mesh_rev (  this, &
                                                                field_id, &
                                                                offset, &
                                                                dofs_gid, &
                                                                raw_interface_data ) result(num_itfc_couplings)
  implicit none
  class(par_fe_space_t)         , intent(inout) :: this
  integer(ip)                   , intent(in)    :: field_id
  integer(ip)                   , intent(in)    :: offset
  type(std_vector_integer_ip_t) , intent(inout) :: dofs_gid
  type(allocatable_array_igp2_t), intent(inout) :: raw_interface_data
  integer(ip) :: num_itfc_couplings

  ! Locals
  integer(ip)  :: istat
  integer(ip)  :: ivef, ivef_itfc, ielem, vef_gid
  integer(ip)  :: mypart_id, part_id
  integer(ip)  :: ivef_in_elem_id
  integer(ip)  :: idof, jdof, dof_gid
  integer(ip)  :: num_dofs_current_vef
  integer(ip)  :: col, init_col, current_col
  integer(ip)  :: num_parts_nearest_neighbours, num_parts_neighbours_nearest_neighbours, local_part_id, ipart

  integer(ip)               :: max_part_id
  integer(ip) , allocatable :: local_idof(:)  
  integer(ip) , allocatable :: lst_dofs_current_vef(:)
  type(std_vector_integer_ip_t) :: dofs_max_part_id
  logical     , allocatable :: touched_neighbours(:)
  integer(ip), allocatable  :: parts_visited(:)

  type(environment_t), pointer :: environment
  class(triangulation_t), pointer :: triangulation
  type(cell_import_t), pointer :: cell_import
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t) :: own_dofs_on_vef_iterator
  type(fe_vef_iterator_t) :: vef
  class(fe_cell_iterator_t), allocatable :: fe
  integer(ip), pointer :: fe_dofs(:)
  integer(ip) :: num_vefs
  integer(ip) :: cell_gid, base_pos_dofs, base_pos, start_pos
  logical :: all_local, all_ghosts
  integer(igp) :: dof_ggid
  integer(ip) :: i, j, k, aux, part_neighbour_nearest_neighbour 
  integer(ip) :: offset_dofs 
  type(hash_table_ip_ip_t) :: parts_neighbours_nearest_neighbours_visited
  type(std_vector_integer_ip_t) :: lst_parts_neighbours_nearest_neighbours
  integer(ip) :: start_col, end_col
  integer(ip) , allocatable :: perm(:)
  integer(ip), allocatable :: buf(:)
  integer(igp), allocatable :: dofs_ggid(:)
  integer(ip), pointer :: p_num_parts_dofs_cell_wise(:)
  integer(ip), pointer :: p_ptrs_to_rcv_lst_parts_dofs_cell_wise(:) 
  integer(ip), pointer :: p_rcv_lst_parts_dofs_cell_wise(:)
  integer(ip), pointer :: p_dofs_max_part_id(:)
  integer(ip), pointer :: p_dofs_gid(:)
 
  environment   => this%get_environment()
  triangulation => this%get_triangulation()
  cell_import   => triangulation%get_cell_import()
  assert ( environment%am_i_l1_task() )

  ! Allocate touch arrays (we could reduce memory consumption by using hash tables here)
  call memalloc ( this%block_layout%get_block_num_dofs(this%block_layout%get_block_id(field_id)), &
       local_idof, __FILE__, __LINE__ )
  call memalloc ( this%block_layout%get_block_num_dofs(this%block_layout%get_block_id(field_id)), &
       lst_dofs_current_vef, __FILE__, __LINE__ )

  call memalloc ( cell_import%get_num_neighbours(), &
       touched_neighbours, &
       __FILE__, __LINE__ )

  call memalloc ( cell_import%get_num_neighbours(), &
       parts_visited, &
       __FILE__, __LINE__ )

  call memalloc ( this%block_layout%get_block_num_dofs(this%block_layout%get_block_id(field_id)), &
       dofs_ggid, __FILE__, __LINE__ )

  mypart_id = environment%get_l1_rank() + 1

  current_col  = offset + 1
  local_idof   = 0

  p_num_parts_dofs_cell_wise => this%num_parts_dofs_cell_wise%get_pointer()
  p_ptrs_to_rcv_lst_parts_dofs_cell_wise => this%ptrs_to_rcv_lst_parts_dofs_cell_wise%get_pointer()
  p_rcv_lst_parts_dofs_cell_wise => this%rcv_lst_parts_dofs_cell_wise%get_pointer()

  ! Traverse vefs on the interface
  call this%create_itfc_fe_vef_iterator(vef)
  call this%create_fe_cell_iterator(fe) 
  if ( .not. fe%has_finished() ) then
    num_vefs = fe%get_num_vefs()
  else
    num_vefs = 0
  end if  
  do while(.not. vef%has_finished())
        do ielem=1, vef%get_num_cells_around()
           call vef%get_cell_around(ielem,fe)
           if ( .not. fe%is_void(field_id) ) exit 
        end do
        if ( ielem > vef%get_num_cells_around() ) then
          call vef%next()
          cycle
        end if
        
        touched_neighbours = .false.
        num_parts_nearest_neighbours = 0
        num_parts_neighbours_nearest_neighbours = 0

        ! Retrieve max_part_id 
        ivef        = fe%get_vef_lid_from_gid(vef%get_gid())
        cell_gid    = fe%get_gid()
        base_pos    = (cell_gid-1)*num_vefs
        max_part_id = this%max_part_id_vefs%get(base_pos+ivef)

        num_dofs_current_vef = 0
        call fe%get_field_fe_dofs( field_id, fe_dofs )
        reference_fe => fe%get_reference_fe(field_id)
        own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
        do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
            idof =  own_dofs_on_vef_iterator%get_current()
            dof_gid = fe_dofs(idof)
            if ( .not. this%is_free_dof(dof_gid) ) then
               call own_dofs_on_vef_iterator%next()
               cycle
            end if

            base_pos_dofs = this%ptr_dofs_field%get(fe%get_gid())-1
            dofs_ggid(dof_gid) = this%lst_dofs_ggids%get(base_pos_dofs+idof)
            if ( local_idof(dof_gid) == 0 ) then
              num_dofs_current_vef = num_dofs_current_vef + 1    
              lst_dofs_current_vef (num_dofs_current_vef) = dof_gid
              local_idof(dof_gid) = idof
            end if
            
            do k=2,this%lst_parts_around_itfc_dofs(1,this%dof_gid_to_itfc_dof_gid(dof_gid))+1
             part_id = this%lst_parts_around_itfc_dofs(k,this%dof_gid_to_itfc_dof_gid(dof_gid))
             if ( part_id /= mypart_id ) then 
               local_part_id = cell_import%get_local_neighbour_id(part_id)
               if ( .not. touched_neighbours(local_part_id) ) then
                  touched_neighbours (local_part_id) = .true.
                  num_parts_nearest_neighbours = num_parts_nearest_neighbours + 1
                  parts_visited (num_parts_nearest_neighbours) = part_id
               end if
             end if
            end do
            call own_dofs_on_vef_iterator%next()
        end do

        if ( num_dofs_current_vef > 0 ) then
        
        call parts_neighbours_nearest_neighbours_visited%init(10)
        call lst_parts_neighbours_nearest_neighbours%resize(0)

        all_ghosts = .true.
        all_local  = .true.
        do ielem=1, vef%get_num_cells_around()
          call vef%get_cell_around(ielem,fe)
          if ( fe%is_local() ) then
            all_ghosts = .false.
          else
            all_local  = .false.
          end if
       
          if ( fe%is_ghost() ) then
            cell_gid = fe%get_gid()
            base_pos_dofs = this%ptr_dofs_field%get(cell_gid)-1
            ivef = fe%get_vef_lid_from_gid(vef%get_gid())
            call fe%get_field_fe_dofs( field_id, fe_dofs )
            reference_fe => fe%get_reference_fe(field_id)
            own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
            do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
              idof =  own_dofs_on_vef_iterator%get_current()
              dof_gid = fe_dofs(idof)
              if ( .not. this%is_free_dof(dof_gid) ) then
                 call own_dofs_on_vef_iterator%next()
                 cycle
              end if
              offset_dofs = 0  
              do jdof=1, idof-1
               offset_dofs = offset_dofs + p_num_parts_dofs_cell_wise(base_pos_dofs+jdof)
              end do
              start_pos = p_ptrs_to_rcv_lst_parts_dofs_cell_wise(cell_gid-triangulation%get_num_local_cells())-1
              do k=1, p_num_parts_dofs_cell_wise(base_pos_dofs+idof)
                part_id = p_rcv_lst_parts_dofs_cell_wise(start_pos+offset_dofs+k)
                assert (part_id > 0)
                if ( part_id /= mypart_id  ) then
                    if ( .not. cell_import%is_local_neighbour(part_id) ) then
                       call parts_neighbours_nearest_neighbours_visited%get(key=part_id,val=aux,stat=istat)
                       if ( istat == key_not_found ) then
                          num_parts_neighbours_nearest_neighbours = num_parts_neighbours_nearest_neighbours + 1
                          call parts_neighbours_nearest_neighbours_visited%put(key=part_id,val=aux,stat=istat)
                          assert ( istat == now_stored )
                          call lst_parts_neighbours_nearest_neighbours%push_back(part_id)
                       end if
                    else
                      local_part_id = cell_import%get_local_neighbour_id(part_id)
                      if ( .not. touched_neighbours(local_part_id) ) then
                        touched_neighbours (local_part_id) = .true.
                        num_parts_nearest_neighbours = num_parts_nearest_neighbours + 1
                        parts_visited (num_parts_nearest_neighbours) = part_id
                      end if  
                    end if
                end if
              end do 
              call own_dofs_on_vef_iterator%next()
            end do
          end if 
        end do

        init_col = current_col
        do idof=1, num_dofs_current_vef
           dof_gid = lst_dofs_current_vef(idof)
           ! If current DoF is only at ghost cells on my processor, then
           ! independently of the value of num_parts_local and 
           ! num_parts_neighbours_nearest_neighbours I will only introduce 
           ! a single non-owner connection in raw_interface_data
           if (all_ghosts) then 
              call dofs_gid%push_back(dof_gid)
              call dofs_max_part_id%push_back(max_part_id)
              call insert_new_itfc_coupling_in_raw_itfc_data(max_part_id, -1, dofs_ggid(dof_gid) )
              current_col = current_col + 1
           else
              do ipart=1, num_parts_nearest_neighbours
                 call dofs_gid%push_back(dof_gid)
                 call dofs_max_part_id%push_back(max_part_id)
                 part_id = parts_visited(ipart)
                 if (all_local) then
                    call insert_new_itfc_coupling_in_raw_itfc_data(part_id, -2, dofs_ggid(dof_gid) )
                 else
                    call insert_new_itfc_coupling_in_raw_itfc_data(part_id, num_parts_nearest_neighbours + &
                                                                            num_parts_neighbours_nearest_neighbours + 1, &
                                                                            dofs_ggid(dof_gid) )
                 end if
                 current_col = current_col + 1
              end do
              do ipart=1, num_parts_neighbours_nearest_neighbours
                 call dofs_gid%push_back(dof_gid)
                 call dofs_max_part_id%push_back(max_part_id)
                 part_id = lst_parts_neighbours_nearest_neighbours%get(ipart)
                 ! We believe that "all_local == .true. => num_parts_neighbours_nearest_neighbours == 0" is true.
                 ! In such a case, the if (all_local) statement is NOT required (only the else). We leave it here 
                 ! as a sanity-check
                 if (all_local) then
                    wassert ( num_parts_neighbours_nearest_neighbours == 0, "all_local == .true. => num_parts_neighbours_nearest_neighbours == 0 not TRUE!!!")
                    call insert_new_itfc_coupling_in_raw_itfc_data(part_id, -2, dofs_ggid(dof_gid) ) 
                 else
                    call insert_new_itfc_coupling_in_raw_itfc_data(part_id, num_parts_nearest_neighbours + &
                                                                            num_parts_neighbours_nearest_neighbours + 1, &
                                                                            dofs_ggid(dof_gid) )
                 end if
                 current_col = current_col + 1
              end do
           end if
        end do
     end if  
     call vef%next()
  end do

  call parts_neighbours_nearest_neighbours_visited%free()
  call lst_parts_neighbours_nearest_neighbours%free()

  call this%free_fe_cell_iterator(fe)
  call this%free_fe_vef_iterator(vef)

  ! Free touch arrays
  call memfree ( local_idof, __FILE__, __LINE__ )
  call memfree ( lst_dofs_current_vef, __FILE__, __LINE__ )
  call memfree ( parts_visited, __FILE__, __LINE__ )
  call memfree ( touched_neighbours, __FILE__, __LINE__ )
  call memfree ( dofs_ggid, __FILE__, __LINE__ )
  p_dofs_max_part_id => dofs_max_part_id%get_pointer()
  p_dofs_gid         => dofs_gid%get_pointer()
  call this%raw_interface_data_by_continuity_decide_owner (offset, &
       current_col-1, &
       raw_interface_data%a,&
       p_dofs_max_part_id,&
       p_dofs_gid )

  call dofs_max_part_id%free()
  num_itfc_couplings = current_col-1 

  call memalloc ( num_itfc_couplings, perm, __FILE__, __LINE__ )
  call memalloc ( num_itfc_couplings, buf , __FILE__, __LINE__ )
  start_col=1
  do i=1,num_itfc_couplings-1
     if ( raw_interface_data%a (neighbor_part_id_row,i) /= & 
          raw_interface_data%a (neighbor_part_id_row,i+1) ) then
        end_col   = i

        if (start_col < end_col) then
           k=1
           do j=start_col, end_col
              perm(j)=k
              k=k+1  
           end do

           call sort_array_cols_by_row_element( dof_gid_row, &
                num_rows_raw_interface_data, &
                end_col-start_col+1, &
                raw_interface_data%a(1:,start_col:end_col), &
                perm(start_col:end_col))

           buf(start_col:end_col) = dofs_gid%get_pointer(start_col,end_col)
           j=1
           do col=start_col, end_col 
              call dofs_gid%set(col, buf(start_col+perm(start_col+j-1)-1))
              j=j+1
           end do

        end if
        start_col = i+1 
     end if
  end do

  end_col=num_itfc_couplings
  if (start_col < end_col) then
     k=1
     do j=start_col, end_col
        perm(j)=k
        k=k+1
     end do

     call sort_array_cols_by_row_element( dof_gid_row, &
          num_rows_raw_interface_data, &
          end_col-start_col+1, &
          raw_interface_data%a(:,start_col:end_col), &
          perm(start_col:end_col))
     buf(start_col:end_col) = dofs_gid%get_pointer(start_col,end_col)
     j=1
     do col=start_col, end_col 
        call dofs_gid%set(col, buf(start_col+perm(start_col+j-1)-1))
        j=j+1
     end do
  end if
  call memfree ( perm, __FILE__, __LINE__ )
  call memfree ( buf , __FILE__, __LINE__ )
contains

  subroutine insert_new_itfc_coupling_in_raw_itfc_data ( neighbor_part_id, num_parts, dof_ggid )
    implicit none                                  
    integer(ip), intent(in)  :: neighbor_part_id
    integer(ip), intent(in)  :: num_parts
    integer(igp), intent(in) :: dof_ggid
    
    if ( current_col > raw_interface_data%nd2 ) then
       call raw_interface_data%resize( raw_interface_data%nd1, (raw_interface_data%nd2*3)/2+1 )
    end if
    raw_interface_data%a(neighbor_part_id_row, current_col) = neighbor_part_id
    raw_interface_data%a(owner_flag_row, current_col) = num_parts
    raw_interface_data%a(dof_gid_row, current_col) = dof_ggid
  end subroutine insert_new_itfc_coupling_in_raw_itfc_data                    
  
  
end function pfs_compute_raw_itfc_data_by_continuity_nc_mesh_rev


function pfs_compute_raw_itfc_data_by_continuity_non_conforming_mesh (  this, &
                                                                        field_id, &
                                                                        offset, &
                                                                        ubound_num_itfc_couplings, &
                                                                        dofs_gid, &
                                                                        raw_interface_data ) result(num_itfc_couplings)
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: field_id
  integer(ip)          , intent(in)    :: offset
  integer(ip)          , intent(in)    :: ubound_num_itfc_couplings
  integer(ip)          , intent(inout) :: dofs_gid(:)
  integer(igp)         , intent(inout) :: raw_interface_data(:, :)
  integer(ip)                          :: num_itfc_couplings

  ! Locals
  integer(ip)  :: istat
  integer(ip)  :: ivef, ivef_itfc, ielem, vef_gid
  integer(ip)  :: mypart_id, part_id
  integer(ip)  :: ivef_in_elem_id
  integer(ip)  :: idof, idof_interior, dof_gid
  integer(ip)  :: num_dofs_current_vef
  integer(ip)  :: col, init_col, current_col
  integer(ip)  :: num_parts_nearest_neighbour, num_parts_neighbours_nearest_neighbours, local_part_id, ipart

  integer(ip)               :: max_part_id
  integer(ip) , allocatable :: local_idof(:)  
  integer(ip) , allocatable :: lst_dofs_current_vef(:)
  integer(ip) , allocatable :: dofs_max_part_id(:)
  logical     , allocatable :: touched_neighbours(:)
  integer(ip), allocatable  :: parts_visited(:)

  type(environment_t), pointer :: environment
  class(triangulation_t), pointer :: triangulation
  type(cell_import_t), pointer :: cell_import
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t) :: own_dofs_on_vef_iterator
  type(fe_vef_iterator_t) :: vef
  class(fe_cell_iterator_t), allocatable :: fe, coarser_fe
  integer(ip), pointer :: fe_dofs(:)
  integer(ip) :: num_vefs
  integer(ip) :: cell_gid, base_pos_dofs, base_pos
  logical :: all_local, all_ghosts
  integer(igp) :: dof_ggid
  integer(ip), pointer :: p_ptr_ghosts_per_local_cell(:)
  integer(ip), pointer :: p_lst_ghosts_per_local_cell(:)
  integer(ip), pointer :: p_ptr_ghosts_per_ghost_cell(:)
  integer(ip), pointer :: p_lst_ghosts_per_ghost_cell(:)
  integer(ip), pointer :: p_rcv_my_part_id_vefs(:)
  integer(ip), pointer :: p_rcv_my_part_id_vefs_complete_itfc_couplings(:)
  integer(ip) :: i, j, k, ghost_part 
  integer(ip) :: aux
  type(hash_table_ip_ip_t) :: ghost_parts_visited
  type(std_vector_integer_ip_t) :: lst_parts
  integer(ip) :: start_col, end_col
  integer(ip) , allocatable :: perm(:)
  integer(igp), allocatable :: buf(:)
  integer(igp), allocatable :: dofs_ggid(:)
  logical :: first_fe_with_free_or_hanging_dofs_on_vef

  environment   => this%get_environment()
  triangulation => this%get_triangulation()
  cell_import   => triangulation%get_cell_import()
  assert ( environment%am_i_l1_task() )

  ! Allocate touch arrays (we could reduce memory consumption by using hash tables here)
  call memalloc ( this%block_layout%get_block_num_dofs(this%block_layout%get_block_id(field_id)), &
       local_idof, __FILE__, __LINE__ )
  call memalloc ( this%block_layout%get_block_num_dofs(this%block_layout%get_block_id(field_id)), &
       lst_dofs_current_vef, __FILE__, __LINE__ )
  call memalloc ( ubound_num_itfc_couplings, dofs_max_part_id, & 
       __FILE__, __LINE__ )

  call memalloc ( cell_import%get_num_neighbours(), &
       touched_neighbours, &
       __FILE__, __LINE__ )

  call memalloc ( cell_import%get_num_neighbours(), &
       parts_visited, &
       __FILE__, __LINE__ )

  call memalloc ( this%block_layout%get_block_num_dofs(this%block_layout%get_block_id(field_id)), &
       dofs_ggid, __FILE__, __LINE__ )

  mypart_id = environment%get_l1_rank() + 1

  current_col  = offset + 1
  local_idof   = 0

  p_ptr_ghosts_per_local_cell                   => this%ptr_ghosts_per_local_cell%get_pointer()
  p_lst_ghosts_per_local_cell                   => this%lst_ghosts_per_local_cell%get_pointer()
  p_ptr_ghosts_per_ghost_cell                   => this%ptr_ghosts_per_ghost_cell%get_pointer()
  p_lst_ghosts_per_ghost_cell                   => this%lst_ghosts_per_ghost_cell%get_pointer()
  p_rcv_my_part_id_vefs                         => this%rcv_my_part_id_vefs%get_pointer()
  p_rcv_my_part_id_vefs_complete_itfc_couplings => this%rcv_my_part_id_vefs_complete_itfc_couplings%get_pointer()

  ! Traverse vefs on the interface
  call this%create_itfc_fe_vef_iterator(vef)
  call this%create_fe_cell_iterator(fe) 
  call this%create_fe_cell_iterator(coarser_fe)
  if ( .not. fe%has_finished() ) then
    num_vefs = fe%get_num_vefs()
  else
    num_vefs = 0
  end if  
  do while(.not. vef%has_finished())
     if ( vef%all_coarser_cells_are_void(field_id,coarser_fe) ) then
        touched_neighbours = .false.
        num_parts_nearest_neighbour = 0
        num_parts_neighbours_nearest_neighbours = 0

        max_part_id = 0
        first_fe_with_free_or_hanging_dofs_on_vef = .true.

        all_ghosts = .true.
        all_local  = .true.
        num_dofs_current_vef = 0

        call ghost_parts_visited%init(100)
        call lst_parts%resize(0)

        ! Identify the total set of dofs in current vef
        do ielem=1, vef%get_num_cells_around()
           call vef%get_cell_around(ielem,fe)
           part_id = fe%get_my_part()
           ivef = fe%get_vef_lid_from_gid(vef%get_gid())
           call fe%get_field_fe_dofs( field_id, fe_dofs )
           reference_fe => fe%get_reference_fe(field_id)
           own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
           do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
              idof =  own_dofs_on_vef_iterator%get_current()
              dof_gid = fe_dofs(idof)
              if ( dof_gid == 0 .or. fe%is_strong_dirichlet_dof(dof_gid) ) then
                 call own_dofs_on_vef_iterator%next()
                 cycle
              end if

              if ( fe%is_local() ) then
                 all_ghosts = .false.
              else
                 all_local  = .false.
              end if

              if ( first_fe_with_free_or_hanging_dofs_on_vef ) then
                cell_gid    = fe%get_gid()
                base_pos    = (cell_gid-1)*num_vefs
                max_part_id = this%max_part_id_vefs%get(base_pos+ivef)
                first_fe_with_free_or_hanging_dofs_on_vef = .false.
              end if
              
              base_pos_dofs = this%ptr_dofs_field%get(fe%get_gid())-1
              dofs_ggid(dof_gid) = this%lst_dofs_ggids%get(base_pos_dofs+idof)

              if ( local_idof(dof_gid) == 0 ) then
                 num_dofs_current_vef = num_dofs_current_vef + 1    
                 lst_dofs_current_vef (num_dofs_current_vef) = dof_gid
                 local_idof(dof_gid) = idof
              end if
              if ( part_id /= mypart_id ) then 
                 local_part_id = cell_import%get_local_neighbour_id(part_id)
                 if ( .not. touched_neighbours(local_part_id) ) then
                    touched_neighbours (local_part_id) = .true.
                    num_parts_nearest_neighbour = num_parts_nearest_neighbour + 1
                    parts_visited (num_parts_nearest_neighbour) = part_id
                 end if
              end if
              call own_dofs_on_vef_iterator%next()
           end do

           if ( fe%is_local() ) then
              do j=p_ptr_ghosts_per_local_cell(fe%get_gid()), &
                   p_ptr_ghosts_per_local_cell(fe%get_gid()+1)-1
                 k = p_lst_ghosts_per_local_cell(j)
                 base_pos   = (k-1)*num_vefs
                 ghost_part = p_rcv_my_part_id_vefs(base_pos+ivef) 
                 if ( ghost_part > 0 .and. ghost_part /= mypart_id ) then
                    local_part_id = cell_import%get_local_neighbour_id(ghost_part)
                    if ( .not. touched_neighbours(local_part_id) ) then
                       touched_neighbours (local_part_id) = .true.
                       num_parts_nearest_neighbour = num_parts_nearest_neighbour + 1
                       parts_visited (num_parts_nearest_neighbour) = ghost_part
                    end if
                 end if
              end do
           else ! fe%is_ghost()
              do j=p_ptr_ghosts_per_ghost_cell(fe%get_gid()-triangulation%get_num_local_cells()), &
                   p_ptr_ghosts_per_ghost_cell(fe%get_gid()+1-triangulation%get_num_local_cells())-1
                 k = p_lst_ghosts_per_ghost_cell(j)
                 base_pos   = (k-1)*num_vefs
                 ghost_part = p_rcv_my_part_id_vefs_complete_itfc_couplings(base_pos+ivef)
                 if ( ghost_part > 0 .and. ghost_part /= mypart_id  ) then
                    if ( cell_import%is_local_neighbour(ghost_part) ) then
                       local_part_id = cell_import%get_local_neighbour_id(ghost_part)
                       if ( .not. touched_neighbours(local_part_id) ) then
                          touched_neighbours (local_part_id) = .true.
                          num_parts_nearest_neighbour = num_parts_nearest_neighbour + 1
                          parts_visited (num_parts_nearest_neighbour) = ghost_part
                       end if
                    else
                       call ghost_parts_visited%get(key=ghost_part,val=aux,stat=istat)
                       if ( istat == key_not_found ) then
                          num_parts_neighbours_nearest_neighbours = num_parts_neighbours_nearest_neighbours + 1
                          call ghost_parts_visited%put(key=ghost_part,val=aux,stat=istat)
                          assert ( istat == now_stored )
                          call lst_parts%push_back(ghost_part)
                       end if
                    end if
                 end if
              end do
           end if
        end do

        init_col = current_col
        do idof=1, num_dofs_current_vef
           dof_gid = lst_dofs_current_vef(idof)
           ! If current DoF is only at ghost cells on my processor, then
           ! independently of the value of num_parts_nearest_neighbour and 
           ! num_parts_neighbours_nearest_neighbours I will only introduce 
           ! a single non-owner connection in raw_interface_data
           if (all_ghosts) then 
              dofs_gid ( current_col ) = dof_gid 
              dofs_max_part_id ( current_col-offset ) = max_part_id 
              raw_interface_data(neighbor_part_id_row, current_col) = max_part_id
              raw_interface_data(dof_gid_row, current_col) = dofs_ggid(dof_gid) 
              raw_interface_data(owner_flag_row, current_col) = -1
              current_col = current_col + 1
           else
              do ipart=1, num_parts_nearest_neighbour
                 dofs_gid ( current_col ) = dof_gid 
                 dofs_max_part_id ( current_col-offset ) = max_part_id 
                 part_id = parts_visited(ipart)
                 raw_interface_data(neighbor_part_id_row, current_col) = part_id
                 raw_interface_data(dof_gid_row, current_col) = dofs_ggid(dof_gid)
                 if (all_local) then
                    raw_interface_data(owner_flag_row, current_col) = -2 
                 else
                    raw_interface_data(owner_flag_row, current_col) = num_parts_nearest_neighbour + num_parts_neighbours_nearest_neighbours + 1
                 end if
                 current_col = current_col + 1
              end do
              do ipart=1, num_parts_neighbours_nearest_neighbours
                 dofs_gid ( current_col ) = dof_gid
                 dofs_max_part_id ( current_col-offset ) = max_part_id
                 part_id = lst_parts%get(ipart)
                 raw_interface_data(neighbor_part_id_row, current_col) = part_id
                 raw_interface_data(dof_gid_row, current_col) = dofs_ggid(dof_gid)
                 ! We believe that "all_local == .true. => num_parts_neighbours_nearest_neighbours == 0" is true.
                 ! In such a case, the if (all_local) statement is NOT required (only the else). We leave it here 
                 ! as a sanity-check
                 if (all_local) then
                    wassert ( num_parts_neighbours_nearest_neighbours == 0, "all_local == .true. => num_parts_neighbours_nearest_neighbours == 0 not TRUE!!!")
                    raw_interface_data(owner_flag_row, current_col) = -2 
                 else
                     raw_interface_data(owner_flag_row, current_col) = num_parts_nearest_neighbour + num_parts_neighbours_nearest_neighbours + 1
                 end if
                 current_col = current_col + 1
              end do
           end if
        end do
     end if
     call vef%next()
  end do

  call ghost_parts_visited%free()
  call lst_parts%free()

  call this%free_fe_cell_iterator(coarser_fe)
  call this%free_fe_cell_iterator(fe)
  call this%free_fe_vef_iterator(vef)

  ! Free touch arrays
  call memfree ( local_idof, __FILE__, __LINE__ )
  call memfree ( lst_dofs_current_vef, __FILE__, __LINE__ )
  call memfree ( parts_visited, __FILE__, __LINE__ )
  call memfree ( touched_neighbours, __FILE__, __LINE__ )
  call memfree ( dofs_ggid, __FILE__, __LINE__ )

  call this%raw_interface_data_by_continuity_decide_owner (offset, &
       current_col-1, &
       raw_interface_data,&
       dofs_max_part_id,&
       dofs_gid)

  call memfree ( dofs_max_part_id, __FILE__, __LINE__ )
  num_itfc_couplings = current_col-1 

  call memalloc ( num_itfc_couplings, perm, __FILE__, __LINE__ )
  call memalloc ( num_itfc_couplings, buf , __FILE__, __LINE__ )
  start_col=1
  do i=1,num_itfc_couplings-1
     if ( raw_interface_data (neighbor_part_id_row,i) /= & 
          raw_interface_data (neighbor_part_id_row,i+1) ) then
        end_col   = i
        if (start_col < end_col) then
           k=1
           do j=start_col, end_col
              perm(j)=k
              k=k+1  
           end do

           call sort_array_cols_by_row_element( dof_gid_row, &
                num_rows_raw_interface_data, &
                end_col-start_col+1, &
                raw_interface_data(1:,start_col:end_col), &
                perm(start_col:end_col))

           buf(start_col:end_col) = dofs_gid(start_col:end_col)
           j=1
           do col=start_col, end_col 
              dofs_gid(col) = buf(start_col+perm(start_col+j-1)-1)
              j=j+1
           end do

        end if
        start_col = i+1 
     end if
  end do

  end_col=num_itfc_couplings
  if (start_col < end_col) then
     k=1
     do j=start_col, end_col
        perm(j)=k
        k=k+1
     end do

     call sort_array_cols_by_row_element( dof_gid_row, &
          num_rows_raw_interface_data, &
          end_col-start_col+1, &
          raw_interface_data(1:,start_col:end_col), &
          perm(start_col:end_col))
     buf(start_col:end_col) = dofs_gid(start_col:end_col)
     j=1
     do col=start_col, end_col 
        dofs_gid(col) = buf(start_col+perm(start_col+j-1)-1)
        j=j+1
     end do
  end if
  call memfree ( perm, __FILE__, __LINE__ )
  call memfree ( buf , __FILE__, __LINE__ )
end function pfs_compute_raw_itfc_data_by_continuity_non_conforming_mesh


subroutine par_fe_space_raw_interface_data_by_continuity_decide_owner ( this, &
                                                                        offset, &
                                                                        num_cols, &
                                                                        raw_interface_data, &
                                                                        dofs_max_part_id,  &
                                                                        dofs_gid)
  implicit none
  class(par_fe_space_t), intent(in)    :: this
  integer(ip)          , intent(in)    :: offset
  integer(ip)          , intent(in)    :: num_cols
  integer(igp)         , intent(inout) :: raw_interface_data(:,:)
  integer(ip)          , intent(inout) :: dofs_max_part_id(:)
  integer(ip)          , intent(inout) :: dofs_gid(:)

  integer(igp)                 :: l1(num_rows_raw_interface_data), l2(num_rows_raw_interface_data)
  integer(ip) , allocatable    :: perm(:)
  integer(ip) , allocatable    :: aux(:)
  integer(ip)                  :: start_col, end_col, col, mypart_id, ipart_max, j, size
  type(environment_t), pointer :: environment


  !do col=1,num_cols
  !  write(*,"(10i10)") col, dofs_gid(col), dofs_max_part_id(col), raw_interface_data(:,col)
  !end do 
  !write(*,*) '============================================================================='

  if ( num_cols-offset == 0 ) return
  
  call memalloc ( num_cols-offset, aux, __FILE__, __LINE__ )
  call memalloc ( num_cols-offset, perm, __FILE__, __LINE__ )
  do col=1, num_cols-offset
     perm(col) = col
  end do

  ! Re-number interface DoF couplings in increasing order by neighbour part id, the
  ! number of neighbour parts around, and e_max + local_pos_dof_in_emax
  call sort_array_cols_by_row_section( num_rows_raw_interface_data, &
                                       num_rows_raw_interface_data, &
                                       num_cols-offset, &
                                       raw_interface_data(1:,offset+1:num_cols), &
                                       perm, &
                                       l1, &
                                       l2)

  aux = dofs_max_part_id(1:num_cols-offset)
  do col=1, num_cols-offset
     dofs_max_part_id(col) = aux(perm(col))
  end do

  aux = dofs_gid(offset+1:num_cols)
  do col=1, num_cols-offset
     dofs_gid(offset+col) = aux(perm(col))
  end do

  call memfree ( perm, __FILE__, __LINE__ )
  call memfree ( aux, __FILE__, __LINE__ )

  environment => this%get_environment()
  mypart_id = environment%get_l1_rank() + 1

  col = offset + 1
  do while ( col <= num_cols ) 
     ! If DoF (only) on ghost cells then non owner 
     if (raw_interface_data ( owner_flag_row, col ) == -1) then
        raw_interface_data ( owner_flag_row, col) = non_owner 
        col = col + 1
     ! If DoF (only) on local cells then owner 
     else if (raw_interface_data ( owner_flag_row, col ) == -2) then
        raw_interface_data ( owner_flag_row, col) = owner    
        col = col + 1
     else if ( raw_interface_data ( owner_flag_row, col ) == 2 ) then
        start_col = col
        do while ( ( raw_interface_data ( owner_flag_row, col ) == 2).and. &
             &          ( raw_interface_data ( neighbor_part_id_row, col ) == raw_interface_data ( neighbor_part_id_row, start_col ) ) )
           col = col + 1
           if ( col > num_cols ) exit
        end do
        end_col = col - 1

        ipart_max = dofs_max_part_id(start_col-offset)
        size = end_col - start_col + 1
        if ( mypart_id == ipart_max ) then
           do j= start_col, start_col + size/2 -1
              raw_interface_data ( owner_flag_row, j) = owner
           end do
           do j= start_col + size/2,  end_col
              raw_interface_data ( owner_flag_row, j) = non_owner
           end do
        else
           do j= start_col, start_col + size/2 -1
              raw_interface_data ( owner_flag_row, j) = non_owner
           end do
           do j= start_col + size/2,  end_col
              raw_interface_data ( owner_flag_row, j) = owner
           end do
        end if
     else
        if ( mypart_id == dofs_max_part_id(col-offset) ) then
           raw_interface_data ( owner_flag_row, col) = owner
        else
           if ( raw_interface_data ( neighbor_part_id_row, col) == dofs_max_part_id(col-offset) ) then
              raw_interface_data ( owner_flag_row, col) = non_owner
           else
              raw_interface_data ( owner_flag_row, col) = uncoupled
           end if
        end if
        col = col + 1
     end if
  end do

  !do col=1,num_cols
  !  write(*,"(10i10)") col, dofs_gid(col), dofs_max_part_id(col), raw_interface_data(:,col)
  !end do 

end subroutine par_fe_space_raw_interface_data_by_continuity_decide_owner

subroutine pfs_compute_lst_parts_around_itfc_dofs(this, &
                                                  field_id )
  implicit none
  class(par_fe_space_t)   , intent(inout)    :: this
  integer(ip)             , intent(in)       :: field_id

  
  class(fe_cell_iterator_t), allocatable :: fe 
  type(fe_vef_iterator_t) :: vef 
  class(triangulation_t), pointer :: triangulation
  type(cell_import_t), pointer :: cell_import
  class(environment_t), pointer :: environment
  integer(ip) :: num_parts_around
 

  integer(ip) :: block_id
  integer(ip) :: num_blk_proper_dofs
  integer(ip) :: num_blk_improper_dofs
  integer(ip) :: num_itfc_dofs
  integer(ip) :: current_itfc_dof
  integer(ip) :: part_id
  integer(ip) :: local_part_id
  integer(ip) :: mypart_id
  integer(ip) :: ielem
  integer(ip) :: idof
  integer(ip) :: ivef
  integer(ip) :: dof_gid
  integer(ip) :: num_parts
 
  logical, allocatable :: touched_neighbours(:)
  integer(ip), allocatable :: parts_visited(:)
  integer(ip), pointer :: fe_dofs(:)
  logical :: dofs_found
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t) :: own_dofs_on_vef_iterator

  call this%free_lst_parts_around_itfc_dofs()
  
  triangulation => this%get_triangulation()
  cell_import   => triangulation%get_cell_import()
  environment   => triangulation%get_environment()
  num_parts_around = cell_import%get_num_neighbours()+1

  call this%create_itfc_fe_vef_iterator(vef)
  call this%create_fe_cell_iterator(fe) 
  
  block_id = this%block_layout%get_block_id(field_id)
  num_blk_proper_dofs    = this%block_layout%get_block_num_dofs(block_id)
  num_blk_improper_dofs  = this%ptr_constraining_free_dofs%size()-1 
  call memalloc(num_blk_proper_dofs+num_blk_improper_dofs,&
                this%dof_gid_to_itfc_dof_gid, __FILE__, __LINE__ )
  call count_itfc_dofs_and_fill_dof_gid_to_itfc_dof_gid()
  
  ! Allocate and initialize lst_parts_around_itfc_dofs
  num_parts_around = cell_import%get_num_neighbours()+1
  call memalloc ( num_parts_around+1, &
                  num_itfc_dofs, &
                  this%lst_parts_around_itfc_dofs, __FILE__, __LINE__ )
  
  call memalloc ( num_itfc_dofs, this%itfc_dof_gid_to_dof_gid, __FILE__, __LINE__ )
  
  ! Fill lst_parts_around_itfc_dofs_using_cells_around()
  call fill_lst_parts_around_itfc_dofs_using_cells_around()
  
  call complete_lst_parts_around_itfc_dofs_using_constraints()
  
  call this%free_fe_vef_iterator(vef)
  call this%free_fe_cell_iterator(fe)
contains
  subroutine count_itfc_dofs_and_fill_dof_gid_to_itfc_dof_gid()
    implicit none
    num_itfc_dofs   = 0
    this%dof_gid_to_itfc_dof_gid=-1
    call vef%first()
    do while(.not. vef%has_finished())
       dofs_found = .false.
       do ielem=1, vef%get_num_cells_around()
          call vef%get_cell_around(ielem,fe)
          ivef = fe%get_vef_lid_from_gid(vef%get_gid())
          reference_fe => fe%get_reference_fe(field_id)
          call fe%get_field_fe_dofs( field_id, fe_dofs )
          own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
          do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
             idof =  own_dofs_on_vef_iterator%get_current()
             dof_gid = fe_dofs(idof)
             if ( dof_gid == 0 .or. this%is_strong_dirichlet_dof(dof_gid) ) then
                call own_dofs_on_vef_iterator%next()
                cycle
             end if

             dofs_found = .true.
             if ( this%dof_gid_to_itfc_dof_gid(get_consecutive_dof_gid(dof_gid)) ==-1) then
                num_itfc_dofs = num_itfc_dofs+1    
                this%dof_gid_to_itfc_dof_gid(get_consecutive_dof_gid(dof_gid))=num_itfc_dofs 
             end if
             call own_dofs_on_vef_iterator%next()
          end do
          if (dofs_found) exit 
       end do
       call vef%next()
    end do
  end subroutine count_itfc_dofs_and_fill_dof_gid_to_itfc_dof_gid

  subroutine fill_lst_parts_around_itfc_dofs_using_cells_around()
    implicit none
    this%lst_parts_around_itfc_dofs = 0
    call memalloc ( cell_import%get_num_neighbours(), &
         touched_neighbours, &
         __FILE__, __LINE__ )

    call memalloc ( cell_import%get_num_neighbours(), &
         parts_visited, &
         __FILE__, __LINE__ )

    mypart_id = environment%get_l1_rank() + 1
    current_itfc_dof = 1
    call vef%first()
    do while(.not. vef%has_finished())
       touched_neighbours = .false.
       num_parts = 0 
       dofs_found = .false.
       ! Retrieve parts around current vef
       do ielem=1, vef%get_num_cells_around()
          call vef%get_cell_around(ielem,fe)
          if ( .not. fe%is_void(field_id) ) then
            part_id = fe%get_my_part()
            if ( part_id /= mypart_id ) then
               local_part_id = cell_import%get_local_neighbour_id(part_id)
               if ( .not. touched_neighbours(local_part_id) ) then
                  touched_neighbours (local_part_id) = .true.
                  num_parts = num_parts + 1
                  parts_visited (num_parts) = part_id
               end if
            end if
          end if
       end do

       ! Go over DoFs around current vef and list parts around
       do ielem=1, vef%get_num_cells_around()
          call vef%get_cell_around(ielem,fe)
          ivef = fe%get_vef_lid_from_gid(vef%get_gid())
          call fe%get_field_fe_dofs( field_id, fe_dofs )
          reference_fe => fe%get_reference_fe(field_id)
          own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
          do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
             idof =  own_dofs_on_vef_iterator%get_current()
             dof_gid = fe_dofs(idof)
             if ( dof_gid == 0 .or. this%is_strong_dirichlet_dof(dof_gid) ) then
                call own_dofs_on_vef_iterator%next()
                cycle
             end if

             this%lst_parts_around_itfc_dofs(1,current_itfc_dof) = num_parts + 1 
             this%lst_parts_around_itfc_dofs(2,current_itfc_dof) = mypart_id
             this%lst_parts_around_itfc_dofs(3:num_parts+2,current_itfc_dof) = parts_visited(1:num_parts)
             
             this%itfc_dof_gid_to_dof_gid(current_itfc_dof) = dof_gid
             current_itfc_dof = current_itfc_dof + 1 
             dofs_found = .true.

             call own_dofs_on_vef_iterator%next()
          end do
          if (dofs_found) exit 
       end do
       call vef%next()
    end do
    call memfree ( parts_visited, __FILE__, __LINE__ )
    call memfree ( touched_neighbours, __FILE__, __LINE__ )
  end subroutine fill_lst_parts_around_itfc_dofs_using_cells_around
  
  subroutine complete_lst_parts_around_itfc_dofs_using_constraints()
    implicit none
    integer(ip) :: free_dof_gid
    integer(ip) :: pos
    integer(ip) :: source_col
    integer(ip) :: target_col
    integer(ip) :: i 
    integer(ip) :: pos_in_ptr
    do i=1, num_itfc_dofs
      dof_gid=this%itfc_dof_gid_to_dof_gid(i)
      if (this%is_hanging_dof(dof_gid)) then
        pos_in_ptr= abs(dof_gid)-this%num_dirichlet_dofs
        do pos=this%ptr_constraining_free_dofs%get(pos_in_ptr), this%ptr_constraining_free_dofs%get(pos_in_ptr+1)-1 
          free_dof_gid = this%constraining_free_dofs%get(pos)
          source_col = this%dof_gid_to_itfc_dof_gid(get_consecutive_dof_gid(dof_gid))
          target_col = this%dof_gid_to_itfc_dof_gid(free_dof_gid)
          assert ( source_col /= -1 .and. target_col /= -1 )
          call merge_lst_parts_around_itfc_dofs_cols (source_col, target_col)
        end do
      end if
    end do
  end subroutine complete_lst_parts_around_itfc_dofs_using_constraints
  
  subroutine merge_lst_parts_around_itfc_dofs_cols ( source_col, target_col )
    implicit none
    integer(ip), intent(in) :: source_col
    integer(ip), intent(in) :: target_col
    integer(ip) :: num_parts_col1
    integer(ip) :: num_parts_col2
    integer(ip) :: part_id_col1
    integer(ip) :: part_id_col2
    integer(ip) :: i, j
    logical :: found
    num_parts_col2=this%lst_parts_around_itfc_dofs(1,source_col)
    do i=2,num_parts_col2+1
       part_id_col2=this%lst_parts_around_itfc_dofs(i,source_col)
       found = .false.
       num_parts_col1=this%lst_parts_around_itfc_dofs(1,target_col)
       do j=2,num_parts_col1+1
         part_id_col1=this%lst_parts_around_itfc_dofs(j,target_col)
         if ( part_id_col1 == part_id_col2 ) then
           found = .true.
           exit
         end if
       end do
       if ( .not. found ) then
         this%lst_parts_around_itfc_dofs(1,target_col) = this%lst_parts_around_itfc_dofs(1,target_col) + 1 
         this%lst_parts_around_itfc_dofs(this%lst_parts_around_itfc_dofs(1,target_col)+1,target_col) = part_id_col2  
       end if
    end do 
  end subroutine merge_lst_parts_around_itfc_dofs_cols
  
  function get_consecutive_dof_gid(dof_gid)
    implicit none
    integer(ip), intent(in) :: dof_gid
    integer(ip) :: get_consecutive_dof_gid
    get_consecutive_dof_gid = abs(dof_gid)
    if ( this%is_hanging_dof(dof_gid) ) then
       get_consecutive_dof_gid = (get_consecutive_dof_gid-this%num_dirichlet_dofs) + num_blk_proper_dofs  
    end if
  end function get_consecutive_dof_gid
end subroutine pfs_compute_lst_parts_around_itfc_dofs

subroutine pfs_free_lst_parts_around_itfc_dofs(this)
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  if ( allocated(this%dof_gid_to_itfc_dof_gid) ) then
    call memfree(this%dof_gid_to_itfc_dof_gid, __FILE__, __LINE__ )
  end if
  if ( allocated(this%lst_parts_around_itfc_dofs) ) then
    call memfree(this%lst_parts_around_itfc_dofs, __FILE__, __LINE__ )
  end if
  if ( allocated(this%itfc_dof_gid_to_dof_gid) ) then
    call memfree(this%itfc_dof_gid_to_dof_gid, __FILE__, __LINE__ )
  end if
end subroutine pfs_free_lst_parts_around_itfc_dofs

subroutine pfs_compute_max_part_id_and_dofs_ggids_field(this, field_id)
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: field_id
  
  class(environment_t)  , pointer :: environment
  class(triangulation_t), pointer :: triangulation
  type(cell_import_t)   , pointer :: cell_import
  class(reference_fe_t) , pointer :: reference_fe
  type(list_iterator_t) :: own_dofs_on_vef_iterator
  type(fe_vef_iterator_t) :: vef
  class(fe_cell_iterator_t), allocatable :: fe, coarser_fe
  integer(ip), pointer :: fe_dofs(:)
  integer(ip) :: ielem, part_id, ivef, dof_gid
  integer(ip) :: mypart_id, max_part_id, idof
  logical :: no_local_cell_around_free_dof
  logical :: free_dofs 
  integer(ip) :: cell_gid
  integer(ip) :: num_vefs
  integer(ip) :: num_dofs
  integer(ip) :: base_pos, base_pos_dofs
  integer(ip), pointer :: p_max_part_id_vefs(:)
  integer(igp), pointer :: p_lst_dofs_ggids(:)
  integer(ip)  :: i
  integer(igp) :: elem_ggid
  integer(igp) :: max_elem_ggid
  integer(ip), allocatable :: local_idof(:)
  
  triangulation => this%get_triangulation()
  environment   => triangulation%get_environment()
  cell_import   => triangulation%get_cell_import()
  
  call memalloc ( this%block_layout%get_block_num_dofs(this%block_layout%get_block_id(field_id)), &
                  local_idof, __FILE__, __LINE__ )
  
  ! Initialization of DoFs data structures
  call this%ptr_dofs_field%resize(1)
  call this%ptr_dofs_field%set(1,1)
  i=2
  call this%create_fe_cell_iterator(fe)
  call this%create_fe_cell_iterator(coarser_fe)
  do while ( .not. fe%has_finished() )
    num_dofs = fe%get_num_dofs_field(field_id)
    call this%ptr_dofs_field%push_back(this%ptr_dofs_field%get(i-1)+num_dofs)  
    call fe%next()
    i=i+1
  end do
  call this%lst_dofs_ggids%resize(0)
  call this%lst_dofs_ggids%resize(this%ptr_dofs_field%get(triangulation%get_num_cells()+1)-1,-1_igp)
  
  call fe%first()
  if ( .not. fe%has_finished() ) then
    num_vefs = fe%get_num_vefs()
  else
    num_vefs = 0
  end if   
  
  call this%max_part_id_vefs%resize(0) 
  call this%max_part_id_vefs%resize(triangulation%get_num_cells()*num_vefs,0) 
    
  mypart_id = environment%get_l1_rank()+1
    
  ! Traverse vefs on the interface
  call this%create_itfc_fe_vef_iterator(vef)
  do while(.not. vef%has_finished())
    if ( vef%all_coarser_cells_are_void(field_id,coarser_fe) ) then
      no_local_cell_around_free_dof = .true.
      free_dofs = .false. 
      max_part_id = mypart_id 
      max_elem_ggid = 0_igp
      do ielem=1, vef%get_num_cells_around()
        call vef%get_cell_around(ielem,fe)
        elem_ggid = fe%get_ggid()
        part_id = fe%get_my_part()
        ivef = fe%get_vef_lid_from_gid(vef%get_gid())
        cell_gid = fe%get_gid()
        base_pos = (cell_gid-1)*num_vefs
        call fe%get_field_fe_dofs( field_id, fe_dofs )
        reference_fe => fe%get_reference_fe(field_id)
        own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
        do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
           idof = own_dofs_on_vef_iterator%get_current()
           dof_gid = fe_dofs(idof)
           if ( dof_gid == 0 .or. this%is_strong_dirichlet_dof(dof_gid) ) then
             call own_dofs_on_vef_iterator%next()
             cycle
           end if
           free_dofs = .true.
           if ( fe%is_local() ) then 
             no_local_cell_around_free_dof = .false.
           end if
           if ( elem_ggid >= max_elem_ggid ) then
             max_elem_ggid = elem_ggid
             local_idof(dof_gid) = idof
           end if
           if ( part_id /= mypart_id ) then
              max_part_id = max(part_id, max_part_id)
           end if
           call own_dofs_on_vef_iterator%next()
        end do
      end do
      
      ! If all parts around a given proper vef are ghost, then 
      ! mypart_id CANNOT become the owner of the DoFs on top of it
      if ( no_local_cell_around_free_dof .and. free_dofs ) then
         call vef%next()
         cycle
      else if ( .not. free_dofs ) then     
         call vef%next()
         cycle
      end if  
      
      do ielem=1, vef%get_num_cells_around()
        call vef%get_cell_around(ielem,fe)
        
        ! Compute this%max_part_id_vefs
        ivef = fe%get_vef_lid_from_gid(vef%get_gid())
        cell_gid = fe%get_gid()
        base_pos = (cell_gid-1)*num_vefs
        
        ! Compute this%lst_dofs_ggids
        call fe%get_field_fe_dofs( field_id, fe_dofs )
        reference_fe => fe%get_reference_fe(field_id)
        own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
        do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
           idof    = own_dofs_on_vef_iterator%get_current()
           dof_gid = fe_dofs(idof)
           if ( dof_gid == 0 .or. this%is_strong_dirichlet_dof(dof_gid) ) then
             call own_dofs_on_vef_iterator%next()
             cycle
           end if
           call this%max_part_id_vefs%set(base_pos+ivef, max_part_id)
                      
           base_pos_dofs = this%ptr_dofs_field%get(fe%get_gid())-1
           call this%lst_dofs_ggids%set(base_pos_dofs+idof, this%generate_non_consecutive_dof_ggid(max_elem_ggid, &
                                                                                                   local_idof(dof_gid), &
                                                                                                   field_id))
           call own_dofs_on_vef_iterator%next()
        end do
      end do  
    end if
    call vef%next()
  end do
  
  p_max_part_id_vefs => this%max_part_id_vefs%get_pointer()
  call environment%l1_neighbours_exchange ( cell_import%get_num_neighbours(), &
                                            cell_import%get_neighbours_ids(),&
                                            cell_import%get_rcv_ptrs(),&
                                            cell_import%get_rcv_leids(),&
                                            cell_import%get_num_neighbours(), &
                                            cell_import%get_neighbours_ids(),&
                                            cell_import%get_snd_ptrs(),&
                                            cell_import%get_snd_leids(),&
                                            p_max_part_id_vefs, & 
                                            p_max_part_id_vefs, &
                                            num_vefs)
  
  p_lst_dofs_ggids => this%lst_dofs_ggids%get_pointer()
  call environment%l1_neighbours_exchange ( cell_import%get_num_neighbours(), &
                                            cell_import%get_neighbours_ids(),&
                                            cell_import%get_rcv_ptrs(),&
                                            cell_import%get_rcv_leids(),&
                                            cell_import%get_num_neighbours(), &
                                            cell_import%get_neighbours_ids(),&
                                            cell_import%get_snd_ptrs(),&
                                            cell_import%get_snd_leids(),&
                                            p_lst_dofs_ggids, & 
                                            p_lst_dofs_ggids, &
                                            this%ptr_dofs_field%get_pointer()) 
  call this%free_fe_cell_iterator(coarser_fe)
  call this%free_fe_cell_iterator(fe)
  call this%free_fe_vef_iterator(vef)
  call memfree ( local_idof, __FILE__, __LINE__ )
end subroutine pfs_compute_max_part_id_and_dofs_ggids_field

subroutine pfs_fetch_num_parts_dofs_cell_wise(this, field_id)
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: field_id
  class(fe_cell_iterator_t), allocatable :: fe
  type(fe_vef_iterator_t) :: vef
  class(environment_t), pointer :: environment
  class(triangulation_t), pointer :: triangulation
  type(cell_import_t), pointer :: cell_import
  integer(ip) :: ielem, base_pos, cell_gid, ivef
  integer(ip), pointer :: p_num_parts_dofs_cell_wise(:)
  integer(ip), pointer :: p_ptr_dofs_field(:)
  integer(ip), pointer :: fe_dofs(:)
  type(list_iterator_t) :: own_dofs_on_vef_iterator
  class(reference_fe_t), pointer :: reference_fe
  integer(ip) :: dof_gid, idof
  
  triangulation   => this%get_triangulation()
  
  call this%num_parts_dofs_cell_wise%resize(0)
  call this%num_parts_dofs_cell_wise%resize(this%ptr_dofs_field%get(triangulation%get_num_cells()+1)-1,0) 
  p_num_parts_dofs_cell_wise => this%num_parts_dofs_cell_wise%get_pointer()
  p_ptr_dofs_field           => this%ptr_dofs_field%get_pointer()
  
  ! For each proper vef on the interface, go over its local cells, and
  ! assign the number of parts it is around on a cell-wise manner
  call this%create_fe_cell_iterator(fe)
  call this%create_itfc_fe_vef_iterator(vef)
  do while(.not. vef%has_finished())
      do ielem=1, vef%get_num_cells_around()
        call vef%get_cell_around(ielem,fe)        
        if ( fe%is_local() ) then
          ivef = fe%get_vef_lid_from_gid(vef%get_gid())
          cell_gid = fe%get_gid()
          base_pos = p_ptr_dofs_field(cell_gid)-1
          
          reference_fe => fe%get_reference_fe(field_id)
          call fe%get_field_fe_dofs( field_id, fe_dofs )
          
          own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
          do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
             idof =  own_dofs_on_vef_iterator%get_current()
             dof_gid = fe_dofs(idof)
             if ( dof_gid == 0 .or. this%is_strong_dirichlet_dof(dof_gid) ) then
                call own_dofs_on_vef_iterator%next()
                cycle
             end if
             if ( this%is_free_dof(dof_gid) ) then
               p_num_parts_dofs_cell_wise(base_pos+idof) = this%lst_parts_around_itfc_dofs(1,this%dof_gid_to_itfc_dof_gid(dof_gid))
             end if
             
             call own_dofs_on_vef_iterator%next()
          end do
        end if
      end do
    call vef%next()
  end do 
  call this%free_fe_vef_iterator(vef)
  call this%free_fe_cell_iterator(fe)

  environment     => this%get_environment()
  cell_import     => triangulation%get_cell_import()
  call environment%l1_neighbours_exchange ( num_rcv        = cell_import%get_num_neighbours(), &
                                            list_rcv       = cell_import%get_neighbours_ids(),&
                                            rcv_ptrs       = cell_import%get_rcv_ptrs(),&
                                            unpack_idx     = cell_import%get_rcv_leids(), &
                                            num_snd        = cell_import%get_num_neighbours(), &
                                            list_snd       = cell_import%get_neighbours_ids(),&
                                            snd_ptrs       = cell_import%get_snd_ptrs(),&
                                            pack_idx       = cell_import%get_snd_leids(),&
                                            x              = p_num_parts_dofs_cell_wise, &
                                            y              = p_num_parts_dofs_cell_wise, &
                                            ptr_chunk_size = this%ptr_dofs_field%get_pointer())
end subroutine pfs_fetch_num_parts_dofs_cell_wise

subroutine pfs_compute_near_neigh_ctrl_data_lst_parts(this, field_id)
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: field_id
  
  integer(ip), pointer :: snd_ptrs(:)
  integer(ip), pointer :: snd_leids(:)
  integer(ip), pointer :: rcv_ptrs(:)
  integer(ip), pointer :: rcv_leids(:)
  
  integer(ip), pointer :: p_snd_ptrs_lst_parts_cell_wise(:)
  integer(ip), pointer :: p_rcv_ptrs_lst_parts_cell_wise(:)
  integer(ip), pointer :: p_num_parts_dofs_cell_wise(:)
  integer(ip), pointer :: p_ptr_dofs_field(:)

  
  integer(ip) :: i, j, k, l, m, n, icell, current
  integer(ip) :: cell_gid, ghost_cell_gid
  integer(ip) :: start_pos, end_pos, num_parts
  class(triangulation_t), pointer :: triangulation
  type(cell_import_t), pointer :: cell_import

  
  triangulation => this%get_triangulation()
  cell_import   => triangulation%get_cell_import()
  
  ! Init send data structures
  call this%snd_ptrs_lst_parts_cell_wise%resize(0)
  call this%snd_ptrs_lst_parts_cell_wise%resize(cell_import%get_num_neighbours()+1,0)
  p_snd_ptrs_lst_parts_cell_wise => this%snd_ptrs_lst_parts_cell_wise%get_pointer()
  call this%lst_parts_pack_idx_cell_wise%resize(0)
  
  p_num_parts_dofs_cell_wise => this%num_parts_dofs_cell_wise%get_pointer()
  snd_ptrs  => cell_import%get_snd_ptrs()
  snd_leids => cell_import%get_snd_leids()
  p_ptr_dofs_field => this%ptr_dofs_field%get_pointer()
  current = 1 
  ! Compute send data structures 
  do i=1, cell_import%get_num_neighbours()
     do j=snd_ptrs(i), snd_ptrs(i+1)-1
        k=snd_leids(j)
        start_pos =  p_ptr_dofs_field(k)        ! (k-1)*num_dofs+1
        end_pos   =  p_ptr_dofs_field(k+1) -1   ! (k  )*num_dofs
        num_parts = 0
        do m=start_pos, end_pos
          num_parts=num_parts+p_num_parts_dofs_cell_wise(m)
        end do
             
        do m=1, num_parts
         call this%lst_parts_pack_idx_cell_wise%push_back(current)
         current = current + 1
        end do  
             
        p_snd_ptrs_lst_parts_cell_wise(i+1) = &
            p_snd_ptrs_lst_parts_cell_wise(i+1) + num_parts
     end do 
  end do
  
  p_snd_ptrs_lst_parts_cell_wise(1)=1
  do i=1, cell_import%get_num_neighbours()
    p_snd_ptrs_lst_parts_cell_wise(i+1) = p_snd_ptrs_lst_parts_cell_wise(i+1) + &
                                              p_snd_ptrs_lst_parts_cell_wise(i)
  end do 
  
  !! 2. "Recv side"
  rcv_ptrs  => cell_import%get_rcv_ptrs()
  rcv_leids => cell_import%get_rcv_leids()
  call this%rcv_ptrs_lst_parts_cell_wise%resize(cell_import%get_num_neighbours()+1,0)
  p_rcv_ptrs_lst_parts_cell_wise => this%rcv_ptrs_lst_parts_cell_wise%get_pointer()
  p_rcv_ptrs_lst_parts_cell_wise = 0
  do i=1, cell_import%get_num_neighbours()
   do j=rcv_ptrs(i), rcv_ptrs(i+1)-1
     k=rcv_leids(j)
     start_pos = p_ptr_dofs_field(k)      ! (k-1)*num_dofs+1
     end_pos   = p_ptr_dofs_field(k+1) -1 ! (k  )*num_dofs
     num_parts=0
     do m=start_pos, end_pos 
       num_parts=num_parts+p_num_parts_dofs_cell_wise(m)
     end do
     p_rcv_ptrs_lst_parts_cell_wise(i+1) = & 
        p_rcv_ptrs_lst_parts_cell_wise(i+1) + num_parts
   end do
  end do 
  ! Length to header
  p_rcv_ptrs_lst_parts_cell_wise(1)=1
  do i=1,cell_import%get_num_neighbours()
    p_rcv_ptrs_lst_parts_cell_wise(i+1) = & 
      p_rcv_ptrs_lst_parts_cell_wise(i+1)+p_rcv_ptrs_lst_parts_cell_wise(i) 
  end do
end subroutine pfs_compute_near_neigh_ctrl_data_lst_parts

subroutine pfs_compute_ptrs_to_rcv_lst_parts_dofs_cell_wise(this, field_id)
  implicit none
  class(par_fe_space_t), intent(inout)    :: this
  integer(ip)          , intent(in)       :: field_id
  integer(ip), pointer :: p_num_parts_dofs_cell_wise(:)
  integer(ip), pointer :: p_ptrs_to_rcv_lst_parts_dofs_cell_wise(:)
  integer(ip), pointer :: rcv_leids(:)
  integer(ip), pointer :: p_ptr_dofs_field(:)
  integer(ip) :: i, j, k, num_parts 
  integer(ip) :: start_pos, end_pos 
  class(triangulation_t), pointer :: triangulation
  type(cell_import_t), pointer :: cell_import
  
  triangulation => this%get_triangulation()
  cell_import   => triangulation%get_cell_import()

  rcv_leids => cell_import%get_rcv_leids()
  call this%ptrs_to_rcv_lst_parts_dofs_cell_wise%resize(size(rcv_leids)+1)
  p_ptrs_to_rcv_lst_parts_dofs_cell_wise => this%ptrs_to_rcv_lst_parts_dofs_cell_wise%get_pointer()
  p_ptrs_to_rcv_lst_parts_dofs_cell_wise = 0
  p_num_parts_dofs_cell_wise => this%num_parts_dofs_cell_wise%get_pointer()
  p_ptr_dofs_field => this%ptr_dofs_field%get_pointer()

  do i=1, size(rcv_leids) 
   k = rcv_leids(i)
   start_pos = p_ptr_dofs_field(k)      ! (k-1)*num_dofs+1
   end_pos   = p_ptr_dofs_field(k+1) -1 ! (k  )*num_dofs
   num_parts = 0
   do j=start_pos, end_pos
     num_parts=num_parts+p_num_parts_dofs_cell_wise(j)
   end do
   p_ptrs_to_rcv_lst_parts_dofs_cell_wise(i+1) = & 
      p_ptrs_to_rcv_lst_parts_dofs_cell_wise(i+1) + num_parts
  end do
  ! Length to header
  p_ptrs_to_rcv_lst_parts_dofs_cell_wise(1)=1
  do i=1,size(rcv_leids)
     p_ptrs_to_rcv_lst_parts_dofs_cell_wise(i+1) = & 
       p_ptrs_to_rcv_lst_parts_dofs_cell_wise(i+1)+p_ptrs_to_rcv_lst_parts_dofs_cell_wise(i) 
  end do 
end subroutine pfs_compute_ptrs_to_rcv_lst_parts_dofs_cell_wise

subroutine pfs_fetch_lst_parts_dofs_cell_wise(this,field_id)
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: field_id
  integer(ip), pointer :: p_lst_parts_dofs_cell_wise(:)
  integer(ip), pointer :: p_rcv_lst_parts_dofs_cell_wise(:)
  integer(ip), pointer :: p_rcv_ptrs_lst_parts_dofs_cell_wise(:)
  integer(ip), pointer :: p_snd_ptrs_lst_parts_dofs_cell_wise(:)
  class(environment_t), pointer :: environment
  integer(ip) :: i, j, k, l, ivef, idof, dof_gid
  integer(ip) :: num_parts, num_dofs
  integer(ip), pointer :: snd_leids(:)
  integer(ip), pointer :: snd_ptrs(:)
  integer(ip) :: current
  class(fe_cell_iterator_t), allocatable :: fe
  type(fe_vef_iterator_t) :: vef
  class(triangulation_t), pointer :: triangulation
  type(cell_import_t), pointer :: cell_import
  type(list_iterator_t) :: own_dofs_on_vef_iterator
  class(reference_fe_t), pointer :: reference_fe
  integer(ip), pointer :: fe_dofs(:)
  
  triangulation => this%get_triangulation()
  cell_import   => triangulation%get_cell_import()


  p_snd_ptrs_lst_parts_dofs_cell_wise => this%snd_ptrs_lst_parts_cell_wise%get_pointer()
  call this%lst_parts_dofs_cell_wise%resize(p_snd_ptrs_lst_parts_dofs_cell_wise(cell_import%get_num_neighbours()+1)-1)
  p_lst_parts_dofs_cell_wise => this%lst_parts_dofs_cell_wise%get_pointer()
  
  p_rcv_ptrs_lst_parts_dofs_cell_wise => this%rcv_ptrs_lst_parts_cell_wise%get_pointer()
  call this%rcv_lst_parts_dofs_cell_wise%resize(p_rcv_ptrs_lst_parts_dofs_cell_wise(cell_import%get_num_neighbours()+1)-1)
  p_rcv_lst_parts_dofs_cell_wise => this%rcv_lst_parts_dofs_cell_wise%get_pointer()
  
  call this%create_fe_cell_iterator(fe)
  call this%create_fe_vef_iterator(vef)
  snd_ptrs  => cell_import%get_snd_ptrs()
  snd_leids => cell_import%get_snd_leids()
  current = 1 
  do i=1, cell_import%get_num_neighbours()
    do j=snd_ptrs(i), snd_ptrs(i+1)-1
       k=snd_leids(j)
       call fe%set_gid(k)
       reference_fe => fe%get_reference_fe(field_id)
       call fe%get_field_fe_dofs( field_id, fe_dofs )
       ! fe_dofs is not associated when subdomain is empty  
       ! INTEL 18 does not allow to use it, unless associated
       if ( associated(fe_dofs) ) then
         do idof=1, size(fe_dofs)
           dof_gid = fe_dofs(idof)
           if ( this%is_free_dof(dof_gid) ) then
            if ( this%dof_gid_to_itfc_dof_gid(dof_gid) /= -1  ) then
              do k=2,this%lst_parts_around_itfc_dofs(1,this%dof_gid_to_itfc_dof_gid(dof_gid))+1
                p_lst_parts_dofs_cell_wise(current) = this%lst_parts_around_itfc_dofs(k,this%dof_gid_to_itfc_dof_gid(dof_gid))
                current = current + 1
              end do 
            end if  
           end if
         end do 
       end if
    end do  
  end do   
  call this%free_fe_cell_iterator(fe)
  call this%free_fe_vef_iterator(vef)
  
  environment             => this%get_environment()
  call environment%l1_neighbours_exchange ( num_rcv    = cell_import%get_num_neighbours(), &
                                            list_rcv   = cell_import%get_neighbours_ids(), &
                                            rcv_ptrs   = p_rcv_ptrs_lst_parts_dofs_cell_wise, &
                                            rcv_buf    = p_rcv_lst_parts_dofs_cell_wise, &
                                            num_snd    = cell_import%get_num_neighbours(), &
                                            list_snd   = cell_import%get_neighbours_ids(), &
                                            snd_ptrs   = p_snd_ptrs_lst_parts_dofs_cell_wise, &
                                            pack_idx   = this%lst_parts_pack_idx_cell_wise%get_pointer(), &
                                            x          = p_lst_parts_dofs_cell_wise)  
end subroutine pfs_fetch_lst_parts_dofs_cell_wise

function par_fe_space_compute_raw_interface_data_by_facet_integ ( this, &
                                                                 fe_space_id, &
                                                                 offset, &
                                                                 ubound_num_itfc_couplings, &
                                                                 dofs_gid, &
                                                                 raw_interface_data) result(num_itfc_couplings)
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: fe_space_id
  integer(ip)          , intent(in)    :: offset
  integer(ip)          , intent(in)    :: ubound_num_itfc_couplings
  integer(ip)          , intent(inout) :: dofs_gid(:)
  integer(igp)         , intent(inout) :: raw_interface_data(:, :)
  integer(ip)                          :: num_itfc_couplings

  ! Locals
  integer(ip)  :: ivef, ivef_itfc, ielem, vef_gid
  integer(igp) :: elem_ggid
  integer(ip)  :: mypart_id, part_id
  integer(ip)  :: elem_gid, max_elem_gid
  integer(ip)  :: idof, idof_face, dof_gid
  integer(ip)  :: current_col
  integer(igp) :: l1(num_rows_raw_interface_data), l2(num_rows_raw_interface_data)

  !assert ( associated (this%par_triangulation) )
  !assert ( environment%am_i_l1_task() )

  !mypart_id = environment%get_l1_rank() + 1 
  !current_col = offset + 1

  !! Traverse vefs on the interface
  !do ivef_itfc = 1, this%par_triangulation%num_itfc_vefs
  !   vef_gid = this%par_triangulation%lst_itfc_vefs(ivef_itfc)

  !   ! Is current vef_gid a face ?
  !   if ( this%triangulation%vefs(vef_gid)%dime == this%triangulation%num_dims-1 ) then
  !      do ielem=1, this%triangulation%vefs(vef_gid)%num_elems_around
  !         elem_gid = this%triangulation%vefs(vef_gid)%elems_around(ielem)
  !         if ( this%par_triangulation%elems(elem_gid)%mypart /= mypart_id ) then
  !            part_id = this%par_triangulation%elems(elem_gid)%mypart
  !         end if
  !      end do

  !      do ielem=1, this%triangulation%vefs(vef_gid)%num_elems_around
  !         elem_gid = this%triangulation%vefs(vef_gid)%elems_around(ielem)
  !         elem_gid = this%par_triangulation%elems(elem_gid)%globagid
  !         finite_element => this%get_finite_element(elem_gid)
  !         ivef = finite_element%cell%find_local_pos_from_vef_id(vef_gid)
  !         do idof_face=1, finite_element%reference_fe_phy(fe_space_id)%p%get_facet_integration_coupling_num_nodes_face()
  !            idof = finite_element%reference_fe_phy(fe_space_id)%p%get_facet_integration_coupling_node_face(idof_face,ivef)
  !            dof_gid = finite_element%fe_dofs(fe_space_id)%p(idof)
  !            dofs_gid ( current_col ) = dof_gid 
  !            raw_interface_data(neighbor_part_id_row, current_col) = part_id
  !            raw_interface_data(dof_gid_row, current_col) = this%generate_non_consecutive_dof_gid(elem_gid, idof, fe_space_id)
  !            if ( mypart_id == this%par_triangulation%elems(elem_gid)%mypart ) then
  !               raw_interface_data(owner_flag_row,current_col) = owner
  !            else
  !               raw_interface_data(owner_flag_row,current_col) = non_owner
  !            end if
  !            current_col = current_col + 1
  !         end do
  !      end do
  !   end if
  !end do

  !num_itfc_couplings = current_col-offset-1

  !if ( num_itfc_couplings > 0 ) then
  !   ! Re-number interface DoF couplings in increasing order by neighbour part id, the
  !   ! number of neighbour parts around, and e_max + local_pos_dof_in_emax
  !   call sort_array_cols_by_row_section( num_rows_raw_interface_data, &
  !                                        num_rows_raw_interface_data, &
  !                                        num_itfc_couplings, &
  !                                        raw_interface_data(1:,offset+1:current_col-1), &
  !                                        dofs_gid(offset+1:current_col-1), &
  !                                        l1, &
  !                                        l2)
  !end if                                        
  !!do current_col=1,num_itfc_couplings 
  !!  write(*,"(10i10)") current_col, dofs_gid(current_col), raw_interface_data(:,current_col)
  !!end do 

end function par_fe_space_compute_raw_interface_data_by_facet_integ


subroutine par_fe_space_create_dof_values(this, dof_values)
  implicit none
  class(par_fe_space_t)       , intent(in)    :: this
  class(vector_t), allocatable, intent(inout) :: dof_values
  integer(ip) :: istat
  type(environment_t), pointer :: environment
  
  if (allocated(dof_values)) then
    call dof_values%free()
    deallocate(dof_values, stat=istat); check(istat==0);
  end if
  
  environment => this%get_environment()
  if (this%block_layout%get_num_blocks() == 1) then
       allocate ( par_scalar_array_t  :: dof_values )
       select type(dof_values)
       class is(par_scalar_array_t)
          call dof_values%create_and_allocate(environment, this%blocks_dof_import(1))
       class default
       check(.false.)
       end select
  else
      check(.false.)
  end if
  
end subroutine par_fe_space_create_dof_values

subroutine par_fe_space_interpolate_scalar_function(this, field_id, function, fe_function, interpolator_type, time )
  implicit none
  class(par_fe_space_t)          , intent(in)    :: this
  integer(ip)                    , intent(in)    :: field_id
  class(scalar_function_t)       , intent(in)    :: function
  type(fe_function_t)            , intent(inout) :: fe_function
  character(*)         , optional, intent(in)    :: interpolator_type
  real(rp)             , optional, intent(in)    :: time
  type(environment_t), pointer :: environment
  environment => this%get_environment()
  if ( environment%am_i_l1_task() ) then
    call this%serial_fe_space_t%interpolate_scalar_function(field_id, function, fe_function, interpolator_type, time)
  end if
end subroutine par_fe_space_interpolate_scalar_function

subroutine par_fe_space_interpolate_vector_function(this, field_id, function, fe_function, interpolator_type, time )
  implicit none
  class(par_fe_space_t)          , intent(in)    :: this
  integer(ip)                    , intent(in)    :: field_id
  class(vector_function_t)       , intent(in)    :: function  
  type(fe_function_t)            , intent(inout) :: fe_function
  character(*)         , optional, intent(in)    :: interpolator_type
  real(rp)             , optional, intent(in)    :: time
  type(environment_t), pointer :: environment
  environment => this%get_environment()
  if ( environment%am_i_l1_task() ) then
    call this%serial_fe_space_t%interpolate_vector_function(field_id, function, fe_function, interpolator_type, time)
  end if
end subroutine par_fe_space_interpolate_vector_function

subroutine par_fe_space_interpolate_dirichlet_values (this, fe_function, interpolator_type, time, time_derivative_order)
  implicit none
  class(par_fe_space_t)          , intent(in)    :: this
  type(fe_function_t)            , intent(inout) :: fe_function
  character(*)         , optional, intent(in)    :: interpolator_type(:)
  real(rp)             , optional, intent(in)    :: time
  integer(ip)          , optional, intent(in)    :: time_derivative_order

  type(environment_t), pointer :: environment
  environment => this%get_environment()
  if ( environment%am_i_l1_task() ) then
    call this%serial_fe_space_t%interpolate_dirichlet_values(fe_function, interpolator_type, time, time_derivative_order)
  end if
end subroutine par_fe_space_interpolate_dirichlet_values

subroutine par_fe_space_project_dirichlet_values_curl_conforming (this, fe_function, time, fields_to_project)
  implicit none
  class(par_fe_space_t)          , intent(inout) :: this
  class(fe_function_t)           , intent(inout) :: fe_function
  real(rp)             , optional, intent(in)    :: time
  integer(ip)          , optional, intent(in)    :: fields_to_project(:)

  !  Locals
  integer(ip)                  , allocatable :: fields_to_project_(:)  
  integer(ip)                                :: field_id, istat
  integer(ip)                                :: component_id
  integer(ip)                  , allocatable :: offset_component(:)
  integer(ip)                                :: num_components
  logical                      , allocatable :: components_code(:)
  type(serial_scalar_array_t)  , pointer     :: strong_dirichlet_values

  class(reference_fe_t)        , pointer     :: reference_fe

  class(fe_facet_iterator_t), allocatable :: fe_face
  class(fe_cell_iterator_t)     , allocatable :: fe
  
  type(i1p_t), allocatable :: fe_dofs(:)

  type(par_sparse_matrix_t)            :: matrix
  type(par_scalar_array_t)             :: rhs
  type(par_scalar_array_t)             :: projected_nodal_values
  type(serial_scalar_array_t), pointer :: projected_nodal_values_serial_scalar_array
  integer(ip), allocatable             :: subset2global_dirichlet_dofs(:) 
  integer(ip), allocatable             :: global2subset_dirichlet_dofs(:) 
  integer(ip), allocatable             :: subset_fe_dofs(:) 
  type(iterative_linear_solver_t)      :: iterative_linear_solver

  real(rp), allocatable       :: elmat(:,:)
  real(rp), allocatable       :: elvec(:) 
  integer(ip)                 :: qpoint, n_q_points, ishape, jshape


  type(p_scalar_function_t), allocatable :: function_scalar_components(:)
  real(rp)                 , allocatable :: scalar_function_values(:,:)
  type(vector_field_t)     , allocatable :: vector_function_values(:,:)
  type(vector_field_t)     , allocatable :: shape_values(:,:)

  type(parameterlist_t)  :: parameter_list
  integer(ip)            :: FPLError
  integer                :: iparm(64)
  integer(ip)            :: ifield, jfield, idof, idof_subset, idof_global
  integer(ip)            :: num_subset_strong_dirichlet_dofs
  
  type(environment_t), pointer :: environment
  type(dof_import_t) :: dof_import
  
  environment => this%get_environment()
  if ( environment%am_i_l1_task() ) then
  
  
     assert ( associated(this%conditions) )
     call memalloc ( this%get_num_components(), components_code, __FILE__, __LINE__ )

     call this%allocate_and_fill_fields_to_project_(fields_to_project_, &
                                                    fields_to_project)
  
     call this%allocate_and_fill_offset_component(offset_component)
  
     call memalloc ( this%get_max_num_shape_functions(), &
                     this%get_max_num_shape_functions(), &
                     elmat, __FILE__, __LINE__ )

     call memalloc ( this%get_max_num_shape_functions(), &
                     elvec, __FILE__, __LINE__ )

     call memalloc ( this%get_max_num_shape_functions(), subset_fe_dofs, __FILE__, __LINE__ )

     allocate ( vector_function_values(this%get_max_num_facet_quadrature_points(),1), & 
                stat=istat); check(istat==0);

     allocate ( scalar_function_values(this%get_max_num_facet_quadrature_points(),1), & 
                stat=istat); check(istat==0);

     allocate ( function_scalar_components(this%triangulation%get_num_dims()), & 
                stat=istat); check(istat==0);
  
     allocate( fe_dofs(this%get_num_fields()), stat=istat); check(istat==0);

     num_subset_strong_dirichlet_dofs = this%allocate_and_fill_global2subset_and_inverse(fields_to_project_, &
                                                                                            global2subset_dirichlet_dofs, &
                                                                                            subset2global_dirichlet_dofs)

     call this%compute_boundary_dof_import( fields_to_project_, &
                                            num_subset_strong_dirichlet_dofs, &
                                            global2subset_dirichlet_dofs, &
                                            dof_import)
  
     ! Create linear system 
     call matrix%create(environment, &
                        dof_import, &
                        symmetric_storage=.false.,       &
                        is_symmetric=.false.,            &
                        sign=SPARSE_MATRIX_SIGN_UNKNOWN )

     call rhs%create_and_allocate(environment, dof_import) 
     call rhs%init(0.0_rp)

     ! Create data structures
     call projected_nodal_values%create_and_allocate(environment, dof_import)
 
     call this%create_fe_facet_iterator(fe_face)
     call this%create_fe_cell_iterator(fe) 
     do while ( .not. fe_face%has_finished() )
        if ( fe_face%is_at_boundary() ) then
           if ( fe_face%get_set_id() /= 0 ) then
              call fe_face%update_integration() 
              call fe_face%get_cell_around(1,fe)
              call fe%get_fe_dofs(fe_dofs)
              call this%conditions%get_components_code( fe_face%get_set_id(), components_code )
              
              do ifield = 1, size(fields_to_project_)    
                 field_id = fields_to_project_(ifield) 
                 component_id = offset_component(field_id) + 1
                 if (components_code(component_id)) then
                    
                    call this%get_function_scalar_components(fe_face, &
                                                             fe, &
                                                             field_id, &
                                                             component_id, &
                                                             function_scalar_components)
                 
                    call this%evaluate_vector_function_scalar_components(fe_face, &
                                                                         fe, &
                                                                         field_id, &
                                                                         function_scalar_components, &
                                                                         scalar_function_values, &
                                                                         vector_function_values, &
                                                                         time)
                 
                    call this%project_curl_conforming_compute_elmat_elvec(fe_face, &
                                                                          fe, &
                                                                          field_id, &
                                                                          vector_function_values, &
                                                                          elmat, &
                                                                          elvec, &
                                                                          shape_values)
              
              
                    ! Consecutive DOF re-numbering for the subset of Dirichlet DOFs to be projected 
                    subset_fe_dofs = 0
                    if ( associated(fe_dofs(field_id)%p) ) then
                      do idof = 1, size(fe_dofs(field_id)%p)
                         if ( this%is_strong_dirichlet_dof(fe_dofs(field_id)%p(idof)) ) then 
                            subset_fe_dofs(idof) = global2subset_dirichlet_dofs( -fe_dofs(field_id)%p(idof) )
                         end if
                      end do
                    end if
                 
                    reference_fe => fe%get_reference_fe(field_id)
                    call matrix%insert(num_rows = reference_fe%get_num_shape_functions(),& 
                                      num_cols = reference_fe%get_num_shape_functions(),& 
                                      ia       = subset_fe_dofs, &
                                      ja       = subset_fe_dofs, &
                                      ioffset  = 0, &
                                      joffset  = 0, & 
                                      val      = elmat)
                    call rhs%add(num_entries = reference_fe%get_num_shape_functions(),& 
                                 ia          = subset_fe_dofs, &
                                 ioffset     = 0, &
                                 val         = elvec)
                 end if
              end do
           end if
        end if
        call fe_face%next()
     end do
     call this%free_fe_cell_iterator(fe) 
     call this%free_fe_facet_iterator(fe_face)
     call matrix%convert(csr_format)

     call parameter_list%init()
     FPLError = parameter_list%set(key = ils_rtol_key, value = 1.0e-12_rp)
     FPLError = FPLError + parameter_list%set(key = ils_output_frequency_key, value = 30)
     assert(FPLError == 0)
     call iterative_linear_solver%create(this%get_environment())
     call iterative_linear_solver%set_type_from_string(cg_name)
     call iterative_linear_solver%set_parameters_from_pl(parameter_list)
     call iterative_linear_solver%set_operators(matrix, .identity. matrix) 
     call iterative_linear_solver%apply(rhs,projected_nodal_values)
     call iterative_linear_solver%free()
     call parameter_list%free()
     
     projected_nodal_values_serial_scalar_array => projected_nodal_values%get_serial_scalar_array()
     
     ! Insert projected nodal values into strong_dirichlet_values array
     strong_dirichlet_values => fe_function%get_fixed_dof_values()
     call strong_dirichlet_values%insert_subvector(iblock=1, &
                                                   size_indices=num_subset_strong_dirichlet_dofs, &
                                                   indices=subset2global_dirichlet_dofs,             &
                                                   values=projected_nodal_values_serial_scalar_array%get_entries())
     call matrix%free()
     call rhs%free()
     call projected_nodal_values%free()
     call dof_import%free()
     call memfree (elmat, __FILE__, __LINE__)
     call memfree (elvec, __FILE__, __LINE__)
     call memfree (offset_component, __FILE__, __LINE__ )
     deallocate ( function_scalar_components, stat=istat); check(istat==0);
     deallocate ( vector_function_values, stat=istat); check(istat==0);
     deallocate ( scalar_function_values, stat=istat); check(istat==0);
     deallocate ( shape_values, stat=istat); check(istat==0);
     call memfree ( components_code, __FILE__, __LINE__ )
     call memfree ( subset2global_dirichlet_dofs, __FILE__, __LINE__ )
     call memfree ( global2subset_dirichlet_dofs, __FILE__, __LINE__ ) 
     call memfree ( fields_to_project_, __FILE__, __LINE__ )
     call memfree ( subset_fe_dofs, __FILE__, __LINE__ )
     deallocate(fe_dofs, stat=istat ); check (istat==0)
  end if
end subroutine par_fe_space_project_dirichlet_values_curl_conforming 

 subroutine par_fe_space_setup_coarse_dofs ( this, parameter_list )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  type(ParameterList_t), intent(in)    :: parameter_list
  integer(ip)                          :: i, istat, field_id
  type(environment_t), pointer         :: environment
  integer(ip)                          :: coarse_dof_gid
  integer(ip)                          :: coarse_n_facet_gid
  type(fe_object_iterator_t)           :: object
  type(list_iterator_t)                :: own_coarse_dofs_iterator
  integer(ip), allocatable             :: num_coarse_dofs_x_field(:,:), max_num_coarse_dofs_x_field(:)
  integer(ip)                          :: current_coarse_dof, sum_max_num_coarse_dofs, max_max_num_coarse_dofs

  environment => this%get_environment()
  assert ( environment%am_i_l1_task() )   
  
  call this%free_coarse_dofs()
    
  call memalloc ( this%get_num_fe_objects(), this%num_fields, num_coarse_dofs_x_field, __FILE__, __LINE__ )
  
  call memalloc ( this%num_fields, max_num_coarse_dofs_x_field, __FILE__, __LINE__ )
  
  call memalloc ( this%num_fields+1, this%ptr_coarse_dofs_x_field, __FILE__, __LINE__ )
    
  allocate ( this%coarse_dof_gids_x_field(this%num_fields), stat=istat )
  check ( istat == 0 )
  
  allocate ( this%own_coarse_dofs_x_field(this%num_fields), stat=istat )
  check ( istat == 0 )
  
  this%ptr_coarse_dofs_x_field(1) = 1
  sum_max_num_coarse_dofs = 0
  max_max_num_coarse_dofs = 0
  do field_id=1, this%num_fields
    call this%coarse_fe_handlers(field_id)%p%get_num_coarse_dofs(field_id, this, parameter_list, num_coarse_dofs_x_field(:,field_id))
    this%ptr_coarse_dofs_x_field(field_id+1) = this%ptr_coarse_dofs_x_field(field_id)
    do i=1, this%get_num_fe_objects()
      this%ptr_coarse_dofs_x_field(field_id+1) = this%ptr_coarse_dofs_x_field(field_id+1) + &
                                                   num_coarse_dofs_x_field(i, field_id)
    end do  
    
    max_num_coarse_dofs_x_field(field_id) = maxval(num_coarse_dofs_x_field(:,field_id))
    max_max_num_coarse_dofs = max(max_max_num_coarse_dofs,max_num_coarse_dofs_x_field(field_id))
    sum_max_num_coarse_dofs = sum_max_num_coarse_dofs + max_num_coarse_dofs_x_field(field_id)
    call environment%l1_max(max_num_coarse_dofs_x_field(field_id))
  end do
  
  call memalloc ( this%ptr_coarse_dofs_x_field(this%num_fields+1)-1, &
                  this%lst_coarse_dofs, __FILE__, __LINE__ )
  
  ! Enumerate coarse DoFs and map them to coarse n_faces
  current_coarse_dof = 1 
  coarse_dof_gid = 1
  do field_id=1, this%num_fields
     call this%own_coarse_dofs_x_field(field_id)%create(this%get_num_fe_objects())
     do i=1, this%get_num_fe_objects()
       call this%own_coarse_dofs_x_field(field_id)%sum_to_pointer_index(i,num_coarse_dofs_x_field(i,field_id))
     end do     
     call this%own_coarse_dofs_x_field(field_id)%calculate_header()
     call this%own_coarse_dofs_x_field(field_id)%allocate_list_from_pointer()
     
     do coarse_n_facet_gid=1, this%own_coarse_dofs_x_field(field_id)%get_num_pointers()
       own_coarse_dofs_iterator = this%own_coarse_dofs_x_field(field_id)%create_iterator(coarse_n_facet_gid)
       do while ( .not. own_coarse_dofs_iterator%is_upper_bound() )
         call own_coarse_dofs_iterator%set_current(coarse_dof_gid)
         call own_coarse_dofs_iterator%next()
         coarse_dof_gid = coarse_dof_gid + 1
         this%lst_coarse_dofs(current_coarse_dof) = current_coarse_dof
         current_coarse_dof = current_coarse_dof + 1
       end do         
     end do
     
  end do
  
  ! Generate a global numbering for the coarse DoFs
  do field_id=1, this%num_fields
     call this%coarse_dof_gids_x_field(field_id)%create(this%ptr_coarse_dofs_x_field(field_id+1)-&
                                                          this%ptr_coarse_dofs_x_field(field_id)) 
  
     call this%create_fe_object_iterator(object)
     do while ( .not. object%has_finished() )
       own_coarse_dofs_iterator = object%create_own_coarse_dofs_iterator(field_id)
       do while (.not. own_coarse_dofs_iterator%is_upper_bound())
         this%coarse_dof_gids_x_field(field_id)%a(own_coarse_dofs_iterator%get_current()-this%ptr_coarse_dofs_x_field(field_id)+1) = &
               this%generate_coarse_dof_ggid(object%get_ggid(),field_id, &
                                            own_coarse_dofs_iterator%get_distance_to_lower_bound(), &
                                            max_max_num_coarse_dofs, & ! max_num_coarse_dofs_x_field(field_id), &
                                            sum_max_num_coarse_dofs)
         call own_coarse_dofs_iterator%next()
       end do
       call object%next()
     end do
     call this%free_fe_object_iterator(object)
  end do
  
  call memfree ( num_coarse_dofs_x_field, __FILE__, __LINE__ )
  call memfree ( max_num_coarse_dofs_x_field, __FILE__, __LINE__ )
end subroutine par_fe_space_setup_coarse_dofs

function par_fe_space_generate_coarse_dof_ggid(object_gid, field_id, &
                                              current_coarse_dof, &
                                              max_num_coarse_dofs_x_object_and_field, &
                                              max_num_coarse_dofs_x_object ) result(coarse_dof_gid)
  implicit none
  integer(igp)         , intent(in) :: object_gid
  integer(ip)          , intent(in) :: field_id
  integer(ip)          , intent(in) :: current_coarse_dof
  integer(ip)          , intent(in) :: max_num_coarse_dofs_x_object
  integer(ip)          , intent(in) :: max_num_coarse_dofs_x_object_and_field
  integer(igp) :: coarse_dof_gid
  !coarse_dof_gid = object_gid*int(max_num_coarse_dofs_x_object,igp) - (int(max_num_coarse_dofs_x_object,igp)-int(current_coarse_dof,igp))
  coarse_dof_gid = (object_gid-1)*int(max_num_coarse_dofs_x_object,igp) &
                 + int((field_id-1)*max_num_coarse_dofs_x_object_and_field,igp)  &
                 + int(current_coarse_dof,igp)

end function par_fe_space_generate_coarse_dof_ggid

subroutine par_fe_space_free_coarse_dofs(this)
    implicit none
    class(par_fe_space_t)           , intent(inout) :: this
    integer(ip)                               :: i, istat 
        
    if (allocated(this%ptr_coarse_dofs_x_field)) then 
      call memfree ( this%ptr_coarse_dofs_x_field, __FILE__, __LINE__ )
    end if
    
    if (allocated(this%lst_coarse_dofs)) then 
      call memfree ( this%lst_coarse_dofs, __FILE__, __LINE__ )
    end if
  
    if (allocated(this%coarse_dof_gids_x_field)) then
      do i=1, size(this%coarse_dof_gids_x_field)
        call this%coarse_dof_gids_x_field(i)%free()
      end do  
      deallocate ( this%coarse_dof_gids_x_field, stat=istat )
      check (istat == 0)  
    end if
  
    if (allocated(this%own_coarse_dofs_x_field)) then
      do i=1, size(this%own_coarse_dofs_x_field)
        call this%own_coarse_dofs_x_field(i)%free()
      end do  
      deallocate ( this%own_coarse_dofs_x_field, stat=istat )
      check (istat == 0)  
    end if
end subroutine par_fe_space_free_coarse_dofs
   
subroutine par_fe_space_setup_coarse_fe_space(this, parameter_list)
  implicit none
  class(par_fe_space_t)        , intent(inout)  :: this
  type(parameterlist_t), target, intent(in)     :: parameter_list
  integer(ip)                           :: istat
  integer(ip)                           :: num_fields
  integer(ip), allocatable              :: fe_space_type_x_field(:)
  integer(ip), allocatable              :: ptr_dofs_x_fe(:)
  integer(ip), allocatable              :: coarse_dofs_gids_recv_counts(:)
  integer(ip), allocatable              :: coarse_dofs_gids_displs(:)
  integer(igp), allocatable             :: lst_dofs_gids(:)
  integer(igp), allocatable             :: lst_vefs_gids_dofs_objects(:)
  type(environment_t), pointer      :: environment
  class(triangulation_t), pointer    :: triangulation
  type(coarse_triangulation_t), pointer :: coarse_triangulation
 
  environment    => this%get_environment()
  triangulation  => this%get_triangulation()
  assert ( triangulation%coarse_triangulation_is_set_up() )
  this%parameter_list => parameter_list 
 
  call this%free_coarse_fe_space_l1_data()
  call this%free_coarse_fe_space_lgt1_data()
 
  if ( environment%am_i_l1_task() ) then
    call this%setup_coarse_dofs(parameter_list)
    call this%compute_faces_object()
  end if  
  
   ! All MPI tasks (even if they are not involved in the L2 from L1 gather) should also allocate the
   ! allocatable arrays due to the fact that non-allocated allocatable arrays cannot
   ! be passed as actual arguments of dummy arguments that do not have the allocatable attribute 
   ! Otherwise, the code crashes with a segmentation fault.
   call memalloc (0, fe_space_type_x_field, __FILE__, __LINE__)
   call memalloc (0, ptr_dofs_x_fe, __FILE__, __LINE__)
   call memalloc (0, lst_dofs_gids, __FILE__, __LINE__)
   call memalloc (0, lst_vefs_gids_dofs_objects, __FILE__, __LINE__)
   call memalloc (0, coarse_dofs_gids_recv_counts, __FILE__, __LINE__)
   call memalloc (0, coarse_dofs_gids_displs, __FILE__, __LINE__)

   
  ! L2 tasks gather from L1 tasks all raw data required to set-up the coarse triangulation on L2 tasks
  if ( environment%am_i_l1_to_l2_task() ) then
     call this%transfer_num_fields(num_fields) 
     call this%transfer_fe_space_type(num_fields, fe_space_type_x_field)
     call this%gather_ptr_dofs_x_fe(num_fields, ptr_dofs_x_fe)
     call this%gather_coarse_dofs_ggids_rcv_counts_and_displs (coarse_dofs_gids_recv_counts, coarse_dofs_gids_displs)
     call this%gather_coarse_dofs_ggids(coarse_dofs_gids_recv_counts, coarse_dofs_gids_displs, lst_dofs_gids)
     call this%gather_vefs_ggids_dofs_objects(coarse_dofs_gids_recv_counts, coarse_dofs_gids_displs, lst_vefs_gids_dofs_objects)
  end if
  

  if ( environment%am_i_lgt1_task() ) then
     ! lgt1 MPI tasks (recursively) build coarse triangulation
     if ( .not. associated(this%coarse_fe_space) ) then
        allocate  ( this%coarse_fe_space, stat = istat )
        check( istat == 0 )
     end if
     triangulation        => this%get_triangulation()
     coarse_triangulation => triangulation%get_coarse_triangulation()
     call this%coarse_fe_space%create (coarse_triangulation, &
                                       num_fields, &
                                       fe_space_type_x_field, &
                                       ptr_dofs_x_fe, &
                                       lst_dofs_gids, &
                                       lst_vefs_gids_dofs_objects)
  else
     ! L1 tasks do not hold any piece of the coarse triangulation
     nullify(this%coarse_fe_space)
  end if
  call this%set_coarse_fe_space_is_set_up(.true.) 

  ! All tasks free raw data (see actual reason on the top part of this subroutine)
  call memfree (fe_space_type_x_field, __FILE__, __LINE__)
  call memfree (ptr_dofs_x_fe, __FILE__, __LINE__)
  call memfree (lst_dofs_gids, __FILE__, __LINE__)
  call memfree (lst_vefs_gids_dofs_objects, __FILE__, __LINE__)
  call memfree (coarse_dofs_gids_recv_counts, __FILE__, __LINE__)
  call memfree (coarse_dofs_gids_displs, __FILE__, __LINE__)
end subroutine par_fe_space_setup_coarse_fe_space

subroutine par_fe_space_transfer_num_fields ( this, num_fields )
  implicit none
  class(par_fe_space_t)   , intent(in)      :: this
  integer(ip)              , intent(out)     :: num_fields
  integer(ip)                                :: dummy_integer_ip
  type(environment_t), pointer           :: environment

  environment => this%get_environment()
  assert ( environment%am_i_l1_to_l2_task() )
  if ( environment%am_i_l1_to_l2_root() ) then
     call environment%l1_to_l2_transfer(input_data=dummy_integer_ip, &
                                            output_data=num_fields)
  else
     num_fields = this%get_num_fields()
     call environment%l1_to_l2_transfer(input_data=num_fields, &
                                            output_data=dummy_integer_ip) 
  end if
end subroutine par_fe_space_transfer_num_fields

subroutine par_fe_space_transfer_fe_space_type ( this, num_fields, fe_space_type_x_field )
  implicit none
  class(par_fe_space_t)   , intent(in)    :: this
  integer(ip)             , intent(in)       :: num_fields
  integer(ip), allocatable, intent(inout)    :: fe_space_type_x_field(:)
  integer(ip)                                :: dummy_integer_array_ip(0)
  type(environment_t), pointer           :: environment

  environment => this%get_environment()
  assert ( environment%am_i_l1_to_l2_task() )
  if ( environment%am_i_l1_to_l2_root() ) then
     if ( allocated (fe_space_type_x_field) ) call memfree ( fe_space_type_x_field, __FILE__, __LINE__ )
     call memalloc ( num_fields, fe_space_type_x_field, __FILE__, __LINE__ )
     call environment%l1_to_l2_transfer(input_data=dummy_integer_array_ip, &
                                            output_data=fe_space_type_x_field)
  else
     call environment%l1_to_l2_transfer(input_data=this%get_fe_space_type(), &
                                            output_data=dummy_integer_array_ip) 
  end if
end subroutine par_fe_space_transfer_fe_space_type

subroutine par_fe_space_gather_ptr_dofs_x_fe( this, num_fields, ptr_dofs_x_fe )
  implicit none
  class(par_fe_space_t)   , intent(inout)    :: this
  integer(ip)             , intent(in)       :: num_fields
  integer(ip), allocatable, intent(inout)    :: ptr_dofs_x_fe(:)
  integer(ip)                                :: i, num_local_cells
  integer(ip)                                :: dummy_integer_array(0)
  type(environment_t), pointer           :: environment
  class(triangulation_t), pointer         :: triangulation
  type(coarse_triangulation_t), pointer      :: coarse_triangulation
  
  environment => this%get_environment()
  assert ( environment%am_i_l1_to_l2_task() )
  if ( environment%am_i_l1_to_l2_root() ) then
     triangulation => this%get_triangulation()
     coarse_triangulation => triangulation%get_coarse_triangulation()
     num_local_cells = coarse_triangulation%get_num_local_cells()
     if (allocated(ptr_dofs_x_fe)) call memfree ( ptr_dofs_x_fe, __FILE__, __LINE__ )
     call memalloc ((num_local_cells+1)*num_fields+1, ptr_dofs_x_fe, __FILE__, __LINE__ )
     call environment%l2_from_l1_gather( input_data_size = num_fields, &
                                             input_data      = [((0), i=1,num_fields)], &
                                             output_data     = ptr_dofs_x_fe(2:))
     ptr_dofs_x_fe(1) = 1
     do i=1, num_local_cells*num_fields
       ptr_dofs_x_fe(i+1) = ptr_dofs_x_fe(i) + ptr_dofs_x_fe(i+1)
     end do
  else
     do i=1, this%num_fields
       this%ptr_coarse_dofs_x_field(i) = this%ptr_coarse_dofs_x_field(i+1)-this%ptr_coarse_dofs_x_field(i) 
     end do
  
     call environment%l2_from_l1_gather( input_data_size = this%get_num_fields(), &
                                             input_data      = this%ptr_coarse_dofs_x_field, &
                                             output_data     = dummy_integer_array )
     do i=this%num_fields,1,-1
       this%ptr_coarse_dofs_x_field(i) = this%ptr_coarse_dofs_x_field(i+1)-this%ptr_coarse_dofs_x_field(i) 
     end do
  end if
end subroutine par_fe_space_gather_ptr_dofs_x_fe

  subroutine par_fe_space_gather_coarse_dofs_ggids_rcv_counts_and_displs( this, recv_counts, displs )
    implicit none
    class(par_fe_space_t)     , intent(in)    :: this
    integer(ip) , allocatable , intent(inout) :: recv_counts(:) 
    integer(ip) , allocatable , intent(inout) :: displs(:)
    integer(ip)                               :: i
    integer(ip)                               :: l1_to_l2_size
    integer(ip)                               :: dummy_integer_array(0)
    type(environment_t), pointer          :: environment

    environment => this%get_environment()
    assert ( environment%am_i_l1_to_l2_task() )
    if ( environment%am_i_l1_to_l2_root() ) then
      l1_to_l2_size = environment%get_l1_to_l2_size()
      if ( allocated (recv_counts) ) call memfree ( recv_counts, __FILE__, __LINE__ )
      if ( allocated (displs) ) call memfree ( displs, __FILE__, __LINE__ )
      call memalloc ( l1_to_l2_size, recv_counts, __FILE__, __LINE__ )
      call memalloc ( l1_to_l2_size, displs, __FILE__, __LINE__ )
      call environment%l2_from_l1_gather( input_data = 0, &
                                              output_data = recv_counts ) 
      displs(1) = 0
      do i=2, l1_to_l2_size
        displs(i) = displs(i-1) + recv_counts(i-1)
      end do
    else
      call environment%l2_from_l1_gather( input_data  = this%ptr_coarse_dofs_x_field(this%num_fields+1)-1, &
                                              output_data = dummy_integer_array ) 
    end if
  end subroutine par_fe_space_gather_coarse_dofs_ggids_rcv_counts_and_displs
  
  subroutine par_fe_space_gather_coarse_dofs_ggids ( this, recv_counts, displs, lst_gids )
    implicit none
    class(par_fe_space_t)     , intent(in)    :: this
    integer(ip)               , intent(in)    :: recv_counts(:)
    integer(ip)               , intent(in)    :: displs(:)
    integer(igp), allocatable , intent(inout) :: lst_gids(:)
    integer(ip)                               :: l1_to_l2_size
    integer(igp)                              :: dummy_integer_array_igp(0)
    integer(ip)                               :: dummy_integer_array_ip(0)
    type(environment_t), pointer          :: environment
    integer(ip)                               :: i, spos, epos
    integer(igp), allocatable                 :: buffer(:)
    
    environment => this%get_environment()
    assert ( environment%am_i_l1_to_l2_task() )
    if ( environment%am_i_l1_to_l2_root() ) then
      l1_to_l2_size = environment%get_l1_to_l2_size()
      if (allocated(lst_gids)) call memfree ( lst_gids, __FILE__, __LINE__ )
      call memalloc ( displs(l1_to_l2_size), lst_gids, __FILE__, __LINE__ )
      call environment%l2_from_l1_gather( input_data_size = 0, &
                                              input_data      = dummy_integer_array_igp, &
                                              recv_counts     = recv_counts, &
                                              displs          = displs, &
                                              output_data     = lst_gids )
    else
      ! Pack dofs_objects_gids_x_field(:) into plain buffer for further data exchange
      call memalloc ( this%ptr_coarse_dofs_x_field(this%num_fields+1)-1, buffer, __FILE__, __LINE__ ) 
      do i=1, this%get_num_fields()
        spos = this%ptr_coarse_dofs_x_field(i)
        epos = this%ptr_coarse_dofs_x_field(i+1)-1
        buffer(spos:epos) = this%coarse_dof_gids_x_field(i)%a
        spos = epos +1 
      end do
    
      call environment%l2_from_l1_gather( input_data_size = size(buffer), &
                                              input_data      = buffer, &
                                              recv_counts     = dummy_integer_array_ip, &
                                              displs          = dummy_integer_array_ip, &
                                              output_data     = dummy_integer_array_igp )
      call memfree ( buffer, __FILE__, __LINE__ )
    end if    
  end subroutine par_fe_space_gather_coarse_dofs_ggids

  subroutine par_fe_space_gather_vefs_ggids_dofs_objects ( this, recv_counts, displs, vef_gids )
    implicit none
    class(par_fe_space_t)     , intent(in)   :: this
    integer(ip)               , intent(in)    :: recv_counts(:)
    integer(ip)               , intent(in)    :: displs(:)
    integer(igp), allocatable , intent(inout) :: vef_gids(:)
    integer(ip)                               :: l1_to_l2_size
    integer(igp)                              :: dummy_integer_array_igp(0)
    integer(ip)                               :: dummy_integer_array_ip(0)
    type(environment_t), pointer          :: environment
    integer(ip)                               :: i, j, spos, epos
    integer(igp), allocatable                 :: buffer(:)
    type(fe_object_iterator_t)                :: object
    type(list_iterator_t)                     :: own_coarse_dofs_iterator
    
    environment => this%get_environment()
    assert ( environment%am_i_l1_to_l2_task() )
    if ( environment%am_i_l1_to_l2_root() ) then
      l1_to_l2_size = environment%get_l1_to_l2_size()
      if (allocated(vef_gids)) call memfree ( vef_gids, __FILE__, __LINE__ )
      call memalloc ( displs(l1_to_l2_size), vef_gids, __FILE__, __LINE__ )
      call environment%l2_from_l1_gather( input_data_size = 0, &
                                                           input_data      = dummy_integer_array_igp, &
                                                           recv_counts     = recv_counts, &
                                                           displs          = displs, &
                                                           output_data     = vef_gids )
    else
      ! Pack vefs_gids_dofs_objects_x_field(:) into plain buffer for further data exchange
      call memalloc ( this%ptr_coarse_dofs_x_field(this%num_fields+1)-1, buffer, __FILE__, __LINE__ )
      do i=1, this%get_num_fields()
        spos = this%ptr_coarse_dofs_x_field(i)
        call this%create_fe_object_iterator(object)
        do while ( .not. object%has_finished() )
          own_coarse_dofs_iterator = object%create_own_coarse_dofs_iterator(i)
          do while (.not. own_coarse_dofs_iterator%is_upper_bound())
            buffer(spos) = object%get_ggid() 
            spos = spos +1
            call own_coarse_dofs_iterator%next()
          end do
          call object%next()
        end do
        call this%free_fe_object_iterator(object)
      end do
    
      call environment%l2_from_l1_gather( input_data_size = size(buffer), &
                                              input_data      = buffer, &
                                              recv_counts     = dummy_integer_array_ip, &
                                              displs          = dummy_integer_array_ip, &
                                              output_data     = dummy_integer_array_igp )
      
      call memfree ( buffer, __FILE__, __LINE__ )
    end if    
  end subroutine par_fe_space_gather_vefs_ggids_dofs_objects
  
  function par_fe_space_get_total_num_coarse_dofs ( this )
    implicit none
    class(par_fe_space_t)           , intent(in) :: this
    integer(ip)                               :: par_fe_space_get_total_num_coarse_dofs
    integer(ip)                               :: field_id
    par_fe_space_get_total_num_coarse_dofs = 0
    do field_id = 1, this%get_num_fields()
       par_fe_space_get_total_num_coarse_dofs = par_fe_space_get_total_num_coarse_dofs + & 
                                                   this%ptr_coarse_dofs_x_field(field_id+1)-this%ptr_coarse_dofs_x_field(field_id)
    end do
  end function par_fe_space_get_total_num_coarse_dofs
  
  function par_fe_space_get_block_num_coarse_dofs ( this, block_id )
    implicit none
    class(par_fe_space_t)           , intent(in)    :: this
    integer(ip)               , intent(in)    :: block_id
    integer(ip)                               :: par_fe_space_get_block_num_coarse_dofs 
    integer(ip)                               :: field_id
    assert ( block_id == 1 )
    par_fe_space_get_block_num_coarse_dofs = 0
    do field_id = 1, this%get_num_fields()
       if ( this%block_layout%get_block_id(field_id) == block_id ) then
         par_fe_space_get_block_num_coarse_dofs = par_fe_space_get_block_num_coarse_dofs + & 
                                                     this%ptr_coarse_dofs_x_field(field_id+1)-this%ptr_coarse_dofs_x_field(field_id)
       end if                                      
    end do
  end function par_fe_space_get_block_num_coarse_dofs
  
 function par_fe_space_get_coarse_fe_handler ( this, field_id ) 
    implicit none
    class(par_fe_space_t), target, intent(in) :: this
    integer(ip)                  , intent(in) :: field_id
    class(l1_coarse_fe_handler_t), pointer :: par_fe_space_get_coarse_fe_handler
    par_fe_space_get_coarse_fe_handler => this%coarse_fe_handlers(field_id)%p
  end function par_fe_space_get_coarse_fe_handler
  
  subroutine par_fe_space_refine_and_coarsen_single_fe_function( this, fe_function )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  type(fe_function_t)  , intent(inout) :: fe_function
  class(triangulation_t), pointer :: triangulation
  class(p4est_par_triangulation_t), pointer :: par_triangulation
  type(fe_function_t) :: transformed_fe_function
  type(std_vector_integer_ip_t), pointer :: refinement_and_coarsening_flags
  type(std_vector_integer_ip_t), allocatable :: old_ptr_dofs_x_fe(:)
  type(std_vector_integer_ip_t) :: old_lst_dofs_gids
  integer(ip), pointer :: old_field_fe_dofs(:)
  integer(ip) :: num_children_x_cell
  integer(ip) :: transformation_flag
  integer(ip) :: subcell_id, old_cell_lid, new_cell_lid
  integer(ip) :: current_old_cell_lid, current_new_cell_lid
  integer(ip) :: old_num_local_cells
  integer(ip) :: old_num_ghost_cells
  integer(ip) :: field_id
  class(fe_cell_iterator_t)         , allocatable :: new_fe
  real(rp)                          , allocatable :: old_nodal_values(:,:)
  real(rp)                          , allocatable :: new_nodal_values(:)
  class(reference_fe_t)             , pointer     :: reference_fe
  integer(ip)                                     :: num_nodes_field
  type(block_layout_t)              , pointer     :: block_layout
  integer(ip)                                     :: error
  integer(ip) :: spos, epos
  real(rp), pointer :: p_new_fe_function_nodal_values(:)
  type(environment_t), pointer :: environment
  class(cell_import_t), pointer :: cell_import
  
  
#ifdef ENABLE_P4EST  
  triangulation => this%get_triangulation()
  environment => triangulation%get_environment()
  if ( environment%am_i_l1_task() ) then
     select type(triangulation)
        class is (p4est_par_triangulation_t)
        par_triangulation => triangulation
        refinement_and_coarsening_flags => triangulation%get_refinement_and_coarsening_flags()
        class default
        assert(.false.)
     end select

     if ( par_triangulation%get_num_cells() > 0 ) then
        old_num_local_cells = par_triangulation%get_previous_num_local_cells()
        old_num_ghost_cells = par_triangulation%get_previous_num_ghost_cells()
        
        call this%update_after_refine_coarsen(old_ptr_dofs_x_fe,old_lst_dofs_gids)

        call this%new_fe_function_nodal_values%resize(0)
        call this%new_fe_function_nodal_values%resize(this%ptr_dofs_x_fe(1)%get(triangulation%get_num_cells()+1)-1)
        p_new_fe_function_nodal_values => this%new_fe_function_nodal_values%get_pointer()

        call this%create_fe_cell_iterator(new_fe)
        reference_fe => new_fe%get_reference_fe_geo()
        num_children_x_cell = reference_fe%get_num_n_faces_of_dim(0)
        call memalloc(num_children_x_cell, &
             this%get_max_num_shape_functions(),old_nodal_values,__FILE__,__LINE__)

        call transformed_fe_function%create(this)

        old_cell_lid = 1
        new_cell_lid = 1
        do while ( old_cell_lid .le. old_num_local_cells )
           transformation_flag = refinement_and_coarsening_flags%get(old_cell_lid)
           do field_id = 1,this%get_num_fields()
              call new_fe%set_gid(new_cell_lid) 
              current_old_cell_lid = old_cell_lid
              current_new_cell_lid = new_cell_lid
              reference_fe => new_fe%get_reference_fe(field_id) ! Only h-adaptivity
              num_nodes_field = reference_fe%get_num_shape_functions()
              old_field_fe_dofs => get_field_fe_dofs()
              call fe_function%gather_nodal_values( field_id, & 
                   old_field_fe_dofs, &
                   num_nodes_field, & 
                   this%get_field_blocks(), &
                   old_nodal_values(1,1:num_nodes_field) )

              if ( transformation_flag == do_nothing ) then
                 call get_new_lst_dofs_spos_epos(spos,epos)
                 p_new_fe_function_nodal_values(spos:epos) = old_nodal_values(1,1:num_nodes_field)
                 current_new_cell_lid = current_new_cell_lid + 1
              else if ( transformation_flag == refinement ) then
                 do subcell_id = 0,num_children_x_cell-1
                    call get_new_lst_dofs_spos_epos(spos,epos)
                    select type(reference_fe)
                    class is (hex_lagrangian_reference_fe_t)
                       call reference_fe%interpolate_nodal_values_on_subcell( subcell_id, & 
                            old_nodal_values(1,1:num_nodes_field), &
                            p_new_fe_function_nodal_values(spos:epos) )
                    type is (void_reference_fe_t)
                       ! Do nothing
                       class default
                       assert(.false.)
                    end select
                    current_new_cell_lid = current_new_cell_lid + 1
                    call new_fe%set_gid(current_new_cell_lid)
                 end do
              else if ( transformation_flag == coarsening ) then
                 do subcell_id = 1,num_children_x_cell-1
                    current_old_cell_lid = current_old_cell_lid + 1
                    old_field_fe_dofs => get_field_fe_dofs()
                    call fe_function%gather_nodal_values( field_id, & 
                         old_field_fe_dofs, &
                         num_nodes_field, & 
                         this%get_field_blocks(), &
                         old_nodal_values(subcell_id+1,1:num_nodes_field) )
                 end do
                 call get_new_lst_dofs_spos_epos(spos,epos)
                 select type(reference_fe)
                 class is (hex_lagrangian_reference_fe_t)
                    call reference_fe%project_nodal_values_on_cell( old_nodal_values(:,1:num_nodes_field), &
                         p_new_fe_function_nodal_values(spos:epos) )
                 type is (void_reference_fe_t)
                    ! Do nothing
                    class default
                    assert(.false.)
                 end select
                 current_new_cell_lid = current_new_cell_lid + 1
              else
                 massert(.false.,'Unrecognised refinement and coarsening flag')
              end if
           end do
           old_cell_lid = current_old_cell_lid
           new_cell_lid = current_new_cell_lid
           old_cell_lid = old_cell_lid + 1
        end do

        ! Retrieve set IDs from ghost cells
        cell_import => triangulation%get_cell_import()
        call environment%l1_neighbours_exchange ( cell_import%get_num_neighbours(), &
                                                  cell_import%get_neighbours_ids(),&
                                                  cell_import%get_rcv_ptrs(),&
                                                  cell_import%get_rcv_leids(),&
                                                  cell_import%get_num_neighbours(), &
                                                  cell_import%get_neighbours_ids(),&
                                                  cell_import%get_snd_ptrs(),&
                                                  cell_import%get_snd_leids(),&
                                                  p_new_fe_function_nodal_values, &
                                                  p_new_fe_function_nodal_values, &
                                                  this%ptr_dofs_x_fe(1)%get_pointer(), &
                                                  this%ptr_dofs_x_fe(1)%get_pointer() )
        
        !  massert ( new_cell_lid - 1 == this%triangulation%get_num_cells(), 'Loop in old cells failed to visit all new cells' )
        !  
        call fe_function%create(this)
        fe_function = transformed_fe_function

        select type(triangulation)
           class is (p4est_par_triangulation_t)
           call triangulation%clear_refinement_and_coarsening_flags()
           class default
           assert(.false.)
        end select
        
        call new_fe%first()
        do while ( .not. new_fe%has_finished() )
          current_new_cell_lid = new_fe%get_gid() 
          do field_id=1, this%num_fields 
            call get_new_lst_dofs_spos_epos(spos,epos)
            call fe_function%insert_nodal_values( new_fe,   &
                                                  field_id, &
                                                  p_new_fe_function_nodal_values(spos:epos))
          end do 
          call new_fe%next()
        end do
        
        call this%update_hanging_dof_values(fe_function)
        
        call this%free_fe_cell_iterator(new_fe)
        call transformed_fe_function%free()
        call memfree(old_nodal_values,__FILE__,__LINE__)

        do field_id = 1,this%num_fields
           call old_ptr_dofs_x_fe(field_id)%free()
        end do
        deallocate( old_ptr_dofs_x_fe, stat = error ); check( error == 0 )
        call old_lst_dofs_gids%free()  
     end if
  end if
  ! Re-set up coarse_fe_space()
  if ( this%coarse_fe_space_is_set_up() ) then
    call this%setup_coarse_fe_space(this%parameter_list)
  end if

contains
  
  function get_field_fe_dofs()
    implicit none
    integer(ip), pointer     :: get_field_fe_dofs(:)
    integer(ip)              :: spos, epos
    spos = old_ptr_dofs_x_fe(field_id)%get(current_old_cell_lid)
    if ( field_id == this%get_num_fields() ) then
      epos = old_ptr_dofs_x_fe(1)%get(current_old_cell_lid+1)-1
    else
      epos = old_ptr_dofs_x_fe(field_id+1)%get(current_old_cell_lid)-1
    end if
    get_field_fe_dofs => old_lst_dofs_gids%get_pointer(spos,epos)
  end function get_field_fe_dofs
  
  subroutine get_new_lst_dofs_spos_epos(spos,epos)
    implicit none
    integer(ip), intent(inout) :: spos, epos
    spos = this%ptr_dofs_x_fe(field_id)%get(current_new_cell_lid)
    if ( field_id == this%get_num_fields() ) then
      epos = this%ptr_dofs_x_fe(1)%get(current_new_cell_lid+1)-1
    else
      epos = this%ptr_dofs_x_fe(field_id+1)%get(current_new_cell_lid)-1
    end if
  end subroutine get_new_lst_dofs_spos_epos
#else  
  call this%not_enabled_error()
#endif   
end subroutine par_fe_space_refine_and_coarsen_single_fe_function

subroutine par_fe_space_update_after_refine_coarsen(this, old_ptr_dofs_x_fe, old_lst_dofs_gids)
  implicit none
  class(par_fe_space_t)                     , intent(inout) :: this
  type(std_vector_integer_ip_t), allocatable, intent(inout) :: old_ptr_dofs_x_fe(:)
  type(std_vector_integer_ip_t)             , intent(inout) :: old_lst_dofs_gids
  type(environment_t), pointer :: environment
  class(triangulation_t), pointer :: triangulation
  class(p4est_par_triangulation_t), pointer :: par_triangulation
  integer(ip) :: field_id
  type(block_layout_t), pointer :: block_layout
  
#ifdef ENABLE_P4EST  
  triangulation => this%get_triangulation()
  environment   => triangulation%get_environment()
  if ( environment%am_i_l1_task() ) then
     select type(triangulation)
        class is (p4est_par_triangulation_t)
        par_triangulation => triangulation
        class default
        assert(.false.)
     end select
     call this%copy_ptr_lst_dofs(old_ptr_dofs_x_fe,old_lst_dofs_gids)
     call this%project_field_cell_to_ref_fes()
     call this%fill_facet_gids()
     call this%project_fe_integration_arrays()
     call this%project_facet_integration_arrays()
     call this%allocate_and_init_ptr_lst_dofs_gids()
     call this%allocate_and_init_at_strong_dirichlet_bound()
     call this%allocate_and_init_has_fixed_dofs()
     call this%allocate_and_init_has_hanging_dofs_x_fe()
     call this%fill_same_reference_fe_or_void_x_field()
     call this%allocate_and_fill_gen_dof_num_scratch_data()
     call this%set_up_strong_dirichlet_bcs()

     ! Force that a new DoF numbering is generated for the refined/coarsened triangulation
     call this%generate_global_dof_numbering()
  end if
#else  
  call this%not_enabled_error()
#endif
end subroutine par_fe_space_update_after_refine_coarsen

subroutine par_fe_space_project_field_cell_to_ref_fes(this)
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  class(triangulation_t)       , pointer     :: triangulation
  type(std_vector_integer_ip_t), pointer     :: refinement_and_coarsening_flags
  class(fe_cell_iterator_t)    , allocatable :: new_fe
  class(reference_fe_t)        , pointer     :: reference_fe
  integer(ip)                  , pointer     :: p_field_cell_to_ref_fes_field_id(:)
  type(std_vector_integer_ip_t), allocatable :: old_field_cell_to_ref_fes(:)
  integer(ip)                                :: num_children_x_cell
  integer(ip)                                :: subcell_id, old_cell_lid, new_cell_lid
  integer(ip)                                :: field_id
  integer(ip)                                :: transformation_flag
  integer(ip)                                :: old_reference_fe_id
  integer(ip)                                :: old_num_local_cells, old_num_ghost_cells
  class(p4est_base_triangulation_t), pointer :: p4est_triangulation
  class(environment_t)           , pointer :: environment
  type(cell_import_t)              , pointer :: cell_import
  integer(ip) :: istat
 
#ifdef ENABLE_P4EST  
  triangulation => this%get_triangulation()
  select type(triangulation)
  class is (p4est_base_triangulation_t)
    refinement_and_coarsening_flags => triangulation%get_refinement_and_coarsening_flags()
    p4est_triangulation             => triangulation
  class default
    assert(.false.)
  end select
  
  call this%create_fe_cell_iterator(new_fe)
  reference_fe => new_fe%get_reference_fe_geo()
  num_children_x_cell = reference_fe%get_num_n_faces_of_dim(0)
  old_num_local_cells = p4est_triangulation%get_previous_num_local_cells()
  old_num_ghost_cells = p4est_triangulation%get_previous_num_ghost_cells()
  
  ! We have to resize the this%field_cell_to_ref_fes(:) corresponding to all fields
  ! at once before the next loop, because it is a precondition of fe_cell_iterator_t%set_gid()
  ! to work
  allocate(old_field_cell_to_ref_fes(this%num_fields), stat=istat); check(istat==0)
  do field_id = 1,this%num_fields
    call old_field_cell_to_ref_fes(field_id)%copy(this%field_cell_to_ref_fes(field_id))
    call this%field_cell_to_ref_fes(field_id)%resize(0)
    call this%field_cell_to_ref_fes(field_id)%resize(this%triangulation%get_num_cells(),1)
  end do   
  
  do field_id = 1,this%num_fields
    old_cell_lid = 1
    new_cell_lid = 1
    p_field_cell_to_ref_fes_field_id => this%field_cell_to_ref_fes(field_id)%get_pointer()
    do while ( old_cell_lid .le. old_num_local_cells )
      transformation_flag = refinement_and_coarsening_flags%get(old_cell_lid)
      old_reference_fe_id  = old_field_cell_to_ref_fes(field_id)%get(old_cell_lid)
      call new_fe%set_gid(new_cell_lid)
      if ( transformation_flag == do_nothing ) then
        p_field_cell_to_ref_fes_field_id(new_fe%get_gid()) = old_reference_fe_id
        new_cell_lid = new_cell_lid + 1
      else if ( transformation_flag == refinement ) then
        do subcell_id = 0,num_children_x_cell-1
          p_field_cell_to_ref_fes_field_id(new_fe%get_gid()) = old_reference_fe_id
          new_cell_lid = new_cell_lid + 1
          call new_fe%set_gid(new_cell_lid)
        end do
      else if ( transformation_flag == coarsening ) then
        do subcell_id = 1,num_children_x_cell-1
          old_cell_lid = old_cell_lid + 1
          if ( old_reference_fe_id /= old_field_cell_to_ref_fes(field_id)%get(old_cell_lid) ) then
            massert(.false.,'Coarsened subcells do not have the same reference FE id')
          end if
        end do
        p_field_cell_to_ref_fes_field_id(new_fe%get_gid()) = old_reference_fe_id
        new_cell_lid = new_cell_lid + 1
      else
        massert(.false.,'Unrecognised refinement and coarsening flag')
      end if
      old_cell_lid = old_cell_lid + 1
    end do
  end do
  
  massert ( (new_cell_lid - 1) == this%triangulation%get_num_local_cells(), 'Loop in old cells failed to visit all new cells' )
  call this%free_fe_cell_iterator(new_fe)

  do field_id=1, this%num_fields
    call old_field_cell_to_ref_fes(field_id)%free()
  end do  
  deallocate(old_field_cell_to_ref_fes, stat=istat); check(istat==0)
  
  environment => triangulation%get_environment()
  cell_import => triangulation%get_cell_import()
  call environment%l1_neighbours_exchange ( cell_import%get_num_neighbours(), & 
                                            cell_import%get_neighbours_ids(), & 
                                            cell_import%get_rcv_ptrs(),       & 
                                            cell_import%get_rcv_leids(),      & 
                                            cell_import%get_num_neighbours(), & 
                                            cell_import%get_neighbours_ids(), & 
                                            cell_import%get_snd_ptrs(),       & 
                                            cell_import%get_snd_leids(),      & 
                                            p_field_cell_to_ref_fes_field_id, & 
                                            p_field_cell_to_ref_fes_field_id )
  
#else  
  call this%not_enabled_error()
#endif  
end subroutine par_fe_space_project_field_cell_to_ref_fes

subroutine par_fe_space_migrate_field_cell_to_ref_fes ( this ) 
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  class(environment_t), pointer :: environment
  class(cell_import_t), pointer :: cell_import
  class(triangulation_t), pointer :: triangulation
  class(p4est_par_triangulation_t), pointer :: par_triangulation
  integer(ip) :: i, field_id, error
  
  integer(ip)          :: num_rcv
  integer(ip), pointer :: lst_rcv(:)
  integer(ip), pointer :: rcv_ptrs(:)
  integer(ip), pointer :: unpack_idx(:)
  
  integer(ip)          :: num_snd
  integer(ip), pointer :: lst_snd(:)
  integer(ip), pointer :: snd_ptrs(:)
  integer(ip), pointer :: pack_idx(:)
  
  integer(ip), pointer :: new2old(:)
  integer(ip), pointer :: old2new(:)
  
  type(std_vector_integer_ip_t)          :: old_field_cell_to_ref_fes
  integer(ip)                  , pointer :: p_old_field_cell_to_ref_fes(:)
  integer(ip)                  , pointer :: p_field_cell_to_ref_fes(:)
  
#ifdef ENABLE_P4EST  
  
  triangulation => this%get_triangulation()
  environment   => triangulation%get_environment()
  cell_import => triangulation%get_cell_import()
  
  if ( environment%am_i_l1_task() ) then
     
     select type(triangulation)
        class is (p4est_par_triangulation_t)
        par_triangulation => triangulation
        class default
        assert(.false.)
     end select
     
     num_rcv     =  par_triangulation%get_migration_num_rcv()
     lst_rcv     => par_triangulation%get_migration_lst_rcv()
     rcv_ptrs    => par_triangulation%get_migration_rcv_ptrs()
     unpack_idx  => par_triangulation%get_migration_unpack_idx()
     
     num_snd     =  par_triangulation%get_migration_num_snd()
     lst_snd     => par_triangulation%get_migration_lst_snd()
     snd_ptrs    => par_triangulation%get_migration_snd_ptrs()
     pack_idx    => par_triangulation%get_migration_pack_idx()
     
     new2old     => par_triangulation%get_migration_new2old()
     
     do field_id = 1,this%num_fields
       
       call old_field_cell_to_ref_fes%copy(this%field_cell_to_ref_fes(field_id))
       call this%field_cell_to_ref_fes(field_id)%resize(0)
       call this%field_cell_to_ref_fes(field_id)%resize(triangulation%get_num_cells())
       
       p_old_field_cell_to_ref_fes => old_field_cell_to_ref_fes%get_pointer()
       p_field_cell_to_ref_fes     => this%field_cell_to_ref_fes(field_id)%get_pointer()
       
       do i=1, triangulation%get_num_local_cells()
         if ( new2old(i) /= 0 ) then
           p_field_cell_to_ref_fes(i) = p_old_field_cell_to_ref_fes(new2old(i))
         end if
       end do
       
       call environment%l1_neighbours_exchange ( num_rcv, lst_rcv, rcv_ptrs , unpack_idx, &
                                                 num_snd, lst_snd, snd_ptrs, pack_idx,    &
                                                 p_old_field_cell_to_ref_fes,             &
                                                 p_field_cell_to_ref_fes )
       
       call environment%l1_neighbours_exchange ( cell_import%get_num_neighbours(), &
                                                 cell_import%get_neighbours_ids(), &
                                                 cell_import%get_rcv_ptrs(),       &
                                                 cell_import%get_rcv_leids(),      &
                                                 cell_import%get_num_neighbours(), &
                                                 cell_import%get_neighbours_ids(), &
                                                 cell_import%get_snd_ptrs(),       &
                                                 cell_import%get_snd_leids(),      &
                                                 p_field_cell_to_ref_fes,          &
                                                 p_field_cell_to_ref_fes )
       
     end do
     
     call old_field_cell_to_ref_fes%free()
  
  end if
#else  
  call this%not_enabled_error()
#endif   
  

end subroutine par_fe_space_migrate_field_cell_to_ref_fes

subroutine par_fe_space_migrate_fe_integration_arrays(this)
  implicit none
  class(par_fe_space_t)                     , intent(inout) :: this
#ifdef ENABLE_P4EST  
#else  
  call this%not_enabled_error()
#endif    
end subroutine par_fe_space_migrate_fe_integration_arrays

subroutine par_fe_space_migrate_facet_integration_arrays(this)
  implicit none
  class(par_fe_space_t)                     , intent(inout) :: this
#ifdef ENABLE_P4EST  
#else  
  call this%not_enabled_error()
#endif    
end subroutine par_fe_space_migrate_facet_integration_arrays

subroutine par_fe_space_update_after_redistribute(this, old_ptr_dofs_x_fe, old_lst_dofs_gids)
  implicit none
  class(par_fe_space_t)                     , intent(inout) :: this
  type(std_vector_integer_ip_t), allocatable, intent(inout) :: old_ptr_dofs_x_fe(:)
  type(std_vector_integer_ip_t)             , intent(inout) :: old_lst_dofs_gids
  type(environment_t), pointer :: environment
  class(triangulation_t), pointer :: triangulation
  class(p4est_par_triangulation_t), pointer :: par_triangulation
  integer(ip) :: field_id
  type(block_layout_t), pointer :: block_layout

#ifdef ENABLE_P4EST  
  triangulation => this%get_triangulation()
  environment   => triangulation%get_environment()
  if ( environment%am_i_l1_task() ) then
     select type(triangulation)
        class is (p4est_par_triangulation_t)
        par_triangulation => triangulation
        class default
        assert(.false.)
     end select
     call this%copy_ptr_lst_dofs(old_ptr_dofs_x_fe,old_lst_dofs_gids)
     call this%migrate_field_cell_to_ref_fes()
     call this%fill_facet_gids()
     call this%migrate_fe_integration_arrays()
     call this%migrate_facet_integration_arrays()
     call this%allocate_and_fill_fe_space_type_x_field()
     call this%allocate_and_init_ptr_lst_dofs_gids()
     call this%allocate_and_init_at_strong_dirichlet_bound()
     call this%allocate_and_init_has_fixed_dofs()
     call this%allocate_and_init_has_hanging_dofs_x_fe()
     call this%fill_same_reference_fe_or_void_x_field()
     call this%allocate_and_fill_gen_dof_num_scratch_data()
     call this%set_up_strong_dirichlet_bcs()

     ! Force that a new DoF numbering is generated for the redistributed triangulation
     call this%generate_global_dof_numbering()
  end if
#else  
  call this%not_enabled_error()
#endif
end subroutine par_fe_space_update_after_redistribute

subroutine par_fe_space_refine_and_coarsen_fe_function_array (this, fe_functions)
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  type(p_fe_function_t), intent(inout) :: fe_functions(:)
  class(triangulation_t), pointer :: triangulation
  class(p4est_par_triangulation_t), pointer :: par_triangulation
  type(fe_function_t) :: transformed_fe_function
  type(std_vector_integer_ip_t), pointer :: refinement_and_coarsening_flags
  type(std_vector_integer_ip_t), allocatable :: old_ptr_dofs_x_fe(:)
  type(std_vector_integer_ip_t) :: old_lst_dofs_gids
  integer(ip), pointer :: old_field_fe_dofs(:)
  integer(ip) :: num_children_x_cell
  integer(ip) :: transformation_flag
  integer(ip) :: subcell_id, old_cell_lid, new_cell_lid
  integer(ip) :: current_old_cell_lid, current_new_cell_lid
  integer(ip) :: old_num_local_cells
  integer(ip) :: old_num_ghost_cells
  integer(ip) :: field_id
  class(fe_cell_iterator_t)         , allocatable :: new_fe
  real(rp)                          , allocatable :: old_nodal_values(:,:)
  real(rp)                          , allocatable :: new_nodal_values(:)
  class(reference_fe_t)             , pointer     :: reference_fe
  integer(ip)                                     :: num_nodes_field
  type(block_layout_t)              , pointer     :: block_layout
  integer(ip)                                     :: error
  integer(ip) :: spos, epos
  real(rp), pointer :: p_new_fe_function_nodal_values(:)
  type(environment_t), pointer :: environment
  class(cell_import_t), pointer :: cell_import
  integer(ip) :: ifunc
  
  
#ifdef ENABLE_P4EST  
  triangulation => this%get_triangulation()
  environment => triangulation%get_environment()
  if ( environment%am_i_l1_task() ) then
     select type(triangulation)
        class is (p4est_par_triangulation_t)
        par_triangulation => triangulation
        refinement_and_coarsening_flags => triangulation%get_refinement_and_coarsening_flags()
        class default
        assert(.false.)
     end select

     if ( par_triangulation%get_num_cells() > 0 ) then
        old_num_local_cells = par_triangulation%get_previous_num_local_cells()
        old_num_ghost_cells = par_triangulation%get_previous_num_ghost_cells()
        
        call this%update_after_refine_coarsen(old_ptr_dofs_x_fe,old_lst_dofs_gids)

        call this%new_fe_function_nodal_values%resize(0)
        call this%new_fe_function_nodal_values%resize(this%ptr_dofs_x_fe(1)%get(triangulation%get_num_cells()+1)-1)
        p_new_fe_function_nodal_values => this%new_fe_function_nodal_values%get_pointer()

        call this%create_fe_cell_iterator(new_fe)
        reference_fe => new_fe%get_reference_fe_geo()
        num_children_x_cell = reference_fe%get_num_n_faces_of_dim(0)
        call memalloc(num_children_x_cell, &
             this%get_max_num_shape_functions(),old_nodal_values,__FILE__,__LINE__)

        do ifunc = 1,size(fe_functions)
        
          call transformed_fe_function%create(this)

          old_cell_lid = 1
          new_cell_lid = 1
          do while ( old_cell_lid .le. old_num_local_cells )
             transformation_flag = refinement_and_coarsening_flags%get(old_cell_lid)
             do field_id = 1,this%get_num_fields()
                call new_fe%set_gid(new_cell_lid)
                current_old_cell_lid = old_cell_lid
                current_new_cell_lid = new_cell_lid
                reference_fe => new_fe%get_reference_fe(field_id) ! Only h-adaptivity
                num_nodes_field = reference_fe%get_num_shape_functions()
                old_field_fe_dofs => get_field_fe_dofs()
                call fe_functions(ifunc)%p%gather_nodal_values( field_id, & 
                     old_field_fe_dofs, &
                     num_nodes_field, & 
                     this%get_field_blocks(), &
                     old_nodal_values(1,1:num_nodes_field) )

                if ( transformation_flag == do_nothing ) then
                   call get_new_lst_dofs_spos_epos(spos,epos)
                   p_new_fe_function_nodal_values(spos:epos) = old_nodal_values(1,1:num_nodes_field)
                   current_new_cell_lid = current_new_cell_lid + 1
                else if ( transformation_flag == refinement ) then
                   do subcell_id = 0,num_children_x_cell-1
                      call get_new_lst_dofs_spos_epos(spos,epos)
                      select type(reference_fe)
                      class is (hex_lagrangian_reference_fe_t)
                         call reference_fe%interpolate_nodal_values_on_subcell( subcell_id, & 
                              old_nodal_values(1,1:num_nodes_field), &
                              p_new_fe_function_nodal_values(spos:epos) )
                      type is (void_reference_fe_t)
                         ! Do nothing
                         class default
                         assert(.false.)
                      end select
                      current_new_cell_lid = current_new_cell_lid + 1
                      call new_fe%set_gid(current_new_cell_lid)
                   end do
                else if ( transformation_flag == coarsening ) then
                   do subcell_id = 1,num_children_x_cell-1
                      current_old_cell_lid = current_old_cell_lid + 1
                      old_field_fe_dofs => get_field_fe_dofs()
                      call fe_functions(ifunc)%p%gather_nodal_values( field_id, & 
                           old_field_fe_dofs, &
                           num_nodes_field, & 
                           this%get_field_blocks(), &
                           old_nodal_values(subcell_id+1,1:num_nodes_field) )
                   end do
                   call get_new_lst_dofs_spos_epos(spos,epos)
                   select type(reference_fe)
                   class is (hex_lagrangian_reference_fe_t)
                      call reference_fe%project_nodal_values_on_cell( old_nodal_values(:,1:num_nodes_field), &
                           p_new_fe_function_nodal_values(spos:epos) )
                   type is (void_reference_fe_t)
                      ! Do nothing
                      class default
                      assert(.false.)
                   end select
                   current_new_cell_lid = current_new_cell_lid + 1
                else
                   massert(.false.,'Unrecognised refinement and coarsening flag')
                end if
             end do
             old_cell_lid = current_old_cell_lid
             new_cell_lid = current_new_cell_lid
             old_cell_lid = old_cell_lid + 1
          end do
          
          ! Retrieve set IDs from ghost cells
          cell_import => triangulation%get_cell_import()
          call environment%l1_neighbours_exchange ( cell_import%get_num_neighbours(), &
                                                    cell_import%get_neighbours_ids(),&
                                                    cell_import%get_rcv_ptrs(),&
                                                    cell_import%get_rcv_leids(),&
                                                    cell_import%get_num_neighbours(), &
                                                    cell_import%get_neighbours_ids(),&
                                                    cell_import%get_snd_ptrs(),&
                                                    cell_import%get_snd_leids(),&
                                                    p_new_fe_function_nodal_values, &
                                                    p_new_fe_function_nodal_values, &
                                                    this%ptr_dofs_x_fe(1)%get_pointer(), &
                                                    this%ptr_dofs_x_fe(1)%get_pointer() )
          
          !  massert ( new_cell_lid - 1 == this%triangulation%get_num_cells(), 'Loop in old cells failed to visit all new cells' )
          !  
          call fe_functions(ifunc)%p%create(this)
          call fe_functions(ifunc)%p%copy(transformed_fe_function)

          call new_fe%first()
          do while ( .not. new_fe%has_finished() )
            current_new_cell_lid = new_fe%get_gid() 
            do field_id=1, this%num_fields 
              call get_new_lst_dofs_spos_epos(spos,epos)
              call fe_functions(ifunc)%p%insert_nodal_values( new_fe,   &
                                                              field_id, &
                                                              p_new_fe_function_nodal_values(spos:epos))
            end do 
            call new_fe%next()
          end do
          
          call this%update_hanging_dof_values(fe_functions(ifunc)%p)
          
        end do
        
        select type(triangulation)
           class is (p4est_par_triangulation_t)
           call triangulation%clear_refinement_and_coarsening_flags()
           class default
           assert(.false.)
        end select
        
        call this%free_fe_cell_iterator(new_fe)
        call transformed_fe_function%free()
        call memfree(old_nodal_values,__FILE__,__LINE__)

        do field_id = 1,this%num_fields
           call old_ptr_dofs_x_fe(field_id)%free()
        end do
        deallocate( old_ptr_dofs_x_fe, stat = error ); check( error == 0 )
        call old_lst_dofs_gids%free()  
     end if
  end if
  ! Re-set up coarse_fe_space()
  if ( this%coarse_fe_space_is_set_up() ) then
    call this%setup_coarse_fe_space(this%parameter_list)
  end if

contains
  
  function get_field_fe_dofs()
    implicit none
    integer(ip), pointer     :: get_field_fe_dofs(:)
    integer(ip)              :: spos, epos
    spos = old_ptr_dofs_x_fe(field_id)%get(current_old_cell_lid)
    if ( field_id == this%get_num_fields() ) then
      epos = old_ptr_dofs_x_fe(1)%get(current_old_cell_lid+1)-1
    else
      epos = old_ptr_dofs_x_fe(field_id+1)%get(current_old_cell_lid)-1
    end if
    get_field_fe_dofs => old_lst_dofs_gids%get_pointer(spos,epos)
  end function get_field_fe_dofs
  
  subroutine get_new_lst_dofs_spos_epos(spos,epos)
    implicit none
    integer(ip), intent(inout) :: spos, epos
    spos = this%ptr_dofs_x_fe(field_id)%get(current_new_cell_lid)
    if ( field_id == this%get_num_fields() ) then
      epos = this%ptr_dofs_x_fe(1)%get(current_new_cell_lid+1)-1
    else
      epos = this%ptr_dofs_x_fe(field_id+1)%get(current_new_cell_lid)-1
    end if
  end subroutine get_new_lst_dofs_spos_epos
#else  
  call this%not_enabled_error()
#endif   
end subroutine par_fe_space_refine_and_coarsen_fe_function_array

subroutine par_fe_space_redistribute_single_fe_function( this, fe_function ) 
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  type(fe_function_t)  , intent(inout) :: fe_function
  
  integer(ip)          :: num_rcv
  integer(ip), pointer :: lst_rcv(:)
  integer(ip), pointer :: rcv_ptrs(:)
  integer(ip), pointer :: unpack_idx(:)
  
  integer(ip)          :: num_snd
  integer(ip), pointer :: lst_snd(:)
  integer(ip), pointer :: snd_ptrs(:)
  integer(ip), pointer :: pack_idx(:)
  
  integer(ip), pointer :: new2old(:)
  integer(ip), pointer :: old2new(:)
  
  integer(ip) :: spos, epos

  class(triangulation_t), pointer :: triangulation
  class(p4est_par_triangulation_t), pointer :: p4est_par_triangulation
  class(environment_t), pointer :: environment
  class(fe_cell_iterator_t), allocatable :: fe
  integer(ip) :: old_num_local_cells, old_num_ghost_cells
  integer(ip) :: field_id
  type(std_vector_integer_ip_t), allocatable :: old_ptr_dofs_x_fe(:)
  type(std_vector_integer_ip_t) :: old_lst_dofs_gids
  integer(ip) :: error
  real(rp), pointer :: p_new_fe_function_nodal_values(:)
  real(rp), pointer :: p_old_fe_function_nodal_values(:)
  integer(ip) :: old_cell_gid
  integer(ip), pointer :: old_field_fe_dofs(:)
  real(rp), allocatable :: old_nodal_values(:,:)
  integer(ip) :: max_num_dofs
  integer(ip) :: current_old_cell_lid, old_cell_lid
  integer(ip) :: num_nodes_field
  integer(ip) :: base_pos_old, base_pos_new
  integer(ip) :: idof, num_dofs
  integer(ip) :: i, current_new_cell_lid
  type(cell_import_t), pointer :: cell_import

#ifdef ENABLE_P4EST
  triangulation => this%get_triangulation()
  environment   => triangulation%get_environment()
  if ( environment%am_i_l1_task() ) then
    select type(triangulation)
     class is (p4est_par_triangulation_t)
       p4est_par_triangulation => triangulation
     class default
       assert(.false.)
    end select
    
    num_rcv     =  p4est_par_triangulation%get_migration_num_rcv()
    lst_rcv     => p4est_par_triangulation%get_migration_lst_rcv()
    rcv_ptrs    => p4est_par_triangulation%get_migration_rcv_ptrs()
    unpack_idx  => p4est_par_triangulation%get_migration_unpack_idx()
    
    num_snd     =  p4est_par_triangulation%get_migration_num_snd()
    lst_snd     => p4est_par_triangulation%get_migration_lst_snd()
    snd_ptrs    => p4est_par_triangulation%get_migration_snd_ptrs()
    pack_idx    => p4est_par_triangulation%get_migration_pack_idx()
    
    new2old     => p4est_par_triangulation%get_migration_new2old()
    
    if ( p4est_par_triangulation%get_num_cells() > 0 .or. num_snd>0 ) then
      old_num_local_cells = p4est_par_triangulation%get_previous_num_local_cells()
      old_num_ghost_cells = p4est_par_triangulation%get_previous_num_ghost_cells()
      call this%update_after_redistribute(old_ptr_dofs_x_fe, &
                                          old_lst_dofs_gids)
    
      call this%old_fe_function_nodal_values%resize(0)
      call this%old_fe_function_nodal_values%resize(old_ptr_dofs_x_fe(1)%get(old_num_local_cells+old_num_ghost_cells+1)-1)
      p_old_fe_function_nodal_values => this%old_fe_function_nodal_values%get_pointer() 
          
      old_cell_lid = 1
      do while ( old_cell_lid .le. old_num_local_cells )
        do field_id = 1,this%get_num_fields()
          current_old_cell_lid = old_cell_lid
          old_field_fe_dofs => get_field_fe_dofs()
          num_nodes_field = size(old_field_fe_dofs)
          call get_old_lst_dofs_spos_epos(spos,epos)
          call fe_function%gather_nodal_values( field_id, & 
                                                old_field_fe_dofs, &
                                                num_nodes_field, & 
                                                this%get_field_blocks(), &
                                                p_old_fe_function_nodal_values(spos:epos) )
        end do   
        old_cell_lid = old_cell_lid + 1
      end do
      
      call this%new_fe_function_nodal_values%resize(0)
      call this%new_fe_function_nodal_values%resize(this%ptr_dofs_x_fe(1)%get(p4est_par_triangulation%get_num_cells()+1)-1)
      p_new_fe_function_nodal_values => this%new_fe_function_nodal_values%get_pointer() 
    
      ! Transfer vef set IDs of local cells
      do i=1, p4est_par_triangulation%get_num_local_cells()
        if (new2old(i) /= 0) then
          current_new_cell_lid = i
          do field_id=1, this%num_fields
            base_pos_old = old_ptr_dofs_x_fe(1)%get(new2old(i))-1
            base_pos_new = this%ptr_dofs_x_fe(1)%get(i)-1
            num_dofs = get_new_num_dofs()
            do idof=1, num_dofs
              p_new_fe_function_nodal_values(base_pos_new+idof) = &
                 p_old_fe_function_nodal_values(base_pos_old+idof)
            end do
          end do 
        end if  
      end do
      
      field_id = 1
      current_new_cell_lid = 1
      num_dofs = get_new_num_dofs()
      
      ! Transfer vef set IDs of remote cells
      call environment%l1_neighbours_exchange (num_rcv, lst_rcv, rcv_ptrs, unpack_idx, &
                                               num_snd, lst_snd, snd_ptrs, pack_idx, &
                                               p_old_fe_function_nodal_values, &
                                               p_new_fe_function_nodal_values, &
                                               old_ptr_dofs_x_fe(1)%get_pointer(), &
                                               this%ptr_dofs_x_fe(1)%get_pointer() )
  
      ! Retrieve set IDs from ghost cells
      cell_import => p4est_par_triangulation%get_cell_import()
      call environment%l1_neighbours_exchange ( cell_import%get_num_neighbours(), &
                                                cell_import%get_neighbours_ids(),&
                                                cell_import%get_rcv_ptrs(),&
                                                cell_import%get_rcv_leids(),&
                                                cell_import%get_num_neighbours(), &
                                                cell_import%get_neighbours_ids(),&
                                                cell_import%get_snd_ptrs(),&
                                                cell_import%get_snd_leids(),&
                                                p_new_fe_function_nodal_values, &
                                                p_new_fe_function_nodal_values, &
                                                this%ptr_dofs_x_fe(1)%get_pointer(), &
                                                this%ptr_dofs_x_fe(1)%get_pointer() )  
      
        
        
      call p4est_par_triangulation%clear_refinement_and_coarsening_flags()
        
      call fe_function%create(this)
      call this%create_fe_cell_iterator(fe)
      do while ( .not. fe%has_finished() )
        current_new_cell_lid = fe%get_gid() 
        do field_id=1, this%num_fields 
            call get_new_lst_dofs_spos_epos(spos,epos)
            call fe_function%insert_nodal_values( fe,   &
                                                  field_id, &
                                                  p_new_fe_function_nodal_values(spos:epos))
        end do     
        call fe%next()
      end do
            
      do field_id = 1,this%num_fields
        call old_ptr_dofs_x_fe(field_id)%free()
      end do
      deallocate( old_ptr_dofs_x_fe, stat = error ); check( error == 0 )
      call old_lst_dofs_gids%free()  
      call this%free_fe_cell_iterator(fe)
     end if 
  end if
  ! Re-set up coarse_fe_space()
  if ( this%coarse_fe_space_is_set_up() ) then
    call this%setup_coarse_fe_space(this%parameter_list)
  end if

 contains 

  function get_field_fe_dofs()
    implicit none
    integer(ip), pointer     :: get_field_fe_dofs(:)
    integer(ip)              :: spos, epos
    spos = old_ptr_dofs_x_fe(field_id)%get(current_old_cell_lid)
    if ( field_id == this%get_num_fields() ) then
      epos = old_ptr_dofs_x_fe(1)%get(current_old_cell_lid+1)-1
    else
      epos = old_ptr_dofs_x_fe(field_id+1)%get(current_old_cell_lid)-1
    end if
    get_field_fe_dofs => old_lst_dofs_gids%get_pointer(spos,epos)
  end function get_field_fe_dofs
    
  subroutine get_old_lst_dofs_spos_epos(spos,epos)
    implicit none
    integer(ip), intent(inout) :: spos, epos
    spos = old_ptr_dofs_x_fe(field_id)%get(current_old_cell_lid)
    if ( field_id == this%get_num_fields() ) then
      epos = old_ptr_dofs_x_fe(1)%get(current_old_cell_lid+1)-1
    else
      epos = old_ptr_dofs_x_fe(field_id+1)%get(current_old_cell_lid)-1
    end if
  end subroutine get_old_lst_dofs_spos_epos
  
  function get_new_num_dofs()
    implicit none
    integer(ip) :: get_new_num_dofs
    integer(ip) :: spos, epos
    spos = this%ptr_dofs_x_fe(field_id)%get(current_new_cell_lid)
    if ( field_id == this%get_num_fields() ) then
      if ( this%ptr_dofs_x_fe(1)%size() > 1 ) then 
      epos = this%ptr_dofs_x_fe(1)%get(current_new_cell_lid+1)-1
      else 
      epos = old_ptr_dofs_x_fe(1)%get(current_new_cell_lid+1)-1
      end if 
    else
      if ( this%ptr_dofs_x_fe(field_id+1)%size() > 1 ) then
      epos = this%ptr_dofs_x_fe(field_id+1)%get(current_new_cell_lid)-1
      else 
      epos = old_ptr_dofs_x_fe(field_id+1)%get(current_new_cell_lid)-1
      end if 
    end if
    get_new_num_dofs = epos-spos+1
  end function get_new_num_dofs
  
  subroutine get_new_lst_dofs_spos_epos(spos,epos)
    implicit none
    integer(ip), intent(inout) :: spos, epos
    spos = this%ptr_dofs_x_fe(field_id)%get(current_new_cell_lid)
    if ( field_id == this%get_num_fields() ) then
      epos = this%ptr_dofs_x_fe(1)%get(current_new_cell_lid+1)-1
    else
      epos = this%ptr_dofs_x_fe(field_id+1)%get(current_new_cell_lid)-1
    end if
  end subroutine get_new_lst_dofs_spos_epos 
#else
  call this%not_enabled_error()
#endif
end subroutine par_fe_space_redistribute_single_fe_function

subroutine par_fe_space_redistribute_fe_function_array( this, fe_functions ) 
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  type(p_fe_function_t), intent(inout) :: fe_functions(:)
  
  integer(ip)          :: num_rcv
  integer(ip), pointer :: lst_rcv(:)
  integer(ip), pointer :: rcv_ptrs(:)
  integer(ip), pointer :: unpack_idx(:)
  
  integer(ip)          :: num_snd
  integer(ip), pointer :: lst_snd(:)
  integer(ip), pointer :: snd_ptrs(:)
  integer(ip), pointer :: pack_idx(:)
  
  integer(ip), pointer :: new2old(:)
  integer(ip), pointer :: old2new(:)
  
  integer(ip) :: spos, epos

  class(triangulation_t), pointer :: triangulation
  class(p4est_par_triangulation_t), pointer :: p4est_par_triangulation
  class(environment_t), pointer :: environment
  class(fe_cell_iterator_t), allocatable :: fe
  integer(ip) :: old_num_local_cells, old_num_ghost_cells
  integer(ip) :: field_id
  type(std_vector_integer_ip_t), allocatable :: old_ptr_dofs_x_fe(:)
  type(std_vector_integer_ip_t) :: old_lst_dofs_gids
  integer(ip) :: error
  real(rp), pointer :: p_new_fe_function_nodal_values(:)
  real(rp), pointer :: p_old_fe_function_nodal_values(:)
  integer(ip) :: old_cell_gid
  integer(ip), pointer :: old_field_fe_dofs(:)
  real(rp), allocatable :: old_nodal_values(:,:)
  integer(ip) :: max_num_dofs
  integer(ip) :: current_old_cell_lid, old_cell_lid
  integer(ip) :: num_nodes_field
  integer(ip) :: base_pos_old, base_pos_new
  integer(ip) :: idof, num_dofs
  integer(ip) :: i, current_new_cell_lid
  type(cell_import_t), pointer :: cell_import
  
  integer(ip) :: ifunc

#ifdef ENABLE_P4EST
  triangulation => this%get_triangulation()
  environment   => triangulation%get_environment()
  if ( environment%am_i_l1_task() ) then
    select type(triangulation)
     class is (p4est_par_triangulation_t)
       p4est_par_triangulation => triangulation
     class default
       assert(.false.)
    end select
    
    num_rcv     =  p4est_par_triangulation%get_migration_num_rcv()
    lst_rcv     => p4est_par_triangulation%get_migration_lst_rcv()
    rcv_ptrs    => p4est_par_triangulation%get_migration_rcv_ptrs()
    unpack_idx  => p4est_par_triangulation%get_migration_unpack_idx()
    
    num_snd     =  p4est_par_triangulation%get_migration_num_snd()
    lst_snd     => p4est_par_triangulation%get_migration_lst_snd()
    snd_ptrs    => p4est_par_triangulation%get_migration_snd_ptrs()
    pack_idx    => p4est_par_triangulation%get_migration_pack_idx()
    
    new2old     => p4est_par_triangulation%get_migration_new2old()
    
    if ( p4est_par_triangulation%get_num_cells() > 0 .or. num_snd>0 ) then
      old_num_local_cells = p4est_par_triangulation%get_previous_num_local_cells()
      old_num_ghost_cells = p4est_par_triangulation%get_previous_num_ghost_cells()
      call this%update_after_redistribute(old_ptr_dofs_x_fe, &
                                          old_lst_dofs_gids)
    
      call this%old_fe_function_nodal_values%resize(0)
      call this%old_fe_function_nodal_values%resize(old_ptr_dofs_x_fe(1)%get(old_num_local_cells+old_num_ghost_cells+1)-1)
      p_old_fe_function_nodal_values => this%old_fe_function_nodal_values%get_pointer() 
          
      call this%new_fe_function_nodal_values%resize(0)
      call this%new_fe_function_nodal_values%resize(this%ptr_dofs_x_fe(1)%get(p4est_par_triangulation%get_num_cells()+1)-1)
      p_new_fe_function_nodal_values => this%new_fe_function_nodal_values%get_pointer()
      
      do ifunc = 1,size(fe_functions)
        
        old_cell_lid = 1
        do while ( old_cell_lid .le. old_num_local_cells )
          do field_id = 1,this%get_num_fields()
            current_old_cell_lid = old_cell_lid
            old_field_fe_dofs => get_field_fe_dofs()
            num_nodes_field = size(old_field_fe_dofs)
            call get_old_lst_dofs_spos_epos(spos,epos)
            call fe_functions(ifunc)%p%gather_nodal_values( field_id, & 
                                                            old_field_fe_dofs, &
                                                            num_nodes_field, & 
                                                            this%get_field_blocks(), &
                                                            p_old_fe_function_nodal_values(spos:epos) )
          end do   
          old_cell_lid = old_cell_lid + 1
        end do
        
        ! Transfer vef set IDs of local cells
        do i=1, p4est_par_triangulation%get_num_local_cells()
          if (new2old(i) /= 0) then
            current_new_cell_lid = i
            do field_id=1, this%num_fields
              base_pos_old = old_ptr_dofs_x_fe(1)%get(new2old(i))-1
              base_pos_new = this%ptr_dofs_x_fe(1)%get(i)-1
              num_dofs = get_new_num_dofs()
              do idof=1, num_dofs
                p_new_fe_function_nodal_values(base_pos_new+idof) = &
                   p_old_fe_function_nodal_values(base_pos_old+idof)
              end do
            end do 
          end if  
        end do
        
        field_id = 1
        current_new_cell_lid = 1
        num_dofs = get_new_num_dofs()
        
        ! Transfer vef set IDs of remote cells
        call environment%l1_neighbours_exchange (num_rcv, lst_rcv, rcv_ptrs, unpack_idx, &
                                                 num_snd, lst_snd, snd_ptrs, pack_idx, &
                                                 p_old_fe_function_nodal_values, &
                                                 p_new_fe_function_nodal_values, &
                                                 old_ptr_dofs_x_fe(1)%get_pointer(), &
                                                 this%ptr_dofs_x_fe(1)%get_pointer() )
    
        ! Retrieve set IDs from ghost cells
        cell_import => p4est_par_triangulation%get_cell_import()
        call environment%l1_neighbours_exchange ( cell_import%get_num_neighbours(), &
                                                  cell_import%get_neighbours_ids(),&
                                                  cell_import%get_rcv_ptrs(),&
                                                  cell_import%get_rcv_leids(),&
                                                  cell_import%get_num_neighbours(), &
                                                  cell_import%get_neighbours_ids(),&
                                                  cell_import%get_snd_ptrs(),&
                                                  cell_import%get_snd_leids(),&
                                                  p_new_fe_function_nodal_values, &
                                                  p_new_fe_function_nodal_values, &
                                                  this%ptr_dofs_x_fe(1)%get_pointer(), &
                                                  this%ptr_dofs_x_fe(1)%get_pointer() )  
        
          
          
        call fe_functions(ifunc)%p%create(this)
        call this%create_fe_cell_iterator(fe)
        do while ( .not. fe%has_finished() )
          current_new_cell_lid = fe%get_gid() 
          do field_id=1, this%num_fields 
              call get_new_lst_dofs_spos_epos(spos,epos)
              call fe_functions(ifunc)%p%insert_nodal_values( fe,   &
                                                              field_id, &
                                                              p_new_fe_function_nodal_values(spos:epos))
          end do     
          call fe%next()
        end do
      
      end do
      
      call p4est_par_triangulation%clear_refinement_and_coarsening_flags()
      
      do field_id = 1,this%num_fields
        call old_ptr_dofs_x_fe(field_id)%free()
      end do
      deallocate( old_ptr_dofs_x_fe, stat = error ); check( error == 0 )
      call old_lst_dofs_gids%free()  
      call this%free_fe_cell_iterator(fe)
    end if 
  end if
  ! Re-set up coarse_fe_space()
  if ( this%coarse_fe_space_is_set_up() ) then
    call this%setup_coarse_fe_space(this%parameter_list)
  end if
  
 contains 

  function get_field_fe_dofs()
    implicit none
    integer(ip), pointer     :: get_field_fe_dofs(:)
    integer(ip)              :: spos, epos
    spos = old_ptr_dofs_x_fe(field_id)%get(current_old_cell_lid)
    if ( field_id == this%get_num_fields() ) then
      epos = old_ptr_dofs_x_fe(1)%get(current_old_cell_lid+1)-1
    else
      epos = old_ptr_dofs_x_fe(field_id+1)%get(current_old_cell_lid)-1
    end if
    get_field_fe_dofs => old_lst_dofs_gids%get_pointer(spos,epos)
  end function get_field_fe_dofs
    
  subroutine get_old_lst_dofs_spos_epos(spos,epos)
    implicit none
    integer(ip), intent(inout) :: spos, epos
    spos = old_ptr_dofs_x_fe(field_id)%get(current_old_cell_lid)
    if ( field_id == this%get_num_fields() ) then
      epos = old_ptr_dofs_x_fe(1)%get(current_old_cell_lid+1)-1
    else
      epos = old_ptr_dofs_x_fe(field_id+1)%get(current_old_cell_lid)-1
    end if
  end subroutine get_old_lst_dofs_spos_epos
  
  function get_new_num_dofs()
    implicit none
    integer(ip) :: get_new_num_dofs
    integer(ip) :: spos, epos
    spos = this%ptr_dofs_x_fe(field_id)%get(current_new_cell_lid)
    if ( field_id == this%get_num_fields() ) then
      if ( this%ptr_dofs_x_fe(1)%size() > 1 ) then 
      epos = this%ptr_dofs_x_fe(1)%get(current_new_cell_lid+1)-1
      else 
      epos = old_ptr_dofs_x_fe(1)%get(current_new_cell_lid+1)-1
      end if 
    else
      if ( this%ptr_dofs_x_fe(field_id+1)%size() > 1 ) then
      epos = this%ptr_dofs_x_fe(field_id+1)%get(current_new_cell_lid)-1
      else 
      epos = old_ptr_dofs_x_fe(field_id+1)%get(current_new_cell_lid)-1
      end if 
    end if
    get_new_num_dofs = epos-spos+1
  end function get_new_num_dofs
  
  subroutine get_new_lst_dofs_spos_epos(spos,epos)
    implicit none
    integer(ip), intent(inout) :: spos, epos
    spos = this%ptr_dofs_x_fe(field_id)%get(current_new_cell_lid)
    if ( field_id == this%get_num_fields() ) then
      epos = this%ptr_dofs_x_fe(1)%get(current_new_cell_lid+1)-1
    else
      epos = this%ptr_dofs_x_fe(field_id+1)%get(current_new_cell_lid)-1
    end if
  end subroutine get_new_lst_dofs_spos_epos 
#else
  call this%not_enabled_error()
#endif
end subroutine par_fe_space_redistribute_fe_function_array

 subroutine par_fe_space_create_fe_object_iterator (this,fe_object)
    implicit none
    class(par_fe_space_t)     , intent(in)    :: this
    type(fe_object_iterator_t), intent(inout) :: fe_object
    call fe_object%create(this)
 end subroutine par_fe_space_create_fe_object_iterator
 
 subroutine par_fe_space_free_fe_object_iterator (this,fe_object)
    implicit none
    class(par_fe_space_t)     , intent(in)    :: this
    type(fe_object_iterator_t), intent(inout) :: fe_object
    call fe_object%free()
 end subroutine par_fe_space_free_fe_object_iterator

 subroutine par_fe_space_update_hanging_dof_values  (this, fe_function )
  implicit none
  class(par_fe_space_t)   , intent(in) :: this
  class(fe_function_t)    , intent(inout) :: fe_function
  class(triangulation_t)   , pointer     :: triangulation
  type(environment_t)      , pointer     :: environment
  triangulation => this%get_triangulation()
  environment => triangulation%get_environment()
  if ( environment%am_i_l1_task() ) then
    call this%serial_fe_space_t%update_hanging_dof_values(fe_function)
  end if
end subroutine par_fe_space_update_hanging_dof_values 
 
 subroutine par_fe_space_update_ghost_dof_values (this, fe_function )
  implicit none
  class(par_fe_space_t), intent(in)    :: this
  class(fe_function_t) , intent(inout) :: fe_function
  
  class(triangulation_t)   , pointer     :: triangulation
  type(environment_t)      , pointer     :: environment
  class(cell_import_t)     , pointer     :: cell_import
  real(rp)                 , allocatable :: fe_function_nodal_values(:)
  class(fe_cell_iterator_t), allocatable :: fe
  integer(ip)                            :: field_id
  integer(ip)                            :: spos, epos
  
  triangulation => this%get_triangulation()
  environment => triangulation%get_environment()
  
  if ( environment%am_i_l1_task() ) then
    if ( triangulation%get_num_cells() > 0 ) then
      
      call memalloc ( this%ptr_dofs_x_fe(1)%get(triangulation%get_num_cells()+1)-1, & 
                      fe_function_nodal_values,__FILE__, __LINE__ ) 
      call this%create_fe_cell_iterator(fe)
      
      ! Gather local nodal values
      do while ( .not. fe%has_finished() )
        if ( fe%is_local() ) then
          do field_id = 1, this%get_num_fields()
            call get_lst_dofs_spos_epos(spos,epos)
            call fe_function%gather_nodal_values( fe, field_id, &
                                                  fe_function_nodal_values(spos:epos))
          end do
        end if
        call fe%next()
      end do
      
      
      ! Comm local to ghost
      cell_import => triangulation%get_cell_import()
      call environment%l1_neighbours_exchange ( cell_import%get_num_neighbours(),    &
                                                cell_import%get_neighbours_ids(),    &
                                                cell_import%get_rcv_ptrs(),          &
                                                cell_import%get_rcv_leids(),         &
                                                cell_import%get_num_neighbours(),    &
                                                cell_import%get_neighbours_ids(),    &
                                                cell_import%get_snd_ptrs(),          &
                                                cell_import%get_snd_leids(),         &
                                                fe_function_nodal_values,            &
                                                fe_function_nodal_values,            &
                                                this%ptr_dofs_x_fe(1)%get_pointer(), &
                                                this%ptr_dofs_x_fe(1)%get_pointer() )
      
      ! Insert ghost dof values
      call fe%set_gid(triangulation%get_num_local_cells()+1)
      do while ( .not. fe%has_finished() )
        if ( fe%is_ghost() ) then
          do field_id = 1, this%get_num_fields()
            call get_lst_dofs_spos_epos(spos,epos)
            call fe_function%insert_nodal_values( fe, field_id, &
                                                  fe_function_nodal_values(spos:epos))
          end do
        end if
        call fe%next()
      end do
      
      call this%free_fe_cell_iterator(fe)
      call memfree ( fe_function_nodal_values,__FILE__, __LINE__ ) 
      
    end if
  end if
  
  contains
   
   subroutine get_lst_dofs_spos_epos(spos,epos)
     implicit none
     integer(ip), intent(inout) :: spos, epos
     spos = this%ptr_dofs_x_fe(field_id)%get(fe%get_gid())
     if ( field_id == this%get_num_fields() ) then
       epos = this%ptr_dofs_x_fe(1)%get(fe%get_gid()+1)-1
     else
       epos = this%ptr_dofs_x_fe(field_id+1)%get(fe%get_gid())-1
     end if
   end subroutine get_lst_dofs_spos_epos
   
end subroutine par_fe_space_update_ghost_dof_values 
