! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 
subroutine fe_cell_iterator_create ( this, fe_space )
  implicit none
  class(fe_cell_iterator_t)            , intent(inout) :: this
  class(serial_fe_space_t), target, intent(in)    :: fe_space
  integer(ip) :: istat
  call this%free()
  call this%set_fe_space(fe_space)
  call this%create_cell(fe_space%triangulation)
  call this%allocate_assembly_scratch_data()
  call this%allocate_performance_scratch_data()
  call this%init_performance_scratch_data()
  call this%first()
end subroutine fe_cell_iterator_create

subroutine fe_cell_iterator_create_cell ( this, triangulation )
  implicit none
  class(fe_cell_iterator_t)              , intent(inout) :: this
  class(triangulation_t), intent(in)    :: triangulation
  call triangulation%create_cell_iterator(this%cell)
end subroutine fe_cell_iterator_create_cell

subroutine fe_cell_iterator_free_cell ( this, triangulation )
  implicit none
  class(fe_cell_iterator_t)              , intent(inout) :: this
  class(triangulation_t), intent(in)    :: triangulation
  call triangulation%free_cell_iterator(this%cell)
end subroutine fe_cell_iterator_free_cell

subroutine fe_cell_iterator_free (this)
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip) :: istat, iblock, ifield
  if ( associated(this%fe_space) ) then
    if ( associated(this%fe_space%triangulation) ) then
      call this%free_cell(this%fe_space%triangulation)
    end if
  end if
  call this%free_assembly_scratch_data()
  call this%free_performance_scratch_data()
  call this%nullify_fe_space()
end subroutine fe_cell_iterator_free

subroutine fe_cell_iterator_allocate_assembly_scratch_data ( this )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip) :: istat, iblock
  assert( associated(this%fe_space) )
  call memalloc ( this%fe_space%num_fields, this%num_cell_dofs_x_field, __FILE__, __LINE__ )
  allocate( this%fe_dofs(this%fe_space%num_fields), stat=istat); check(istat==0);
  allocate ( this%cell_integrators(this%fe_space%num_fields), stat=istat ); check(istat==0);
  allocate( this%extended_fe_dofs(this%fe_space%num_fields), stat=istat); check(istat==0);
  call this%extended_elmat%create(0,0)
  call this%extended_elvec%create(0) 
  allocate ( this%gid_to_lid_map(this%fe_space%get_num_blocks()), stat=istat); check(istat==0);
  do iblock = 1, this%fe_space%get_num_blocks()
    call this%gid_to_lid_map(iblock)%create(this%fe_space%get_block_num_dofs(iblock))
    this%gid_to_lid_map(iblock)%a = 0
  end do  
end subroutine fe_cell_iterator_allocate_assembly_scratch_data

subroutine fe_cell_iterator_free_assembly_scratch_data ( this )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip) :: istat, iblock, ifield
  if ( allocated(this%num_cell_dofs_x_field) ) then
    call memfree ( this%num_cell_dofs_x_field, __FILE__, __LINE__ )
  end if
  if ( allocated(this%fe_dofs) ) then
    deallocate ( this%fe_dofs, stat=istat ); check(istat==0);
  end if
  if ( allocated(this%cell_integrators) ) then
    deallocate ( this%cell_integrators, stat=istat ); check(istat==0);
  end if
  nullify(this%cell_map)
  if ( allocated(this%gid_to_lid_map) ) then
    do iblock = 1, this%fe_space%get_num_blocks()
       call this%gid_to_lid_map(iblock)%free()
    end do   
    deallocate( this%gid_to_lid_map, stat=istat); check(istat==0);
  end if  
  if ( allocated(this%extended_fe_dofs) ) then
    do ifield = 1, this%get_num_fields()
       call this%extended_fe_dofs(ifield)%free()
    end do
    deallocate( this%extended_fe_dofs, stat=istat); check(istat==0);
  end if
  call this%extended_elmat%free()
  call this%extended_elvec%free()
end subroutine fe_cell_iterator_free_assembly_scratch_data

subroutine fe_cell_iterator_allocate_performance_scratch_data ( this )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip) :: istat
  allocate ( this%reference_fes(this%fe_space%num_fields), stat=istat)
  check(istat == 0)
end subroutine fe_cell_iterator_allocate_performance_scratch_data

subroutine fe_cell_iterator_init_performance_scratch_data ( this ) 
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip) :: istat, i
  ! If (same) set of reference FEs on top of all cells ...
  if ( size(this%fe_space%set_ids_to_reference_fes,2) == 1 ) then 
    do i=1, this%fe_space%num_fields
      this%reference_fes(i)%p => this%fe_space%reference_fes(i)%p
    end do   
  end if 
end subroutine fe_cell_iterator_init_performance_scratch_data 

subroutine fe_cell_iterator_update_performance_scratch_data ( this ) 
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip) :: istat, i
  ! If (potentially) different set of reference FEs on top of all cells ...
  if ( size(this%fe_space%set_ids_to_reference_fes,2) > 1 ) then 
    do i=1, this%fe_space%num_fields
      this%reference_fes(i)%p => this%fe_space%reference_fes(this%fe_space%field_cell_to_ref_fes(i)%get(this%get_gid()))%p
    end do   
  end if
end subroutine fe_cell_iterator_update_performance_scratch_data 

subroutine fe_cell_iterator_free_performance_scratch_data ( this )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip) :: istat
  if ( allocated(this%reference_fes) ) then
    deallocate ( this%reference_fes, stat=istat)
    check(istat == 0)
  end if
end subroutine fe_cell_iterator_free_performance_scratch_data

subroutine fe_cell_iterator_free_final(this)
  implicit none
  type(fe_cell_iterator_t), intent(inout) :: this
  assert ( .not. allocated(this%cell) )
  assert ( .not. associated(this%fe_space))
  assert ( .not. associated(this%cell_map))
end subroutine fe_cell_iterator_free_final

subroutine fe_cell_iterator_next(this)
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  call base_fe_cell_iterator_next(this)
  if ( .not. this%has_finished() ) then
    call this%update_performance_scratch_data()
  end if   
end subroutine fe_cell_iterator_next

subroutine fe_cell_iterator_first(this)
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  call base_fe_cell_iterator_first(this)
  if ( .not. this%has_finished() ) then
    call this%update_performance_scratch_data()
  end if
end subroutine fe_cell_iterator_first

subroutine fe_cell_iterator_set_gid(this, lid)
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip)        , intent(in)    :: lid
  call base_fe_cell_iterator_set_gid(this,lid)
  if ( .not. this%has_finished() ) then
    call this%update_performance_scratch_data()
  end if 	
end subroutine fe_cell_iterator_set_gid

subroutine fe_cell_iterator_set_fe_space(this,fe_space)
  implicit none
  class(fe_cell_iterator_t)             , intent(inout) :: this
  class(serial_fe_space_t), target, intent(in)    :: fe_space
  this%fe_space => fe_space
end subroutine fe_cell_iterator_set_fe_space

subroutine fe_cell_iterator_nullify_fe_space(this)
  implicit none
  class(fe_cell_iterator_t)             , intent(inout) :: this
  nullify(this%fe_space)
end subroutine fe_cell_iterator_nullify_fe_space

function fe_cell_iterator_count_own_dofs_cell ( this, field_id )
  implicit none
  ! Parameters
  class(fe_cell_iterator_t), intent(in)   :: this
  integer(ip)         , intent(in)   :: field_id
  integer(ip) :: fe_cell_iterator_count_own_dofs_cell 
  
  ! Local variables
  integer(ip) :: ivef
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t) :: own_dofs_on_vef_iterator
  
  assert ( field_id>= 1 .and. field_id <= this%fe_space%num_fields )
  
  reference_fe => this%get_reference_fe(field_id)
  ivef = this%get_num_vefs()+1
  own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
  fe_cell_iterator_count_own_dofs_cell = own_dofs_on_vef_iterator%get_size() 
end function fe_cell_iterator_count_own_dofs_cell

subroutine fe_cell_iterator_generate_own_dofs_cell ( this, field_id, current_dof, are_free_dofs )
  implicit none
  ! Parameters
  class(fe_cell_iterator_t), intent(inout)   :: this
  integer(ip)         , intent(in)      :: field_id
  integer(ip)         , intent(inout)   :: current_dof
  logical, optional   , intent(in)      :: are_free_dofs

  ! Local variables
  integer(ip) :: ivef
  integer(ip) :: base_pos_lst_dofs_gids
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t) :: own_dofs_on_vef_iterator
  logical  :: are_free

  if (present(are_free_dofs)) then
    are_free = are_free_dofs
  else
    are_free = .true.
  end if
  
  assert ( field_id>= 1 .and. field_id <= this%fe_space%num_fields )
  ivef = this%get_num_vefs()+1
  
  reference_fe => this%get_reference_fe(field_id)
  
  ! Determine position in lst_dofs_gids of the first dof associated to the
  ! field "field_id" within the current fe
  base_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())-1
  
  ! Iterate over all DoFs associated to field "field_id" on top of the vef
  ! with local identifier ivef within current fe
  own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
  do while (.not. own_dofs_on_vef_iterator%is_upper_bound())
    current_dof = current_dof + 1
    if (are_free) then
      call this%fe_space%lst_dofs_gids%set(base_pos_lst_dofs_gids+own_dofs_on_vef_iterator%get_current(),current_dof)
    else
      call this%fe_space%lst_dofs_gids%set(base_pos_lst_dofs_gids+own_dofs_on_vef_iterator%get_current(),-current_dof)
    end if
    call own_dofs_on_vef_iterator%next()
  end do
end subroutine fe_cell_iterator_generate_own_dofs_cell

subroutine fe_cell_iterator_generate_own_dofs_vef ( this, ivef, field_id, current_dof, free_dofs_loop )
  implicit none
  class(fe_cell_iterator_t) , intent(inout) :: this
  integer(ip)          , intent(in)    :: ivef
  integer(ip)          , intent(in)    :: field_id
  integer(ip)          , intent(inout) :: current_dof
  logical              , intent(in)    :: free_dofs_loop

  integer(ip) :: base_pos_lst_dofs_gids
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t) :: own_dofs_on_vef_iterator
  
  assert ( ivef >=1 .and. ivef <= this%get_num_vefs() )
  assert ( field_id >= 1 .and. field_id <= this%fe_space%num_fields )
  
  ! Determine position in lst_dofs_gids of the first dof associated to the
  ! field "field_id" within the current fe
  base_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())-1
  
  reference_fe => this%get_reference_fe(field_id)
  
  ! Iterate over all DoFs associated to field "field_id" on top of the vef
  ! with local identifier ivef within current fe
  own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
  do while (.not. own_dofs_on_vef_iterator%is_upper_bound())
    if ( this%fe_space%lst_dofs_gids%get(base_pos_lst_dofs_gids+own_dofs_on_vef_iterator%get_current()) >= 0 ) then
      current_dof = current_dof + 1
      if ( free_dofs_loop ) then ! A free dofs loop is surrounding this call 
        call this%fe_space%lst_dofs_gids%set(base_pos_lst_dofs_gids+own_dofs_on_vef_iterator%get_current(),current_dof)
      else                       ! A fixed dofs loop is surrounding this call 
        call this%fe_space%lst_dofs_gids%set(base_pos_lst_dofs_gids+own_dofs_on_vef_iterator%get_current(),-current_dof)
      end if
    end if
    call own_dofs_on_vef_iterator%next()
  end do
end subroutine fe_cell_iterator_generate_own_dofs_vef

function fe_cell_iterator_count_own_dofs_vef ( this, ivef, field_id )
  implicit none
  class(fe_cell_iterator_t) , intent(in) :: this
  integer(ip)          , intent(in) :: ivef
  integer(ip)          , intent(in) :: field_id
  integer(ip) :: fe_cell_iterator_count_own_dofs_vef

  integer(ip) :: base_pos_lst_dofs_gids
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t) :: own_dofs_on_vef_iterator
  
  assert ( ivef >=1 .and. ivef <= this%get_num_vefs() )
  assert ( field_id >= 1 .and. field_id <= this%fe_space%num_fields )
  
  ! Determine position in lst_dofs_gids of the first dof associated to the
  ! field "field_id" within the current fe
  base_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())-1
  
  reference_fe => this%get_reference_fe(field_id)
  
  fe_cell_iterator_count_own_dofs_vef = 0
  own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
  do while (.not. own_dofs_on_vef_iterator%is_upper_bound())
    if ( this%fe_space%lst_dofs_gids%get(base_pos_lst_dofs_gids+own_dofs_on_vef_iterator%get_current()) >= 0 ) then
      fe_cell_iterator_count_own_dofs_vef = fe_cell_iterator_count_own_dofs_vef + 1
    end if
    call own_dofs_on_vef_iterator%next()
  end do
end function fe_cell_iterator_count_own_dofs_vef

subroutine fe_cell_iterator_generate_own_dofs_vef_component_wise ( this, ivef, field_id, current_dof, components_code, free_dofs_loop )
  implicit none
  class(fe_cell_iterator_t) , intent(inout) :: this
  integer(ip)          , intent(in)    :: ivef
  integer(ip)          , intent(in)    :: field_id
  integer(ip)          , intent(inout) :: current_dof
  logical              , intent(in)    :: components_code(:)
  logical              , intent(in)    :: free_dofs_loop
  integer(ip) :: base_pos_lst_dofs_gids, component_id, local_within_ref_fe_dof_id
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t) :: own_dofs_on_vef_iterator
  
  assert ( ivef >=1 .and. ivef <= this%get_num_vefs() )
  assert ( field_id >= 1 .and. field_id <= this%get_num_fields() )
  
  ! Determine position in lst_dofs_gids of the first dof associated to the
  ! field "field_id" within the current fe
  base_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())-1

  reference_fe => this%get_reference_fe(field_id)
  
  assert ( size(components_code) == reference_fe%get_num_field_components() )
  
  ! Iterate over all DoFs associated to field "field_id" on top of the vef
  ! with local identifier ivef within current fe
  own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
  do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
    local_within_ref_fe_dof_id  = own_dofs_on_vef_iterator%get_current()
    if ( this%fe_space%lst_dofs_gids%get(base_pos_lst_dofs_gids+local_within_ref_fe_dof_id) >= 0 ) then
      component_id = reference_fe%get_component_node(local_within_ref_fe_dof_id)
      if ( components_code(component_id) ) then 
       current_dof = current_dof +1 
       if ( free_dofs_loop ) then ! A free dofs loop is surrounding this call 
         call this%fe_space%lst_dofs_gids%set(base_pos_lst_dofs_gids+local_within_ref_fe_dof_id,current_dof)
       else
         call this%fe_space%lst_dofs_gids%set(base_pos_lst_dofs_gids+local_within_ref_fe_dof_id,-current_dof)
       end if
      end if  
    end if
    call own_dofs_on_vef_iterator%next()
  end do
end subroutine fe_cell_iterator_generate_own_dofs_vef_component_wise

subroutine fe_cell_iterator_fetch_own_dofs_vef_from_source_fe ( this, target_ivef, source_fe, source_ivef, field_id )
  implicit none
  class(fe_cell_iterator_t) , intent(inout) :: this
  integer(ip)          , intent(in)    :: target_ivef
  class(fe_cell_iterator_t) , intent(in)    :: source_fe
  integer(ip)          , intent(in)    :: source_ivef
  integer(ip)          , intent(in)    :: field_id

  class(reference_fe_t), pointer :: reference_fe_source 
  integer(ip)                    :: base_pos_lst_dofs_gids_source
  type(list_iterator_t)          :: own_dofs_on_vef_iterator_target
  
  class(reference_fe_t), pointer :: reference_fe_target 
  integer(ip)                    :: base_pos_lst_dofs_gids_target
  
  integer(ip)                    :: source_dof_LID_cell, target_dof_LID_cell
  integer(ip)                    :: target_dof_LID_vef
  integer(ip)                    :: source_dof_LID_vef
  integer(ip)                    :: permutation_index
  integer(ip)                    :: source_ivef_dim

  assert ( target_ivef <= this%get_num_vefs() )
  assert ( source_ivef <= source_fe%get_num_vefs() )
  assert ( field_id <= this%get_num_fields() )
  
  reference_fe_target => this%get_reference_fe(field_id)
  base_pos_lst_dofs_gids_target = this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())-1
  
  reference_fe_source => source_fe%get_reference_fe(field_id)
  base_pos_lst_dofs_gids_source = this%fe_space%ptr_dofs_x_fe(field_id)%get(source_fe%get_gid())-1
  source_ivef_dim = reference_fe_source%get_n_face_dim(source_ivef)
  ! Iterate over all DoFs associated to field "field_id" on top of the vef
  ! with local identifier ivef within target fe
  own_dofs_on_vef_iterator_target = reference_fe_target%create_own_dofs_on_n_face_iterator(target_ivef)
  if ( own_dofs_on_vef_iterator_target%get_size() > 0 ) then
       assert (reference_fe_source%check_compatibility_of_n_faces(reference_fe_target,target_ivef,source_ivef))
       permutation_index = this%get_permutation_index( source_fe, &
                                                       target_ivef, &
                                                       source_ivef )
      do while (.not. own_dofs_on_vef_iterator_target%is_upper_bound())
        target_dof_LID_vef = own_dofs_on_vef_iterator_target%get_distance_to_lower_bound()
        source_dof_LID_vef = reference_fe_source%permute_dof_LID_n_face(target_dof_LID_vef, &
                                                                    source_ivef_dim, & 
                                                                    permutation_index)
        target_dof_LID_cell = own_dofs_on_vef_iterator_target%get_current()
        source_dof_LID_cell = reference_fe_source%translate_dof_lid_n_face_to_dof_lid_cell(source_dof_LID_vef, source_ivef)
        call this%fe_space%lst_dofs_gids%set(base_pos_lst_dofs_gids_target+target_dof_LID_cell, &                                                      
            this%fe_space%lst_dofs_gids%get(base_pos_lst_dofs_gids_source+source_dof_LID_cell) )
        call own_dofs_on_vef_iterator_target%next()
      end do
  end if
end subroutine fe_cell_iterator_fetch_own_dofs_vef_from_source_fe

subroutine fe_cell_iterator_generate_dofs_facet_integration_coupling ( this, ivef, field_id, dof_count )
  implicit none
  ! Parameters
  class(fe_cell_iterator_t), intent(inout)   :: this
  integer(ip)         , intent(in)      :: ivef
  integer(ip)         , intent(in)      :: field_id
  integer(ip)         , intent(inout)   :: dof_count

  ! Local variables
  integer(ip)                    :: idof, base_pos_lst_dofs_gids
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t)          :: facet_integration_coupling_dofs 
  
  reference_fe => this%get_reference_fe(field_id)
  assert ( reference_fe%get_n_face_dim(ivef) == reference_fe%get_num_dims()-1 )
  
  if ( reference_fe%get_continuity() ) then
    facet_integration_coupling_dofs = reference_fe%create_dofs_on_n_face_iterator(ivef)
    base_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())-1
    do while (.not. facet_integration_coupling_dofs%is_upper_bound())
      idof = facet_integration_coupling_dofs%get_current()
      dof_count = dof_count +1 
      call this%fe_space%lst_dofs_gids%set(base_pos_lst_dofs_gids+idof,dof_count)
      call facet_integration_coupling_dofs%next()
    end do
  end if
end subroutine fe_cell_iterator_generate_dofs_facet_integration_coupling

! Renumbers the DoF identifiers corresponding to all fields mapped to block with identifier block_id
subroutine fe_cell_iterator_renum_dofs_block ( this, block_id, perm_old2new )
  implicit none
  ! Parameters
  class(fe_cell_iterator_t)      , intent(inout) :: this
  integer(ip)               , intent(in)    :: block_id
  ! No way to know the size of perm_old2new() within the local scope
  ! of class(fe_cell_iterator_t). This is why I used an assumed-size dummy
  ! argument in this context. This will be solved in the future whenever
  ! class(fe_cell_iterator_t) also has access to the whole mesh-like container.
  integer(ip)               , intent(in)    :: perm_old2new(*)
  integer(ip)                            :: field_id
  assert ( block_id >= 1 .and. block_id <= this%fe_space%get_num_blocks() )
  do field_id=1, this%fe_space%get_num_fields()
    if ( this%fe_space%block_layout%get_block_id(field_id) == block_id ) then
      call this%renum_dofs_field( field_id, perm_old2new )
    end if
  end do 
end subroutine fe_cell_iterator_renum_dofs_block

! Renumbers the DoF identifiers corresponding to field with identifier field_id
subroutine fe_cell_iterator_renum_dofs_field ( this, field_id, perm_old2new )
  implicit none
  ! Parameters
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip)         , intent(in) :: field_id
  ! No way to know the size of perm_old2new() within the local scope
  ! of class(fe_cell_iterator_t). This is why I used an assumed-size dummy
  ! argument in this context. This will be solved in the future whenever
  ! class(fe_cell_iterator_t) also has access to the whole mesh-like container.
  integer(ip)         , intent(in) :: perm_old2new(*)
  integer(ip) :: i, start_pos_lst_dofs_gids, end_pos_lst_dofs_gids
  
  start_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())
  
  if ( field_id == this%fe_space%get_num_fields() ) then
    end_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(1)%get(this%get_gid()+1)-1
  else  
    end_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(field_id+1)%get(this%get_gid())-1
  end if  
  
  assert ( field_id >= 1 .and. field_id <= this%fe_space%get_num_fields() )
  do i = start_pos_lst_dofs_gids, end_pos_lst_dofs_gids
    if ( this%fe_space%lst_dofs_gids%get(i) > 0 ) then
      call this%fe_space%lst_dofs_gids%set(i,perm_old2new(this%fe_space%lst_dofs_gids%get(i)))
    end if
  end do
end subroutine fe_cell_iterator_renum_dofs_field

subroutine fe_cell_iterator_update_assembly_scratch_data( this)
  implicit none
  class(fe_cell_iterator_t), intent(inout)    :: this 
  integer(ip) :: field_id
  do field_id = 1, this%get_num_fields()-1
    this%num_cell_dofs_x_field(field_id) = this%fe_space%ptr_dofs_x_fe(field_id+1)%get(this%get_gid())- &
                                      this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())
  end do
  this%num_cell_dofs_x_field(field_id) = this%fe_space%ptr_dofs_x_fe(1)%get(this%get_gid()+1)- &
                                    this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())
                                    
  call this%get_fe_dofs(this%fe_dofs)
end subroutine fe_cell_iterator_update_assembly_scratch_data



subroutine fe_cell_iterator_update_integration( this )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this 
  integer(ip) :: field_id
  type(point_t)            , pointer :: coordinates(:)
  type(quadrature_t)       , pointer :: quadrature

  call this%update_cell_map()
  coordinates => this%cell_map%get_coordinates()
  call this%get_nodes_coordinates(coordinates)

  quadrature => this%get_quadrature()
  call this%cell_map%update(quadrature)
  call this%update_cell_integrators()
  do field_id = 1, this%get_num_fields()
     call this%cell_integrators(field_id)%p%update(this%cell_map)
  end do
  
end subroutine fe_cell_iterator_update_integration

function fe_cell_iterator_get_fe_space(this)
  implicit none
  class(fe_cell_iterator_t), target, intent(in) :: this
  class(serial_fe_space_t), pointer :: fe_cell_iterator_get_fe_space
  fe_cell_iterator_get_fe_space => this%fe_space
end function fe_cell_iterator_get_fe_space

function fe_cell_iterator_get_num_fields(this)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip) :: fe_cell_iterator_get_num_fields
  fe_cell_iterator_get_num_fields = this%fe_space%num_fields
end function fe_cell_iterator_get_num_fields

function fe_cell_iterator_get_fe_space_type(this, field_id)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip)         , intent(in) :: field_id
  integer(ip)                      :: fe_cell_iterator_get_fe_space_type
  assert (field_id >= 1 .and. field_id <= this%get_num_fields())
  fe_cell_iterator_get_fe_space_type = this%fe_space%fe_space_type_x_field(field_id)
end function fe_cell_iterator_get_fe_space_type

function fe_cell_iterator_get_field_type(this, field_id)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip)         , intent(in) :: field_id
  character(:), pointer :: fe_cell_iterator_get_field_type
  class(reference_fe_t), pointer :: reference_fe
  reference_fe => this%get_reference_fe(field_id)
  fe_cell_iterator_get_field_type => reference_fe%get_field_type()
end function fe_cell_iterator_get_field_type

function fe_cell_iterator_get_field_blocks(this)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip), pointer             :: fe_cell_iterator_get_field_blocks(:)
  fe_cell_iterator_get_field_blocks => this%fe_space%block_layout%get_field_id_to_block_id()
end function fe_cell_iterator_get_field_blocks

function fe_cell_iterator_get_field_coupling(this)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  logical, pointer :: fe_cell_iterator_get_field_coupling(:,:)
  fe_cell_iterator_get_field_coupling => this%fe_space%block_layout%get_field_coupling()
end function fe_cell_iterator_get_field_coupling

function fe_cell_iterator_get_num_dofs(this)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip) :: fe_cell_iterator_get_num_dofs
  fe_cell_iterator_get_num_dofs = this%fe_space%ptr_dofs_x_fe(1)%get(this%get_gid()+1)- &
                                this%fe_space%ptr_dofs_x_fe(1)%get(this%get_gid())
end function fe_cell_iterator_get_num_dofs

function fe_cell_iterator_get_num_dofs_field(this, field_id)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip), intent(in) :: field_id
  integer(ip) :: fe_cell_iterator_get_num_dofs_field
  
  if ( field_id < this%fe_space%num_fields ) then
     fe_cell_iterator_get_num_dofs_field = this%fe_space%ptr_dofs_x_fe(field_id+1)%get(this%get_gid())- &
                                   this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())
  else                                
     fe_cell_iterator_get_num_dofs_field = this%fe_space%ptr_dofs_x_fe(1)%get(this%get_gid()+1)- &
                                   this%fe_space%ptr_dofs_x_fe(this%fe_space%num_fields)%get(this%get_gid())
  end if
end function fe_cell_iterator_get_num_dofs_field


subroutine fe_cell_iterator_get_field_fe_dofs( this, field_id, fe_dofs )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip)         , intent(in)      :: field_id
  integer(ip), pointer, intent(inout)   :: fe_dofs(:)
  integer(ip) :: spos, epos
  ! Always assign an status of the output fe_dofs(:) dummy argument
  ! (i.e., even when there are NO DoFs on the local subdomain)
  nullify(fe_dofs)
  
  ! The code below according to the Fortran2003 handbook returns a zero-sized
  ! pointer array if spos>epos (i.e., when we have a void FE on top of this for
  ! field_id)
  if ( this%fe_space%lst_dofs_gids%size() > 0 ) then
    spos = this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())
    if ( field_id == this%fe_space%get_num_fields() ) then
       epos = this%fe_space%ptr_dofs_x_fe(1)%get(this%get_gid()+1)-1
    else
       epos = this%fe_space%ptr_dofs_x_fe(field_id+1)%get(this%get_gid())-1
    end if
    fe_dofs => this%fe_space%lst_dofs_gids%get_pointer(spos,epos)
  end if
end subroutine fe_cell_iterator_get_field_fe_dofs

subroutine fe_cell_iterator_get_fe_dofs( this, fe_dofs )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  type(i1p_t)         , intent(inout) :: fe_dofs(:)
  integer(ip) :: field_id
  do field_id = 1, this%get_num_fields()
    call this%get_field_fe_dofs(field_id, fe_dofs(field_id)%p)
  end do 
end subroutine fe_cell_iterator_get_fe_dofs

function fe_cell_iterator_get_order( this, field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip)         , intent(in) :: field_id
  integer(ip) :: fe_cell_iterator_get_order
  class(reference_fe_t), pointer :: reference_fe
  reference_fe => this%get_reference_fe(field_id)
  fe_cell_iterator_get_order = reference_fe%get_order()
end function fe_cell_iterator_get_order

function fe_cell_iterator_get_max_order_single_field( this, field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip)         , intent(in) :: field_id
  integer(ip) :: fe_cell_iterator_get_max_order_single_field
  class(reference_fe_t), pointer :: reference_fe
  reference_fe => this%get_reference_fe(field_id)
  fe_cell_iterator_get_max_order_single_field = reference_fe%get_max_order()
end function fe_cell_iterator_get_max_order_single_field

function fe_cell_iterator_get_max_order_all_fields( this )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip) :: fe_cell_iterator_get_max_order_all_fields
  integer(ip) :: field_id
  fe_cell_iterator_get_max_order_all_fields = -1
  do field_id=1, this%get_num_fields()
   if ( fe_cell_iterator_get_max_order_all_fields < this%get_max_order_single_field(field_id) ) then
        fe_cell_iterator_get_max_order_all_fields = this%get_max_order_single_field(field_id)
   end if
  end do
end function fe_cell_iterator_get_max_order_all_fields

function fe_cell_iterator_at_strong_dirichlet_boundary ( this, field_id )
  implicit none
  class(fe_cell_iterator_t)   , intent(in) :: this
  integer(ip)            , intent(in) :: field_id
  logical                             :: fe_cell_iterator_at_strong_dirichlet_boundary
  fe_cell_iterator_at_strong_dirichlet_boundary = this%fe_space%at_strong_dirichlet_boundary_x_fe(field_id)%get(this%get_gid())
end function fe_cell_iterator_at_strong_dirichlet_boundary

function fe_cell_iterator_has_fixed_dofs ( this, field_id )
  implicit none
  class(fe_cell_iterator_t)   , intent(in) :: this
  integer(ip)            , intent(in) :: field_id
  logical                             :: fe_cell_iterator_has_fixed_dofs
  fe_cell_iterator_has_fixed_dofs = this%fe_space%has_fixed_dofs_x_fe(field_id)%get(this%get_gid())
end function fe_cell_iterator_has_fixed_dofs

function fe_cell_iterator_has_hanging_dofs ( this, field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip)              , intent(in) :: field_id
  logical                               :: fe_cell_iterator_has_hanging_dofs
  fe_cell_iterator_has_hanging_dofs = this%fe_space%has_hanging_dofs_x_fe(field_id)%get(this%get_gid())
end function fe_cell_iterator_has_hanging_dofs

subroutine fe_cell_iterator_set_at_strong_dirichlet_boundary_single_field ( this, field_id )
  implicit none
  class(fe_cell_iterator_t)   , intent(inout) :: this
  integer(ip)            , intent(in)    :: field_id
  integer(ip), pointer :: fe_dofs(:)
  call this%get_field_fe_dofs(field_id, fe_dofs)
  if ( associated(fe_dofs) ) then 
    if ( any( (fe_dofs(:) < 0) .and. (fe_dofs(:) >= -this%fe_space%num_dirichlet_dofs) ) ) & 
        call this%fe_space%at_strong_dirichlet_boundary_x_fe(field_id)%set(this%get_gid(),.true.)
  end if       
end subroutine fe_cell_iterator_set_at_strong_dirichlet_boundary_single_field

subroutine fe_cell_iterator_set_has_fixed_dofs ( this, field_id )
  implicit none
  class(fe_cell_iterator_t)   , intent(inout) :: this
  integer(ip)            , intent(in)    :: field_id
  integer(ip), pointer :: fe_dofs(:)
  integer(ip) :: i 
  call this%get_field_fe_dofs(field_id, fe_dofs)
  if ( associated(fe_dofs) ) then
    do i=1, size(fe_dofs)
      if ( this%is_fixed_dof(fe_dofs(i)) ) then
        call this%fe_space%has_fixed_dofs_x_fe(field_id)%set(this%get_gid(),.true.)
        exit
      end if  
    end do  
  end if   
end subroutine fe_cell_iterator_set_has_fixed_dofs

subroutine fe_cell_iterator_set_has_hanging_dofs ( this, field_id )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip)              , intent(in)    :: field_id
  integer(ip), pointer :: fe_dofs(:)
  integer(ip) :: i 
  call this%get_field_fe_dofs(field_id, fe_dofs)
  if ( associated(fe_dofs) ) then
    do i=1, size(fe_dofs)
      if ( this%is_hanging_dof(fe_dofs(i)) ) then
        call this%fe_space%has_hanging_dofs_x_fe(field_id)%set(this%get_gid(),.true.)
        exit
      end if
    end do
  end if 
end subroutine fe_cell_iterator_set_has_hanging_dofs

subroutine fe_cell_iterator_set_at_strong_dirichlet_boundary_all_fields ( this )
  implicit none
  class(fe_cell_iterator_t)   , intent(inout) :: this
  integer(ip) :: field_id
  do field_id=1, this%get_num_fields()
    call this%determine_at_strong_dirichlet_boundary(field_id)
  end do
end subroutine fe_cell_iterator_set_at_strong_dirichlet_boundary_all_fields

function fe_cell_iterator_is_free_dof ( this, dof_lid )
  implicit none
  class(fe_cell_iterator_t)   , intent(in) :: this
  integer(ip)            , intent(in) :: dof_lid
  logical :: fe_cell_iterator_is_free_dof
  fe_cell_iterator_is_free_dof = this%fe_space%is_free_dof(dof_lid)
end function fe_cell_iterator_is_free_dof

function fe_cell_iterator_is_strong_dirichlet_dof ( this, dof_lid )
  implicit none
  class(fe_cell_iterator_t)   , intent(in) :: this
  integer(ip)            , intent(in) :: dof_lid
  logical :: fe_cell_iterator_is_strong_dirichlet_dof
  fe_cell_iterator_is_strong_dirichlet_dof = this%fe_space%is_strong_dirichlet_dof(dof_lid)
end function fe_cell_iterator_is_strong_dirichlet_dof

function fe_cell_iterator_is_fixed_dof ( this, dof_lid )
  implicit none
  class(fe_cell_iterator_t)   , intent(in) :: this
  integer(ip)            , intent(in) :: dof_lid
  logical :: fe_cell_iterator_is_fixed_dof
  fe_cell_iterator_is_fixed_dof = this%fe_space%is_fixed_dof(dof_lid)
end function fe_cell_iterator_is_fixed_dof

function fe_cell_iterator_is_hanging_dof ( this, dof_lid )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip)              , intent(in) :: dof_lid
  logical :: fe_cell_iterator_is_hanging_dof
  fe_cell_iterator_is_hanging_dof = this%fe_space%is_hanging_dof(dof_lid)
end function fe_cell_iterator_is_hanging_dof

function fe_cell_iterator_compute_volume ( this )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  real(rp) :: fe_cell_iterator_compute_volume
  integer(ip)                 :: q_poin, num_quadrature_points
  
  type(quadrature_t), pointer :: quadrature
  
  quadrature => this%get_quadrature()
  
  num_quadrature_points = quadrature%get_num_quadrature_points()
  fe_cell_iterator_compute_volume = 0.0_rp
  do q_poin = 1, num_quadrature_points
     fe_cell_iterator_compute_volume = fe_cell_iterator_compute_volume + &
          &                          this%get_det_jacobian(q_poin) * &
          &                          quadrature%get_weight(q_poin)
  end do
end function fe_cell_iterator_compute_volume

function fe_cell_iterator_get_quadrature_degree ( this )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip) :: fe_cell_iterator_get_quadrature_degree
  if ( this%fe_space%cell_quadratures_degree%size() > 0 ) then
     fe_cell_iterator_get_quadrature_degree = this%fe_space%cell_quadratures_degree%get(this%get_gid())
  end if
  if ( this%fe_space%cell_quadratures_degree%size() == 0 .or. &
       fe_cell_iterator_get_quadrature_degree == fe_space_default_quadrature_degree_flag ) then
     fe_cell_iterator_get_quadrature_degree = this%get_default_quadrature_degree()
  end if
end function fe_cell_iterator_get_quadrature_degree

function fe_cell_iterator_get_default_quadrature_degree ( this )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip) :: fe_cell_iterator_get_default_quadrature_degree
  integer(ip) :: reference_fe_id
  reference_fe_id = this%fe_space%max_order_reference_fe_id_x_cell%get(this%get_gid())
  fe_cell_iterator_get_default_quadrature_degree = & 
    this%fe_space%reference_fes(reference_fe_id)%p%get_default_quadrature_degree()
end function fe_cell_iterator_get_default_quadrature_degree

subroutine fe_cell_iterator_set_quadrature_degree ( this, quadrature_degree )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip)         , intent(in)    :: quadrature_degree
  assert ( quadrature_degree >= -1 )
  if ( this%fe_space%cell_quadratures_degree%size() == 0 ) then
     call this%fe_space%allocate_and_init_cell_quadratures_degree()
  end if
  call this%fe_space%cell_quadratures_degree%set(this%get_gid(),quadrature_degree)
end subroutine fe_cell_iterator_set_quadrature_degree

function fe_cell_iterator_get_quadrature ( this )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  type(quadrature_t), pointer      :: fe_cell_iterator_get_quadrature
  integer(ip) :: cell_quadratures_key, cell_quadratures_position
  integer(ip) :: istat
  
  cell_quadratures_key = this%fe_space%generate_cell_quadratures_position_key(this%get_reference_fe_geo_id(),&
                                                                          this%get_quadrature_degree())
  
  call this%fe_space%cell_quadratures_and_maps_position%get(key=cell_quadratures_key, &
                                                          val=cell_quadratures_position, &
                                                          stat=istat)
  assert ( .not. istat == key_not_found )
  fe_cell_iterator_get_quadrature => this%fe_space%cell_quadratures%get_pointer(cell_quadratures_position)
end function fe_cell_iterator_get_quadrature

function fe_cell_iterator_get_cell_map ( this )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  type(cell_map_t), pointer :: fe_cell_iterator_get_cell_map
  fe_cell_iterator_get_cell_map => this%cell_map
end function fe_cell_iterator_get_cell_map

!==================================================================================================
subroutine fe_cell_iterator_update_cell_map ( this )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip) :: cell_maps_position, cell_maps_key
  integer(ip) :: istat
  
  cell_maps_key = this%fe_space%generate_cell_quadratures_position_key(this%get_reference_fe_geo_id(),&
                                                                   this%get_quadrature_degree())
  
  call this%fe_space%cell_quadratures_and_maps_position%get(key=cell_maps_key, &
                                                          val=cell_maps_position, &
                                                          stat=istat)
  
  assert ( .not. istat == key_not_found )
  this%cell_map => this%fe_space%cell_maps%get_pointer(cell_maps_position)
  
end subroutine fe_cell_iterator_update_cell_map

!==================================================================================================
subroutine fe_cell_iterator_update_cell_integrators ( this )
  implicit none
  class(fe_cell_iterator_t), intent(inout)   :: this
  integer(ip) :: cell_integrators_position_key
  integer(ip) :: cell_integrators_position
  integer(ip) :: istat, field_id
  do field_id = 1, this%get_num_fields()
     cell_integrators_position_key = &
           this%fe_space%generate_cell_integrators_position_key(this%get_reference_fe_geo_id(), &
                                                                  this%get_quadrature_degree(), &
                                                                  this%fe_space%field_cell_to_ref_fes(field_id)%get(this%get_gid()))  
     call this%fe_space%cell_integrators_position%get(key=cell_integrators_position_key, &
                                                           val=cell_integrators_position, &
                                                           stat=istat)
     assert ( .not. istat == key_not_found )
     this%cell_integrators(field_id)%p => this%fe_space%cell_integrators%get_pointer(cell_integrators_position) 
  end do  
end subroutine fe_cell_iterator_update_cell_integrators


!==================================================================================================
subroutine fe_cell_iterator_set_cell_map ( this, cell_map )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  type(cell_map_t), target, intent(in) :: cell_map
  this%cell_map => cell_map
end subroutine fe_cell_iterator_set_cell_map

!==================================================================================================
subroutine fe_cell_iterator_set_cell_integrator ( this, field_id, cell_integrator )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip)              , intent(in) :: field_id
  type(cell_integrator_t), target, intent(in) :: cell_integrator
  this%cell_integrators(field_id)%p => cell_integrator
end subroutine fe_cell_iterator_set_cell_integrator

!==================================================================================================
function fe_cell_iterator_get_quadrature_points_coordinates(this)
  implicit none
  class(fe_cell_iterator_t)   , target, intent(in) :: this
  type(point_t), pointer :: fe_cell_iterator_get_quadrature_points_coordinates(:)
  fe_cell_iterator_get_quadrature_points_coordinates => this%cell_map%get_quadrature_points_coordinates()
end function fe_cell_iterator_get_quadrature_points_coordinates

!==================================================================================================
function fe_cell_iterator_get_det_jacobian ( this, i )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip)    , intent(in) :: i
  real(rp) :: fe_cell_iterator_get_det_jacobian
  fe_cell_iterator_get_det_jacobian = this%cell_map%get_det_jacobian(i)
end function fe_cell_iterator_get_det_jacobian

!==================================================================================================
function fe_cell_iterator_get_cell_integrator ( this, field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in)   :: this
  integer(ip)         , intent(in)   :: field_id
  type(cell_integrator_t), pointer :: fe_cell_iterator_get_cell_integrator
  fe_cell_iterator_get_cell_integrator => this%cell_integrators(field_id)%p
end function fe_cell_iterator_get_cell_integrator

function fe_cell_iterator_get_interpolation_duties ( this, field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in)   :: this
  integer(ip)              , intent(in)   :: field_id
  type(interpolation_duties_t), pointer :: fe_cell_iterator_get_interpolation_duties
  fe_cell_iterator_get_interpolation_duties => & 
    this%cell_integrators(field_id)%p%get_interpolation_duties_real_cell()
end function fe_cell_iterator_get_interpolation_duties

subroutine fe_cell_iterator_get_fe_vef(this, ivef, fe_vef)
  implicit none
  class(fe_cell_iterator_t)   , intent(in)    :: this
  integer(ip)            , intent(in)    :: ivef
  type(fe_vef_iterator_t), intent(inout) :: fe_vef
  call fe_vef%set_gid( this%cell%get_vef_gid(ivef))
end subroutine fe_cell_iterator_get_fe_vef

function fe_cell_iterator_get_reference_fe(this, field_id)
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  integer(ip)              , intent(in)    :: field_id
  class(reference_fe_t), pointer :: fe_cell_iterator_get_reference_fe
  fe_cell_iterator_get_reference_fe => this%reference_fes(field_id)%p
  !fe_cell_iterator_get_reference_fe => this%fe_space%reference_fes(this%fe_space%field_cell_to_ref_fes(field_id)%get(this%get_gid()))%p
end function fe_cell_iterator_get_reference_fe

function fe_cell_iterator_get_max_order_reference_fe(this)
  implicit none
  class(fe_cell_iterator_t),  intent(in)      :: this
  class(reference_fe_t), pointer         :: fe_cell_iterator_get_max_order_reference_fe
  class(reference_fe_t), pointer         :: reference_fe
  integer(ip)                            :: max_order
  integer(ip)                            :: field_id
  max_order = -1
  do field_id=1, this%get_num_fields()
    reference_fe => this%get_reference_fe(field_id)
    if ( reference_fe%get_max_order() > max_order ) then
      max_order = reference_fe%get_max_order()
      fe_cell_iterator_get_max_order_reference_fe => reference_fe
    end if
  end do
end function fe_cell_iterator_get_max_order_reference_fe

function fe_cell_iterator_get_max_order_reference_fe_id(this)
  implicit none
  class(fe_cell_iterator_t),  intent(in)      :: this
  integer(ip)                            :: fe_cell_iterator_get_max_order_reference_fe_id
  class(reference_fe_t), pointer         :: reference_fe
  integer(ip)                            :: max_order
  integer(ip)                            :: field_id
  max_order = -1
  fe_cell_iterator_get_max_order_reference_fe_id = -1
  do field_id=1, this%get_num_fields()
    reference_fe => this%get_reference_fe(field_id)
    if ( reference_fe%get_max_order() >= max_order ) then
      max_order = reference_fe%get_max_order()
      fe_cell_iterator_get_max_order_reference_fe_id = this%get_reference_fe_id(field_id)
    end if
  end do
end function fe_cell_iterator_get_max_order_reference_fe_id

function fe_cell_iterator_get_reference_fe_id(this, field_id)
  implicit none
  class(fe_cell_iterator_t), target   , intent(in)    :: this
  integer(ip)                    , intent(in)    :: field_id
  integer(ip) :: fe_cell_iterator_get_reference_fe_id
  fe_cell_iterator_get_reference_fe_id = this%fe_space%field_cell_to_ref_fes(field_id)%get(this%get_gid())
end function fe_cell_iterator_get_reference_fe_id

subroutine fe_cell_iterator_set_reference_fe_id(this, field_id, reference_fe_id)
  implicit none
  class(fe_cell_iterator_t), target   , intent(inout) :: this
  integer(ip)                    , intent(in)    :: field_id
  integer(ip)                    , intent(in)    :: reference_fe_id
  call this%fe_space%field_cell_to_ref_fes(field_id)%set(this%get_gid(),reference_fe_id)
end subroutine fe_cell_iterator_set_reference_fe_id

function fe_cell_iterator_is_void(this, field_id)
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  integer(ip),          intent(in)    :: field_id
  logical                             :: fe_cell_iterator_is_void
  class(reference_fe_t), pointer :: reference_fe
  reference_fe => this%get_reference_fe(field_id)
  fe_cell_iterator_is_void =  .false.
  select type (reference_fe)
    class is (void_reference_fe_t)
      fe_cell_iterator_is_void =  .true.
  end select
end function fe_cell_iterator_is_void

function fe_cell_iterator_create_own_dofs_on_vef_iterator ( this, ivef, field_id ) result(list_iterator)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip)                , intent(in) :: ivef
  integer(ip)                , intent(in) :: field_id
  type(list_iterator_t)                   :: list_iterator
  class(reference_fe_t), pointer          :: reference_fe
  
  reference_fe => this%get_reference_fe(field_id)
  list_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
end function fe_cell_iterator_create_own_dofs_on_vef_iterator

subroutine fe_cell_iterator_impose_strong_dirichlet_bcs_conforming ( this, fe_function, elmat, elvec )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  type(fe_function_t)      , intent(in)    :: fe_function
  real(rp)                 , intent(in)    :: elmat(:,:)
  real(rp)                 , intent(inout) :: elvec(:)
  
  integer(ip) :: idof, elmat_col, field_id, spos
  
  class(reference_fe_t)      , pointer :: reference_fe
  type(serial_scalar_array_t), pointer :: strong_dirichlet_values
  real(rp)                   , pointer :: strong_dirichlet_values_entries(:)
  
  strong_dirichlet_values         => fe_function%get_fixed_dof_values()
  strong_dirichlet_values_entries => strong_dirichlet_values%get_entries()
  
  elmat_col = 0
  do field_id = 1, this%fe_space%get_num_fields()
    if ( this%at_strong_dirichlet_boundary(field_id) ) then
      reference_fe => this%get_reference_fe(field_id)
      spos = this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())
      do idof = 1, reference_fe%get_num_shape_functions()
        elmat_col = elmat_col + 1
        if ( this%fe_space%lst_dofs_gids%get(spos+idof-1) < 0 ) then
          elvec = elvec - elmat(:,elmat_col)*strong_dirichlet_values_entries(-this%fe_space%lst_dofs_gids%get(spos+idof-1))
        end if
      end do
    end if
  end do
  
end subroutine fe_cell_iterator_impose_strong_dirichlet_bcs_conforming

subroutine fe_cell_iterator_impose_strong_dirichlet_bcs_non_conforming ( this, fe_function )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  type(fe_function_t)      , intent(in)    :: fe_function
  
  type(serial_scalar_array_t), pointer :: strong_dirichlet_values
  real(rp)                   , pointer :: strong_dirichlet_values_entries(:)
  integer(ip) :: ifield, i_lid, i_gid, i_gid_hanging, k_lid, k_gid, pos, spos, epos
  real(rp) :: weight
  integer(ip) :: offset
  
  strong_dirichlet_values         => fe_function%get_fixed_dof_values()
  strong_dirichlet_values_entries => strong_dirichlet_values%get_entries()
  do ifield=1, this%get_num_fields() 
     if (ifield==1) then
       offset = 0
     else
       offset = offset + this%num_cell_dofs_x_field(ifield-1)
     end if
     do i_lid=1, this%num_cell_dofs_x_field(ifield)
        i_gid = this%fe_dofs(ifield)%p(i_lid)
        ! i is a hanging DoF?
        if ( this%is_hanging_dof(i_gid) ) then
           ! Traverse constraining dirichlet DoFs of i
           i_gid_hanging = abs(i_gid) - this%fe_space%num_dirichlet_dofs
           spos = this%fe_space%ptr_constraining_dirichlet_dofs%get(i_gid_hanging)
           epos = this%fe_space%ptr_constraining_dirichlet_dofs%get(i_gid_hanging+1)-1
           do pos=spos, epos 
              k_gid = this%fe_space%constraining_dirichlet_dofs%get(pos)
              weight = this%fe_space%constraining_dirichlet_dofs_coefficients%get(pos)
              ! add the hanging dof column * weighting * dirichlet dof value * -1 to the RHS (for extended elvec)
              this%extended_elvec%a(:) = this%extended_elvec%a(:)-weight*this%extended_elmat%a(:,i_lid+offset)*strong_dirichlet_values_entries(abs(k_gid))
           end do
        ! i is dirichlet dof, proceed as usual
        else if ( this%is_strong_dirichlet_dof(i_gid) ) then
           this%extended_elvec%a(:) = this%extended_elvec%a(:)-this%extended_elmat%a(:,i_lid+offset)*strong_dirichlet_values_entries(abs(i_gid))
        end if
     end do
  end do
  
end subroutine fe_cell_iterator_impose_strong_dirichlet_bcs_non_conforming

subroutine fe_cell_iterator_assembly_array ( this,  &
                                             elvec, &
                                             assembler )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  real(rp)                 , intent(in)    :: elvec(:)
  class(assembler_t)       , intent(inout) :: assembler
  
#ifdef DEBUG  
  logical     :: no_hanging_node_constraints
  integer(ip) :: ifield
  
  no_hanging_node_constraints = .true.
  do ifield=1, this%fe_space%num_fields
    if ( this%has_hanging_dofs(ifield) ) then
      massert(.false.,'fe_cell_iterator_assembly_array not implemented for non-conforming meshes')
    end if
  end do
#endif  
  
  call this%update_assembly_scratch_data()
  call assembler%assembly_array( this%fe_space%num_fields,           &
                                 this%fe_space%get_field_blocks(),   &
                                 this%fe_space%get_field_coupling(), &
                                 this%num_cell_dofs_x_field,         &
                                 this%fe_dofs,                       &
                                 elvec )
  
end subroutine fe_cell_iterator_assembly_array

subroutine fe_cell_iterator_assembly_matrix ( this,  &
                                              elmat, &
                                              assembler )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  real(rp)                 , intent(in)    :: elmat(:,:)
  class(assembler_t)       , intent(inout) :: assembler
  
#ifdef DEBUG  
  logical     :: no_hanging_node_constraints
  integer(ip) :: ifield
  
  no_hanging_node_constraints = .true.
  do ifield=1, this%fe_space%num_fields
    if ( this%has_hanging_dofs(ifield) ) then
      massert(.false.,'fe_cell_iterator_assembly_matrix not implemented for non-conforming meshes')
    end if
  end do
#endif  
  
  call this%update_assembly_scratch_data()
  call assembler%assembly_matrix( this%fe_space%num_fields,                        &
                                               this%fe_space%get_field_blocks(),   &
                                               this%fe_space%get_field_coupling(), &
                                               this%num_cell_dofs_x_field,         &
                                               this%num_cell_dofs_x_field,         &
                                               this%fe_dofs,                       &
                                               this%fe_dofs,                       &
                                               elmat )
  
end subroutine fe_cell_iterator_assembly_matrix

subroutine fe_cell_iterator_assembly_matrix_array ( this,  &
                                                    elmat, &
                                                    elvec, &
                                                    assembler )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  real(rp)                 , intent(in)    :: elmat(:,:)
  real(rp)                 , intent(in)    :: elvec(:)
  class(assembler_t)       , intent(inout) :: assembler
  
  logical     :: no_hanging_node_constraints
  integer(ip) :: ifield
  
  no_hanging_node_constraints = .true.
  do ifield=1, this%fe_space%num_fields
     if ( this%has_hanging_dofs(ifield) ) then
        no_hanging_node_constraints = .false.
        exit
     end if
  end do
  
  call this%update_assembly_scratch_data()
  if ( no_hanging_node_constraints ) then
    call assembler%assembly_matrix( this%fe_space%num_fields,           &
                                    this%fe_space%get_field_blocks(),   &
                                    this%fe_space%get_field_coupling(), &
                                    this%num_cell_dofs_x_field,         &
                                    this%num_cell_dofs_x_field,         &
                                    this%fe_dofs,                       &
                                    this%fe_dofs,                       &
                                    elmat )
    call assembler%assembly_array( this%fe_space%num_fields,            &
                                   this%fe_space%get_field_blocks(),    &
                                   this%fe_space%get_field_coupling(),  &
                                   this%num_cell_dofs_x_field,          &
                                   this%fe_dofs,                        &
                                   elvec )
  else
     call this%apply_constraints ( elmat, elvec )
     call assembler%assembly_matrix( this%fe_space%num_fields,           &
                                     this%fe_space%get_field_blocks(),   &
                                     this%fe_space%get_field_coupling(), &
                                     this%num_cell_dofs_x_field,         &
                                     this%num_cell_dofs_x_field,         &
                                     this%fe_dofs,                       &
                                     this%fe_dofs,                       &
                                     this%extended_elmat%a )
     call assembler%assembly_array( this%fe_space%num_fields,           &
                                    this%fe_space%get_field_blocks(),   &
                                    this%fe_space%get_field_coupling(), &
                                    this%num_cell_dofs_x_field,         &
                                    this%fe_dofs,                       &
                                    this%extended_elvec%a )
  end if
  
end subroutine fe_cell_iterator_assembly_matrix_array

subroutine fe_cell_iterator_assembly_matrix_array_with_strong_bcs ( this,        &
                                                                    fe_function, &
                                                                    elmat,       &
                                                                    elvec,       &
                                                                    assembler )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  type(fe_function_t)      , intent(in)    :: fe_function
  real(rp)                 , intent(in)    :: elmat(:,:)
  real(rp)                 , intent(inout) :: elvec(:)
  class(assembler_t)       , intent(inout) :: assembler
  
  logical :: no_hanging_node_constraints
  integer(ip) :: ifield
  
  no_hanging_node_constraints = .true.
  do ifield=1, this%fe_space%num_fields
     if ( this%has_hanging_dofs(ifield) ) then
        no_hanging_node_constraints = .false.
        exit
     end if
  end do
  
  call this%update_assembly_scratch_data()
  if ( no_hanging_node_constraints ) then
    call this%impose_strong_dirichlet_bcs ( fe_function, elmat, elvec )
    call assembler%assembly_matrix( this%fe_space%num_fields,           &
                                    this%fe_space%get_field_blocks(),   &
                                    this%fe_space%get_field_coupling(), &
                                    this%num_cell_dofs_x_field,         &
                                    this%num_cell_dofs_x_field,         &
                                    this%fe_dofs,                       &
                                    this%fe_dofs,                       &
                                    elmat )
    call assembler%assembly_array( this%fe_space%num_fields,            &
                                   this%fe_space%get_field_blocks(),    &
                                   this%fe_space%get_field_coupling(),  &
                                   this%num_cell_dofs_x_field,          &
                                   this%fe_dofs,                        &
                                   elvec )
  else
     call this%apply_constraints ( elmat, elvec )
     call this%impose_strong_dirichlet_bcs ( fe_function )
     call assembler%assembly_matrix( this%fe_space%num_fields,           &
                                     this%fe_space%get_field_blocks(),   &
                                     this%fe_space%get_field_coupling(), &
                                     this%num_cell_dofs_x_field,         &
                                     this%num_cell_dofs_x_field,         &
                                     this%fe_dofs,                       &
                                     this%fe_dofs,                       &
                                     this%extended_elmat%a )
     call assembler%assembly_array( this%fe_space%num_fields,           &
                                    this%fe_space%get_field_blocks(),   &
                                    this%fe_space%get_field_coupling(), &
                                    this%num_cell_dofs_x_field,         &
                                    this%fe_dofs,                       &
                                    this%extended_elvec%a )
  end if
  
end subroutine fe_cell_iterator_assembly_matrix_array_with_strong_bcs

subroutine fe_cell_iterator_clear_scratch_field_fe_dofs(this,field_id)
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip)              , intent(in)    :: field_id
  this%fe_dofs(field_id)%p = 0
end subroutine fe_cell_iterator_clear_scratch_field_fe_dofs

subroutine fe_cell_iterator_first_local_non_void(this,field_id)
 implicit none
 class(fe_cell_iterator_t), intent(inout) :: this
 integer(ip),          intent(in)    :: field_id
 class(triangulation_t), pointer :: triangulation
 ! Find the first local elem non void in this field
 ! If all local elems are void, then position the iterator at the end ( this%has_finished() == .true. )
 call this%first()
 do while( .not. this%has_finished())
   if (this%is_local()) then
     if ( .not. this%is_void(field_id) ) exit
   end if
   call this%next()
 end do
end subroutine fe_cell_iterator_first_local_non_void

function fe_cell_iterator_get_boundary_quadrature(this) result (quadrature)
  implicit none
  class(fe_cell_iterator_t),  intent(in) :: this
  type(quadrature_t), pointer      :: quadrature
  mcheck(.false.,'This TPB cannot be called from this class')
end function fe_cell_iterator_get_boundary_quadrature

function fe_cell_iterator_get_boundary_piecewise_cell_map(this) result (cell_map)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  type(piecewise_cell_map_t), pointer :: cell_map
  mcheck(.false.,'This TPB cannot be called from this class')
end function fe_cell_iterator_get_boundary_piecewise_cell_map

function fe_cell_iterator_get_boundary_cell_map(this) result (cell_map)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  type(cell_map_t), pointer :: cell_map
  mcheck(.false.,'This TPB cannot be called from this class')
end function fe_cell_iterator_get_boundary_cell_map

function fe_cell_iterator_get_boundary_cell_integrator(this, field_id) result (cell_int)
  implicit none
  class(fe_cell_iterator_t), intent(in)   :: this
  integer(ip)         , intent(in)   :: field_id
  type(cell_integrator_t), pointer :: cell_int
  mcheck(.false.,'This TPB cannot be called from this class')
end function fe_cell_iterator_get_boundary_cell_integrator

subroutine fe_cell_iterator_update_boundary_integration( this )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  mcheck(.false.,'This TPB cannot be called from this class')
end subroutine fe_cell_iterator_update_boundary_integration

subroutine fe_cell_iterator_get_values_scalar (this, values, field_id)
  implicit none
  class(fe_cell_iterator_t)   , intent(in)    :: this
  real(rp), allocatable        , intent(inout) :: values(:,:)
  integer(ip)     , optional   , intent(in)    :: field_id
  integer(ip) :: field_id_
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%get_values(values)
end subroutine fe_cell_iterator_get_values_scalar

subroutine fe_cell_iterator_get_values_vector (this, values, field_id)
  implicit none
  class(fe_cell_iterator_t)       , intent(in)    :: this
  type(vector_field_t), allocatable, intent(inout) :: values(:,:)
  integer(ip)     , optional       , intent(in)    :: field_id
  integer(ip) :: field_id_
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%get_values(values)
end subroutine fe_cell_iterator_get_values_vector

subroutine fe_cell_iterator_get_gradients_scalar (this, gradients, field_id)
  implicit none
  class(fe_cell_iterator_t)              , intent(in)    :: this
  type(vector_field_t),        allocatable, intent(inout) :: gradients(:,:)
  integer(ip)     , optional              , intent(in)    :: field_id
  integer(ip) :: field_id_
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%get_gradients(gradients)
end subroutine fe_cell_iterator_get_gradients_scalar

subroutine fe_cell_iterator_get_gradients_vector (this, gradients, field_id)
  implicit none
  class(fe_cell_iterator_t)           , intent(in)     :: this
  type(tensor_field_t),     allocatable, intent(inout)  :: gradients(:,:)
  integer(ip)     , optional           , intent(in)     :: field_id
  integer(ip) :: field_id_
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%get_gradients(gradients)
end subroutine fe_cell_iterator_get_gradients_vector

subroutine fe_cell_iterator_get_divergences_vector (this, divergences, field_id)
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  real(rp), allocatable     , intent(inout) :: divergences(:,:)
  integer(ip)  , optional   , intent(in)    :: field_id
  integer(ip) :: field_id_
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%get_divergences(divergences)
end subroutine fe_cell_iterator_get_divergences_vector

subroutine fe_cell_iterator_get_curls_vector (this, curls, field_id)
  implicit none
  class(fe_cell_iterator_t)       , intent(in)    :: this
  type(vector_field_t), allocatable, intent(inout) :: curls(:,:)
  integer(ip)     , optional       , intent(in)    :: field_id
  integer(ip) :: field_id_
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%get_curls(curls)
end subroutine fe_cell_iterator_get_curls_vector

subroutine fe_cell_iterator_get_laplacians_scalar (this, laplacians, field_id)
  implicit none
  class(fe_cell_iterator_t)   , intent(in)    :: this
  real(rp), allocatable        , intent(inout) :: laplacians(:,:)
  integer(ip)     , optional   , intent(in)    :: field_id
  integer(ip) :: field_id_
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%get_laplacians(laplacians)
end subroutine fe_cell_iterator_get_laplacians_scalar

subroutine fe_cell_iterator_get_laplacians_vector (this, laplacians, field_id)
  implicit none
  class(fe_cell_iterator_t)       , intent(in)    :: this
  type(vector_field_t), allocatable, intent(inout) :: laplacians(:,:)
  integer(ip)     , optional       , intent(in)    :: field_id
  integer(ip) :: field_id_
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%get_laplacians(laplacians)
end subroutine fe_cell_iterator_get_laplacians_vector

!=================================================================================================
subroutine fe_cell_iterator_evaluate_fe_function_scalar ( this,                     &
                                                         nodal_values,             &
                                                         quadrature_points_values, &
                                                         field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  real(rp)                , intent(in)    :: nodal_values(:)
  real(rp), allocatable   , intent(inout) :: quadrature_points_values(:)
  integer(ip), optional   , intent(in)    :: field_id
  integer(ip)                             :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%evaluate_fe_function(nodal_values,quadrature_points_values)
end subroutine fe_cell_iterator_evaluate_fe_function_scalar
!=================================================================================================
subroutine fe_cell_iterator_evaluate_fe_function_vector ( this,                     &
                                                         nodal_values,             &
                                                         quadrature_points_values, &
                                                         field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  real(rp)                , intent(in)    :: nodal_values(:)
  type(vector_field_t)    , allocatable   , intent(inout) :: quadrature_points_values(:)
  integer(ip), optional   , intent(in)    :: field_id
  integer(ip)                             :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%evaluate_fe_function(nodal_values,quadrature_points_values)
end subroutine fe_cell_iterator_evaluate_fe_function_vector
!=================================================================================================
subroutine fe_cell_iterator_evaluate_fe_function_tensor ( this,                     &
                                                         nodal_values,             &
                                                         quadrature_points_values, &
                                                         field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  real(rp)                , intent(in)    :: nodal_values(:)
  type(tensor_field_t)    , allocatable   , intent(inout) :: quadrature_points_values(:)
  integer(ip), optional   , intent(in)    :: field_id
  integer(ip)                             :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%evaluate_fe_function(nodal_values,quadrature_points_values)
end subroutine fe_cell_iterator_evaluate_fe_function_tensor
!=================================================================================================
subroutine fe_cell_iterator_evaluate_gradient_fe_function_scalar ( this,                     &
                                                         nodal_values,             &
                                                         quadrature_points_values, &
                                                         field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  real(rp)                , intent(in)    :: nodal_values(:)
  type(vector_field_t)    , allocatable   , intent(inout) :: quadrature_points_values(:)
  integer(ip), optional   , intent(in)    :: field_id
  integer(ip)                             :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%evaluate_gradient_fe_function(nodal_values,quadrature_points_values)
end subroutine fe_cell_iterator_evaluate_gradient_fe_function_scalar
!=================================================================================================
subroutine fe_cell_iterator_evaluate_gradient_fe_function_vector ( this,                     &
                                                         nodal_values,             &
                                                         quadrature_points_values, &
                                                         field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  real(rp)                , intent(in)    :: nodal_values(:)
  type(tensor_field_t)    , allocatable   , intent(inout) :: quadrature_points_values(:)
  integer(ip), optional   , intent(in)    :: field_id
  integer(ip)                             :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%evaluate_gradient_fe_function(nodal_values,quadrature_points_values)
end subroutine fe_cell_iterator_evaluate_gradient_fe_function_vector
!=================================================================================================
subroutine fe_cell_iterator_evaluate_laplacian_fe_function_scalar ( this,                     &
                                                                    nodal_values,             &
                                                                    quadrature_points_values, &
                                                                    field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  real(rp)                , intent(in)    :: nodal_values(:)
  real(rp), allocatable   , intent(inout) :: quadrature_points_values(:)
  integer(ip), optional   , intent(in)    :: field_id
  integer(ip)                             :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%evaluate_laplacian_fe_function(nodal_values,quadrature_points_values)
end subroutine fe_cell_iterator_evaluate_laplacian_fe_function_scalar
!=================================================================================================
subroutine fe_cell_iterator_evaluate_laplacian_fe_function_vector ( this,                     &
                                                                    nodal_values,             &
                                                                    quadrature_points_values, &
                                                                    field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  real(rp)                , intent(in)    :: nodal_values(:)
  type(vector_field_t)    , allocatable   , intent(inout) :: quadrature_points_values(:)
  integer(ip), optional   , intent(in)    :: field_id
  integer(ip)                             :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%evaluate_laplacian_fe_function(nodal_values,quadrature_points_values)
end subroutine fe_cell_iterator_evaluate_laplacian_fe_function_vector

subroutine fe_cell_iterator_apply_constraints(this,elmat,elvec)
  implicit none
  class(fe_cell_iterator_t), intent(inout)    :: this
  real(rp), intent(in) :: elmat(:,:)
  real(rp), intent(in) :: elvec(:)

  integer(ip) :: ifield, jfield, i_lid, j_lid, i_gid, i_gid_hanging, j_gid, total_num_dofs
  integer(ip) :: current_i, current_extended_i, current_j, current_extended_j
  integer(ip) :: k_lid, k_gid, pos, spos, epos, iblock
  real(rp) :: weight
  integer(ip), pointer :: field_blocks(:)
  integer(ip) :: offset
  
  field_blocks            => this%get_field_blocks()
  
     ! Count number of free dofs involved in the assembly of this cell
     ! i.e., the free dofs of the cell + all other free dofs that constrain
     ! hanging dofs of the cell
     do ifield=1, this%get_num_fields() 
        iblock = field_blocks(ifield)
        ! Only if hanging nodes perform the following work
        if ( this%has_hanging_dofs(ifield) ) then
           ! Initialize extended_fe_dofs
           call this%extended_fe_dofs(ifield)%resize(0)
           ! First, insert all free nodes
           do i_lid=1, this%get_num_dofs_field(ifield)
              i_gid = this%fe_dofs(ifield)%p(i_lid)
              if ( this%is_free_dof(i_gid) ) then
                 ! Global to local map for free dofs (dofs already belonging to the cell)
                 this%gid_to_lid_map(iblock)%a(i_gid) = i_lid
              end if
              ! Insert all dofs belonging to the cell
              call this%extended_fe_dofs(ifield)%push_back(i_gid)
           end do
           do i_lid=1, this%get_num_dofs_field(ifield)
              i_gid = this%fe_dofs(ifield)%p(i_lid)
              if ( this%is_hanging_dof(i_gid) ) then
                 ! Only for hanging dofs, find outer constraining dofs
                 i_gid_hanging = abs(i_gid) - this%fe_space%num_dirichlet_dofs
                 do j_lid= this%fe_space%ptr_constraining_free_dofs%get(i_gid_hanging), &
                    this%fe_space%ptr_constraining_free_dofs%get(i_gid_hanging+1)-1
                    j_gid = this%fe_space%constraining_free_dofs%get(j_lid)
                    ! If not touched constraining free dof, compute gid to lid map, and insert this dof
                    ! in extended_fe_dofs
                    if ( this%gid_to_lid_map(iblock)%a(j_gid) == 0 ) then
                       this%num_cell_dofs_x_field(ifield) = this%num_cell_dofs_x_field(ifield)+1
                       this%gid_to_lid_map(iblock)%a(j_gid) = this%num_cell_dofs_x_field(ifield)
                       call this%extended_fe_dofs(ifield)%push_back(j_gid) 
                    end if
                 end do
              end if
           end do
           ! Update the fe_dofs array with the extended ones
           this%fe_dofs(ifield)%p => this%extended_fe_dofs(ifield)%get_pointer()
        end if
        
     end do
     
     ! Compute all extended dofs, and resize elmat and elvec accordingly
     total_num_dofs = sum(this%num_cell_dofs_x_field)
     call this%extended_elmat%resize(total_num_dofs, total_num_dofs)
     call this%extended_elvec%resize(total_num_dofs)
     
     this%extended_elmat%a(1:total_num_dofs,1:total_num_dofs) = 0.0_rp
     this%extended_elvec%a(1:total_num_dofs) = 0.0_rp
     
     current_i          = 1 
     current_extended_i = 1     
     do ifield=1, this%get_num_fields()   
     current_j          = 1 
     current_extended_j = 1   
     do jfield=1, this%get_num_fields() 
        ! For every field, insert the cell dofs entries
        this%extended_elmat%a(current_extended_i:current_extended_i+this%get_num_dofs_field(ifield)-1, &
             & current_extended_j:current_extended_j+this%get_num_dofs_field(jfield)-1) = &
             & elmat(current_i:current_i+this%get_num_dofs_field(ifield)-1, &
             & current_j:current_j+this%get_num_dofs_field(jfield)-1)
           current_j = current_j + this%get_num_dofs_field(jfield)
           current_extended_j = current_extended_j + this%num_cell_dofs_x_field(jfield)  
    end do
    this%extended_elvec%a(current_extended_i:current_extended_i+this%get_num_dofs_field(ifield)-1) &
         & = elvec(current_i:current_i+this%get_num_dofs_field(ifield)-1)
    current_i = current_i + this%get_num_dofs_field(ifield)
    current_extended_i = current_extended_i + this%num_cell_dofs_x_field(ifield)       
    end do

     ! Now, we want to compute the matrix entries for the constraining free dofs, both the own constraining free dofs
     ! and the outer ones
     do ifield=1, this%get_num_fields() 
        iblock = field_blocks(ifield)
        if (ifield==1) then
          offset = 0
        else
          offset = offset + this%num_cell_dofs_x_field(ifield-1)
        end if
        do i_lid=1, this%get_num_dofs_field(ifield)
           i_gid = this%fe_dofs(ifield)%p(i_lid)
           ! i is a hanging DoF?
           if ( this%is_hanging_dof(i_gid) ) then
              ! Traverse constraining free DoFs of i
              i_gid_hanging = abs(i_gid) - this%fe_space%num_dirichlet_dofs
              spos = this%fe_space%ptr_constraining_free_dofs%get(i_gid_hanging)
              epos = this%fe_space%ptr_constraining_free_dofs%get(i_gid_hanging+1)-1
              do pos=spos, epos 
                 k_gid = this%fe_space%constraining_free_dofs%get(pos)
                 weight = this%fe_space%constraining_free_dofs_coefficients%get(pos)
                 k_lid = this%gid_to_lid_map(iblock)%a(k_gid)
                 ! free dofs, add the hanging dof row * weighting in the free dof row (for extended elmat and elvec)
                 this%extended_elmat%a(k_lid+offset,:) = this%extended_elmat%a(k_lid+offset,:) + weight*this%extended_elmat%a(i_lid+offset,:)
                 this%extended_elvec%a(k_lid+offset)   = this%extended_elvec%a(k_lid+offset)   + weight*this%extended_elvec%a(i_lid+offset)
              end do
           end if
        end do
     end do

     ! Idem for columns
     do ifield=1, this%get_num_fields() 
        iblock = field_blocks(ifield)
        if (ifield==1) then
          offset = 0
        else
          offset = offset + this%num_cell_dofs_x_field(ifield-1)
        end if
        do i_lid=1, this%get_num_dofs_field(ifield)
           i_gid = this%fe_dofs(ifield)%p(i_lid)
           ! i is a hanging DoF?
           if ( this%is_hanging_dof(i_gid) ) then
              ! Traverse constraining free DoFs of i
              i_gid_hanging = abs(i_gid) - this%fe_space%num_dirichlet_dofs
              spos = this%fe_space%ptr_constraining_free_dofs%get(i_gid_hanging)
              epos = this%fe_space%ptr_constraining_free_dofs%get(i_gid_hanging+1)-1
              do pos=spos, epos 
                 k_gid = this%fe_space%constraining_free_dofs%get(pos)
                 weight = this%fe_space%constraining_free_dofs_coefficients%get(pos)
                 k_lid = this%gid_to_lid_map(iblock)%a(k_gid)
                 ! free dofs, add the hanging dof column * weighting in the free dof column (for extended elmat and elvec)
                 this%extended_elmat%a(:,k_lid+offset) = this%extended_elmat%a(:,k_lid+offset) + weight*this%extended_elmat%a(:,i_lid+offset)
              end do
           end if
        end do
     end do
     
     ! Initialize gid_to_lid_map to zero
     do ifield=1, this%get_num_fields() 
       iblock = field_blocks(ifield)
       ! Only if hanging nodes perform the following work
       if ( this%has_hanging_dofs(ifield) ) then
         do i_lid=1, this%get_num_dofs_field(ifield)
           i_gid = this%fe_dofs(ifield)%p(i_lid)
           if ( this%is_hanging_dof(i_gid) ) then
                 ! Only for hanging dofs, find outer constraining dofs
                 i_gid_hanging = abs(i_gid) - this%fe_space%num_dirichlet_dofs
                 do j_lid= this%fe_space%ptr_constraining_free_dofs%get(i_gid_hanging), &
                    this%fe_space%ptr_constraining_free_dofs%get(i_gid_hanging+1)-1
                    j_gid = this%fe_space%constraining_free_dofs%get(j_lid)
                    ! If not touched constraining free dof, compute gid to lid map, and insert this dof
                    ! in extended_fe_dofs
                    this%gid_to_lid_map(iblock)%a(j_gid) = 0
                 end do 
           else if ( this%is_free_dof(i_gid) ) then
             ! Global to local map for free dofs (dofs already belonging to the cell)
             this%gid_to_lid_map(iblock)%a(i_gid) = 0
           end if
         end do
       end if
     end do
     
   end subroutine fe_cell_iterator_apply_constraints



