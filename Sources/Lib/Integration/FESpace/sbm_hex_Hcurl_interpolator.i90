! Copyright (C) 2014 Santiago Badia, Alberto F. Martín and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  
! ================================================================================
subroutine hex_Hcurl_interpolator_create( this, fe_space, field_id  )
  implicit none
  class(hex_Hcurl_interpolator_t)      , intent(inout) :: this 
		class(serial_fe_space_t)             , intent(in)    :: fe_space
  integer(ip)                          , intent(in)    :: field_id
		
		class(fe_cell_iterator_t), allocatable :: fe
  class(reference_fe_t)  ,   pointer     :: reference_fe
		 
  integer(ip)                         :: reduced_order_vector(SPACE_DIM)
  integer(ip)                         :: num_interior_moments
  integer(ip)                         :: idime, istat 

	 this%field_id = field_id

  call fe_space%create_fe_cell_iterator(fe)
  reference_fe => fe%get_reference_fe(field_id)
		
  ! Create a 1D scalar lagrangian reference FE of order k-1
  call this%fe_1D%create(topology          = reference_fe%get_topology(), &
                         num_dims          = 1,                           &
                         order             = reference_fe%get_order()-1,  &
                         field_type        = field_type_scalar,           &
                         conformity        = .true. )

		select type ( reference_fe ) 
		class is ( hex_nedelec_reference_fe_t ) 
  call reference_fe%create_edge_quadrature( this%edge_quadrature )
		class DEFAULT 
		check(.false.) 
		end select 
		
  call this%edge_map%create( this%edge_quadrature, fe%get_reference_fe_geo() )
  call this%fe_1D%create_interpolation( this%edge_quadrature, this%edge_interpolation )
  allocate (this%edge_function_values(this%edge_quadrature%get_num_quadrature_points(),1), stat=istat); check(istat==0)
		call memalloc ( this%edge_quadrature%get_num_quadrature_points(), 1, this%scalar_function_values_on_edge, __FILE__, __LINE__)

  if ( reference_fe%get_num_dims() == 3 .and. reference_fe%get_order() > 1 ) then 
  ! Create a 2D Nedelec reference FE of order k-1
    call this%fe_2D%create(topology   = reference_fe%get_topology(),     &
                           num_dims   = 2,                               &
                           order      = reference_fe%get_order()-1,      &
                           field_type = field_type_vector,               &
                           conformity = .false. )

   call reference_fe%create_facet_quadrature( this%facet_quadrature )
   call this%fe_2D%create_interpolation( this%facet_quadrature, this%facet_interpolation )
   call this%facet_map%create( this%facet_quadrature, fe%get_reference_fe_geo() )
   allocate (this%facet_function_values(this%facet_quadrature%get_num_quadrature_points(),1), stat=istat); check(istat==0)
   call memalloc ( this%facet_quadrature%get_num_quadrature_points(), 1, this%scalar_function_values_on_facet, __FILE__, __LINE__)

  end if 

  ! Q_{k-1,k-2,k-2} x Q_{k-2,k-1,k-2} x Q_{k-2,k-2,k-1}
  reduced_order_vector(1)   = reference_fe%get_order()-1 
  reduced_order_vector(2:3) = reference_fe%get_order()-2

  ! compute number shape functions for reduced order element
  num_interior_moments = 1
  do idime = 1, reference_fe%get_num_dims() 
     num_interior_moments = num_interior_moments*(reduced_order_vector(idime)+1)
  end do
  num_interior_moments = num_interior_moments*reference_fe%get_num_dims() 
		
		call reference_fe%create_quadrature( this%cell_quadrature )
		call this%cell_map%create( this%cell_quadrature, fe%get_reference_fe_geo() )
		
  if ( num_interior_moments > 0 ) then 

      ! Create a Raviart-Thomas reference FE of order k-2
     call this%fe%create(topology          = reference_fe%get_topology(),   &
                         num_dims          = reference_fe%get_num_dims(),   &
                         order             = reference_fe%get_order()-2,    &
                         field_type        = field_type_vector,             &
                         conformity        = .false. )

   

    ! create reduced order interpolation
     call this%cell_interpolation%create( reference_fe%get_num_dims(),                &
                                          num_interior_moments,                       &
                                          this%cell_quadrature%num_quadrature_points, &
                                          num_entries_symmetric_tensor=0,             &
                                          compute_hessian = .false. )
					
					! create reduced order interpolation
     call this%real_cell_interpolation%clone( this%cell_interpolation )

			select type ( reference_fe ) 
		 class is ( hex_nedelec_reference_fe_t )
   call reference_fe%fill_interpolation_pre_basis( this%cell_quadrature,               & 
                                                   this%cell_interpolation,  & 
                                                   reduced_order_vector)
			class DEFAULT 
			check(.false.) 
			end select 

   allocate (this%cell_function_values(this%cell_quadrature%get_num_quadrature_points(),1), stat=istat); check(istat==0)

  end if 

		call fe_space%free_fe_cell_iterator( fe ) 
end subroutine hex_Hcurl_interpolator_create

! ================================================================================
subroutine hex_Hcurl_interpolator_evaluate_vector_function_moments( this, fe, vector_function, dof_values, n_face_mask, time ) 
  implicit none
  class(hex_Hcurl_interpolator_t) , intent(inout) :: this
  class(fe_cell_iterator_t)       , intent(in)    :: fe
  class(vector_function_t)        , intent(in)    :: vector_function
  real(rp) , allocatable          , intent(inout) :: dof_values(:) 
  logical  , optional             , intent(in)    :: n_face_mask(:)
  real(rp) , optional             , intent(in)    :: time 

  ! Edge moments evaluation 
  type(vector_field_t)                :: tangent 
  type(list_iterator_t)               :: vertex_iterator 
  type(point_t), pointer              :: edge_map_coordinates(:)
  integer(ip)                         :: edge_id  
  integer(ip)                         :: vertex_within_edge_id 

  ! Faces moments integration  
		
  type(point_t), pointer              :: facet_map_coordinates(:)
  type(vector_field_t)                :: normal
  type(vector_field_t)                :: cross_product_function_normal
  type(vector_field_t)                :: cross_product_function_normal_proj
  type(vector_field_t)                :: col_jacobian
		type(vector_field_t)                :: normalized_col_jacobian
  integer(ip)                         :: facet_id, facet_lid
  integer(ip)                         :: vertex_within_facet_id

  ! Local variables required by interior moments integration
  type(vector_field_t)                :: v_shape_test, mapped_shape_test

  ! Common integration 
		class(reference_fe_t), pointer      :: reference_fe 
		class(reference_fe_t), pointer      :: reference_fe_geo 
		type(point_t)        , pointer      :: cell_coordinates(:) 
  integer(ip)                         :: vertex_within_cell_id
  real(rp)                            :: shape_test, factor 
  integer(ip)                         :: idime, jdime, ishape
  integer(ip)                         :: qpoint, num_quad_points 
  type(vector_field_t), allocatable   :: function_values(:) 
  type(point_t), pointer              :: quad_points_coordinates(:)
		
		real(rp) :: jacobian_restricted_to_face(2,2) 
		real(rp) :: inv_jacobian_restricted_to_face(2,2)

		real(rp)    :: time_(1) 
  integer(ip) :: d, istat 

		dof_values = 0.0_rp 
  if ( present(time) ) time_(1) = time 
		reference_fe     => fe%get_reference_fe(this%field_id)
		reference_fe_geo => fe%get_reference_fe_geo()
		
		! Extract cell coordinates 
		cell_coordinates => this%cell_map%get_coordinates() 
		call fe%get_nodes_coordinates( cell_coordinates ) 

  d = 0
  do edge_id = reference_fe%get_first_n_face_id_of_dim(1), & 
               reference_fe%get_first_n_face_id_of_dim(1) + reference_fe%get_num_n_faces_of_dim(1)-1

     edge_map_coordinates => this%edge_map%get_coordinates()   

     vertex_within_edge_id = 1
     vertex_iterator = reference_fe%create_vertices_n_face_iterator(edge_id)
     do while ( .not. vertex_iterator%is_upper_bound () )
        vertex_within_cell_id = vertex_iterator%get_current()
        call edge_map_coordinates(vertex_within_edge_id)%init( cell_coordinates(vertex_within_cell_id)%get_value() )
        call vertex_iterator%next()
        vertex_within_edge_id = vertex_within_edge_id + 1
     end do

     ! Update edge_map on current edge
     call this%edge_map%update(local_edge_id = edge_id - reference_fe%get_first_n_face_id_of_dim(1)+1, &
                               reference_fe  = reference_fe,                                           &
                               quadrature    = this%edge_quadrature )

     ! Extract quadrature points coordinates 
					num_quad_points         = this%edge_quadrature%get_num_quadrature_points()
     quad_points_coordinates => this%edge_map%get_quadrature_points_coordinates()

     ! Fill vector function values restricted to edge 
					if ( present(time) ) then 
					call vector_function%get_values_set(quad_points_coordinates, time_, this%edge_function_values(1:num_quad_points,1:1))
					else
     call vector_function%get_values_set(quad_points_coordinates, this%edge_function_values(1:num_quad_points,1))
     end if 
					
     ! Integrate edge boundary moments int_edge(f.tau q), q \in P_k-1
     do qpoint = 1, num_quad_points 
        factor = this%edge_map%get_det_jacobian(qpoint) * this%edge_quadrature%get_weight(qpoint)
        call this%edge_map%get_tangent(qpoint, tangent)
        do ishape=1, this%fe_1D%get_num_shape_functions()
           call this%fe_1D%get_value(this%edge_interpolation, ishape, qpoint, shape_test)
           dof_values(d+ishape) = dof_values(d+ishape) +  this%edge_function_values(qpoint,1) * shape_test * tangent * factor 
        end do
     end do

     d = d + this%fe_1D%get_num_shape_functions() 
  end do

  if ( reference_fe%get_num_dims() == 3 .and. reference_fe%get_order() > 1 ) then

     do facet_id = reference_fe%get_first_facet_id(), & 
                   reference_fe%get_first_facet_id() + reference_fe%get_num_facets()-1

        ! Get face map coordinates
        facet_map_coordinates => this%facet_map%get_coordinates()

        ! Extract coordinates of the vertices within the face
        vertex_within_facet_id = 1
        vertex_iterator = reference_fe%create_vertices_n_face_iterator(facet_id)
        do while ( .not. vertex_iterator%is_upper_bound () )
           vertex_within_cell_id = vertex_iterator%get_current()
           call facet_map_coordinates(vertex_within_facet_id)%init( cell_coordinates(vertex_within_cell_id)%get_value() )
           call vertex_iterator%next()
           vertex_within_facet_id = vertex_within_facet_id + 1
        end do

        ! Update facet_map on current face 
        facet_lid = facet_id - reference_fe_geo%get_first_facet_id()+1
        call this%facet_map%update(reorientation_factor   = reference_fe_geo%get_normal_orientation_factor(facet_lid), &
                                   quadrature             = this%facet_quadrature ) 
								
        ! Extract quadrature points coordinates 
								num_quad_points = this%facet_quadrature%get_num_quadrature_points()
        quad_points_coordinates => this%facet_map%get_quadrature_points_coordinates()

        ! Fill vector function values restricted to facet
								if ( present(time) ) then 
								call vector_function%get_values_set(quad_points_coordinates, time_, this%facet_function_values(1:num_quad_points,1:1) )
								else 
        call vector_function%get_values_set(quad_points_coordinates, this%facet_function_values(1:num_quad_points,1) )
								end if 
        call cross_product_function_normal_proj%init(0.0_rp)

        ! Integrate face boundary moments int_Face(u x n q), q \in Q_k-2,k-1 x Q_k-1,k-2
        do qpoint = 1, num_quad_points
           factor = this%facet_map%get_det_jacobian(qpoint) * this%facet_quadrature%get_weight(qpoint)
           call this%facet_map%get_normal(qpoint, normal)   
           normal = reference_fe%get_normal_orientation_factor( facet_lid ) * normal

           ! Compute g x n
           cross_product_function_normal = cross_product(this%facet_function_values(qpoint,1),normal)
           do idime=1, reference_fe%get_num_dims()-1 
              call this%facet_map%get_jacobian_column(idime,qpoint,col_jacobian)
              col_jacobian = col_jacobian * (1.0_rp/col_jacobian%nrm2()) 
              call cross_product_function_normal_proj%set(idime, col_jacobian*cross_product_function_normal)
           end do

											! WARNING: Compute Jacobian restricted to face, taking adventadge of the structured meshing! (only diagonal filling) 
											do idime=1,2
											 call this%facet_map%get_jacobian_column(idime,qpoint,col_jacobian)
												  call this%facet_map%get_jacobian_column(idime,qpoint,normalized_col_jacobian)
														normalized_col_jacobian = (1.0_rp/normalized_col_jacobian%nrm2()) * normalized_col_jacobian 
												  jacobian_restricted_to_face(idime,idime) = col_jacobian*normalized_col_jacobian
              inv_jacobian_restricted_to_face(idime,idime) = 1.0_rp/jacobian_restricted_to_face(idime,idime)
											end do 
											
           do ishape=1, this%fe_2D%get_num_shape_functions()
              call this%fe_2D%get_value(this%facet_interpolation, ishape, qpoint, v_shape_test)   

                 ! Apply Nedelec mapping to test function  
                 call mapped_shape_test%set(1, inv_jacobian_restricted_to_face(1,1)*v_shape_test%get(1) )
																	call mapped_shape_test%set(2, inv_jacobian_restricted_to_face(2,2)*v_shape_test%get(2) )

              dof_values(d+ishape) = dof_values(d+ishape) + cross_product_function_normal_proj * mapped_shape_test * factor
           end do
        end do
        d = d + this%fe_2D%get_num_shape_functions()
     end do

  end if 

  if ( reference_fe%get_order() > 1 ) then 
     ! Update cell map 
     call this%cell_map%update(this%cell_quadrature)

     ! Extract quadrature points coordinates 
					num_quad_points  = this%cell_quadrature%num_quadrature_points
     quad_points_coordinates => this%cell_map%get_quadrature_points_coordinates()

     ! Fill vector function values restricted to edge 
					if ( present(time) ) then 
     call vector_function%get_values_set(quad_points_coordinates, time_, this%cell_function_values(1:num_quad_points,1:1) )
					else 
					call vector_function%get_values_set(quad_points_coordinates, this%cell_function_values(1:num_quad_points,1) )
					end if 

     ! Update interpolation on the physical space 
     call this%fe%apply_cell_map( this%cell_map, this%cell_interpolation, this%real_cell_interpolation) 

     ! Integration of interior moments int_K (u.q), q \in Q_{k-1,k-2,k-2} x Q_{k-2,k-1,k-2} x Q_{k-2,k-2,k-1}
     do qpoint = 1, num_quad_points
        factor = this%cell_map%get_det_jacobian(qpoint) * this%cell_quadrature%get_weight(qpoint)
        do ishape=1, this%fe%get_num_shape_functions() 
           call reference_fe%get_value(this%real_cell_interpolation, ishape, qpoint, v_shape_test)
           dof_values(d+ishape) = dof_values(d+ishape) + this%cell_function_values(qpoint,1) * v_shape_test * factor
        end do
     end do

  end if

end subroutine hex_Hcurl_interpolator_evaluate_vector_function_moments

!==================================================================================================
subroutine hex_Hcurl_interpolator_evaluate_function_components_moments(this, vef_lid, fe, vector_function_scalar_components, dof_values, time)
  class(hex_Hcurl_interpolator_t) , intent(inout) :: this
		integer(ip)                     , intent(in)    :: vef_lid 
  class(fe_cell_iterator_t)       , intent(in)    :: fe
  class(p_scalar_function_t)      , intent(in)    :: vector_function_scalar_components(:)
  real(rp) , allocatable          , intent(inout) :: dof_values(:) 
  real(rp) , optional             , intent(in)    :: time 

  ! Edges 
  type(vector_field_t)                :: tangent
  type(list_iterator_t)               :: vertex_iterator 
  type(point_t), pointer              :: edge_map_coordinates(:)
  integer(ip)                         :: edge_id  
  integer(ip)                         :: vertex_within_edge_id  

  ! Faces 
  integer(ip)                         :: facet_lid, facet_id 
  type(point_t), pointer              :: facet_map_coordinates(:)
  type(vector_field_t)                :: normal
  type(vector_field_t)                :: cross_product_function_normal
  type(vector_field_t)                :: cross_product_function_normal_proj
  type(vector_field_t)                :: col_jacobian
		type(vector_field_t)                :: normalized_col_jacobian
  integer(ip)                         :: vertex_within_facet_id 

  ! Common integration 
		class(reference_fe_t)   , pointer   :: reference_fe 
		class(reference_fe_t)   , pointer   :: reference_fe_geo 
		type(point_t)           , pointer   :: cell_coordinates(:) 
  real(rp)                            :: time_(1)  
  integer(ip)                         :: vertex_within_cell_id
  real(rp)                            :: shape_test, factor 
  type(vector_field_t)                :: v_shape_test, mapped_shape_test 
  integer(ip)                         :: idime, ishape, idof 
  integer(ip)                         :: qpoint, num_quad_points 
  type(point_t), pointer              :: quad_points_coordinates(:)
  type(list_iterator_t)               :: own_dofs

  integer(ip)                         :: d, i, iedge, icomp, istat
		real(rp) :: jacobian_restricted_to_face(2,2)  
		real(rp) :: inv_jacobian_restricted_to_face(2,2)
  			
  dof_values = 0.0_rp		
  if ( present(time) ) time_(1) = time 	
  reference_fe     => fe%get_reference_fe( this%field_id ) 
		reference_fe_geo => fe%get_reference_fe_geo()
				
		! Nedelec elements do not contain DOFs on vertices 
		if ( reference_fe%get_n_face_dim( vef_lid ) == 0 ) then 
		return 
		end if 
		
		! Extract cell coordinates 
		cell_coordinates => this%cell_map%get_coordinates() 
		call fe%get_nodes_coordinates( cell_coordinates ) 
	
     num_quad_points = this%edge_quadrature%get_num_quadrature_points()
     edge_map_coordinates => this%edge_map%get_coordinates()

			if ( reference_fe%get_n_face_dim( vef_lid ) == 1 ) then 
     vertex_within_edge_id = 1
     vertex_iterator = reference_fe%create_vertices_n_face_iterator(vef_lid)
     do while ( .not. vertex_iterator%is_upper_bound () )
        vertex_within_cell_id = vertex_iterator%get_current()
        call edge_map_coordinates(vertex_within_edge_id)%init( cell_coordinates(vertex_within_cell_id)%get_value() )
        call vertex_iterator%next()
        vertex_within_edge_id = vertex_within_edge_id + 1
     end do

     ! Update edge_map on current edge
     call this%edge_map%update(local_edge_id = vef_lid - reference_fe%get_first_n_face_id_of_dim(1)+1, &
                               reference_fe  = reference_fe,                                           &
                               quadrature    = this%edge_quadrature )

     ! Extract quadrature points coordinates 
     quad_points_coordinates => this%edge_map%get_quadrature_points_coordinates()

     ! Fill vector function values restricted to edge 
     select case(reference_fe%get_field_type())
     case ( field_type_scalar )
        ! reference_fe MUST BE a vector-valued FE
        assert (.false.)
     case ( field_type_vector )
        do icomp=1, reference_fe%get_num_field_components()
           if(present(time)) then
              call vector_function_scalar_components(icomp)%p%get_values_set_space_time(quad_points_coordinates,     & 
																																																																																								time_,                       & 
																																																																																								this%scalar_function_values_on_edge(1:num_quad_points,:))
           else
              call vector_function_scalar_components(icomp)%p%get_values_set_space(quad_points_coordinates,this%scalar_function_values_on_edge(1:num_quad_points,1))
           end if
           do qpoint = 1, num_quad_points
              call this%edge_function_values(qpoint,1)%set(icomp,this%scalar_function_values_on_edge(qpoint,1))
           end do
        end do
     case ( field_type_tensor )
        ! reference_fe MUST BE a vector-valued FE
        assert(.false.)
     end select

     own_dofs = reference_fe%create_dofs_n_face_iterator(vef_lid)
     ! Integrate edge boundary moments int_edge(g·tau q), q \in P_k-1
     do qpoint = 1, num_quad_points
        factor = this%edge_map%get_det_jacobian(qpoint) * this%edge_quadrature%get_weight(qpoint)
        call this%edge_map%get_tangent(qpoint, tangent)								
        call own_dofs%begin() 
        do ishape = 1, this%fe_1D%get_num_shape_functions()  
           idof = own_dofs%get_current() 
           call this%fe_1D%get_value(this%edge_interpolation, ishape, qpoint, shape_test)
           dof_values(idof) = dof_values(idof) + this%edge_function_values(qpoint,1) * shape_test * tangent * factor 
           call own_dofs%next() 
        end do
     end do
					
				elseif ( reference_fe%get_n_face_dim( vef_lid ) == 2) then  
		
     if ( reference_fe%get_num_dims() == 3 .and. reference_fe%get_order() > 1 ) then
																			
        ! Get face map coordinates
        num_quad_points         =  this%facet_quadrature%get_num_quadrature_points()
        facet_map_coordinates   => this%facet_map%get_coordinates()

        ! Extract coordinates of the vertices within the face
        vertex_within_facet_id = 1
        vertex_iterator = reference_fe%create_vertices_n_face_iterator(vef_lid)
        do while ( .not. vertex_iterator%is_upper_bound () )
           vertex_within_cell_id = vertex_iterator%get_current()
           call facet_map_coordinates(vertex_within_facet_id)%init( cell_coordinates(vertex_within_cell_id)%get_value() )
           call vertex_iterator%next()
           vertex_within_facet_id = vertex_within_facet_id + 1
        end do

        ! Update facet_map on current face
        facet_lid = vef_lid - reference_fe_geo%get_first_facet_id()+1
        call this%facet_map%update(reorientation_factor   = reference_fe_geo%get_normal_orientation_factor(facet_lid), &
                                   quadrature             = this%facet_quadrature ) 

        ! Extract quadrature points coordinates 
        quad_points_coordinates => this%facet_map%get_quadrature_points_coordinates()

        ! Fill vector function values restricted to face 
        select case(reference_fe%get_field_type())
        case ( field_type_scalar )
           ! reference_fe MUST BE a vector-valued FE
           assert (.false.)
        case ( field_type_vector )
           do icomp=1, reference_fe%get_num_field_components()
              if(present(time)) then
                 call vector_function_scalar_components(icomp)%p%get_values_set_space_time(quad_points_coordinates,  & 
																																																																																											time_,                    & 
																																																																																											this%scalar_function_values_on_facet(1:num_quad_points,:))
              else
                 call vector_function_scalar_components(icomp)%p%get_values_set_space(quad_points_coordinates,this%scalar_function_values_on_facet(1:num_quad_points,1))
              end if
              do qpoint = 1, num_quad_points
                 call this%facet_function_values(qpoint,1)%set(icomp,this%scalar_function_values_on_facet(qpoint,1))
              end do
           end do
        case ( field_type_tensor )
           ! reference_fe MUST BE a vector-valued FE
           assert(.false.)
        end select

        ! Integrate face boundary moments int_Face(g x n q), q \in Q_k-2,k-1 x Q_k-1,k-2
        do qpoint = 1, this%facet_quadrature%num_quadrature_points
           factor = this%facet_map%get_det_jacobian(qpoint) * this%facet_quadrature%get_weight(qpoint)
           call this%facet_map%get_normal(qpoint, normal)

           !! IMPORTANT NOTE: trick to have normals associated to each pair of faces pointing
           !!                 to the same direction. This only works provided we have an "oriented"
           !!                 triangulation.
           normal = reference_fe%get_normal_orientation_factor( facet_lid ) * normal

           ! Compute g x n
           call cross_product_function_normal%init(0.0_rp) 
           cross_product_function_normal = cross_product(this%facet_function_values(qpoint,1),normal)

           ! Multiply the transpose of the jacobian with normalized columns by g x n
           ! This is required to transform g x n in a vector contained within the face
           call cross_product_function_normal_proj%init(0.0_rp)
           do i=1,reference_fe%get_num_dims()-1
              call this%facet_map%get_jacobian_column(i,qpoint,col_jacobian)
              col_jacobian = col_jacobian * (1.0_rp/col_jacobian%nrm2())
              call cross_product_function_normal_proj%set(i, col_jacobian*cross_product_function_normal)
           end do
											
										! WARNING: Compute Jacobian restricted to face, taking adventadge of the structured meshing! (only diagonal filling) 
											do idime=1,2
											 call this%facet_map%get_jacobian_column(idime,qpoint,col_jacobian)
												  call this%facet_map%get_jacobian_column(idime,qpoint,normalized_col_jacobian)
														normalized_col_jacobian = (1.0_rp/normalized_col_jacobian%nrm2()) * normalized_col_jacobian 
												  jacobian_restricted_to_face(idime,idime) = col_jacobian*normalized_col_jacobian
              inv_jacobian_restricted_to_face(idime,idime) = 1.0_rp/jacobian_restricted_to_face(idime,idime)
											end do 

           ! Apply face_map to v_shape_test 
           own_dofs = reference_fe%create_dofs_n_face_iterator(vef_lid)
           do ishape=1, this%fe_2D%get_num_shape_functions() 
              idof = own_dofs%get_current() 
              call this%fe_2D%get_value(this%facet_interpolation, ishape, qpoint, v_shape_test)    

														   ! Apply Nedelec mapping to test function  
                 call mapped_shape_test%set(1, inv_jacobian_restricted_to_face(1,1)*v_shape_test%get(1) )
																	call mapped_shape_test%set(2, inv_jacobian_restricted_to_face(2,2)*v_shape_test%get(2) )

              dof_values(idof) = dof_values(idof) + cross_product_function_normal_proj * mapped_shape_test * factor
              call own_dofs%next() 
           end do
        end do
     end if
					end if 

end subroutine hex_Hcurl_interpolator_evaluate_function_components_moments

! ================================================================================
subroutine hex_Hcurl_interpolator_free( this ) 
  implicit none
  class(hex_Hcurl_interpolator_t)   , intent(inout) :: this
  integer(ip) :: istat 

  ! Edge related data  
  call this%fe_1D%free()
  call this%edge_quadrature%free() 
  call this%edge_map%free() 
  call this%edge_interpolation%free()  

  ! Face related data  
  call this%fe_2D%free()
  call this%facet_quadrature%free() 
  call this%facet_map%free() 
  call this%facet_interpolation%free() 

  ! Element related data  
  call this%fe%free()
  call this%cell_quadrature%free() 
  call this%cell_map%free() 
  call this%cell_interpolation%free() 
		call this%real_cell_interpolation%free()

  ! Functions evaluations
  if ( allocated(this%edge_function_values))  deallocate( this%edge_function_values , stat=istat); check(istat==0) 
  if ( allocated(this%facet_function_values)) deallocate( this%facet_function_values , stat=istat); check(istat==0) 
  if ( allocated(this%cell_function_values))  deallocate( this%cell_function_values , stat=istat); check(istat==0) 

  if ( allocated(this%scalar_function_values_on_edge) )  call memfree( this%scalar_function_values_on_edge, __FILE__, __LINE__ ) 
  if ( allocated(this%scalar_function_values_on_facet) ) call memfree( this%scalar_function_values_on_facet, __FILE__, __LINE__ )

end subroutine hex_Hcurl_interpolator_free
