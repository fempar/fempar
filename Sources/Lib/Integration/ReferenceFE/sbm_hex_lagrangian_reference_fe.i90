! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published byfill_inter
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!**************************************************************************************************
! Deferred TBP implementors from reference_fe_t
!**************************************************************************************************

function hex_lagrangian_reference_fe_check_compatibility_of_n_faces                   &
     &                      (target_reference_fe,source_reference_fe, source_n_face_id,target_n_face_id)
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)  :: target_reference_fe
  class(reference_fe_t)               , intent(in)  :: source_reference_fe
  integer(ip)                         , intent(in)  :: source_n_face_id ! Local n-face ID
  integer(ip)                         , intent(in)  :: target_n_face_id ! Local n-face ID
  logical :: hex_lagrangian_reference_fe_check_compatibility_of_n_faces 
  integer(ip) :: idime

  select type(source_reference_fe)
     class is(hex_lagrangian_reference_fe_t)
        ! Get number nodes per dimension
     assert (target_reference_fe%num_dims == source_reference_fe%num_dims)
     do idime = 1, target_reference_fe%num_dims
        assert (target_reference_fe%order_vector(idime) == source_reference_fe%order_vector(idime))
     end do
     assert (target_reference_fe%get_n_face_dim(target_n_face_id) == source_reference_fe%get_n_face_dim(source_n_face_id))
     assert (target_reference_fe%get_n_face_dim(target_n_face_id) < 3)
     assert (target_reference_fe%num_field_components == source_reference_fe%num_field_components)
     assert (target_reference_fe%get_num_own_dofs_n_face(target_n_face_id) == source_reference_fe%get_num_own_dofs_n_face(source_n_face_id))
     hex_lagrangian_reference_fe_check_compatibility_of_n_faces = .true.
     class default
     hex_lagrangian_reference_fe_check_compatibility_of_n_faces = .false.
  end select

end function hex_lagrangian_reference_fe_check_compatibility_of_n_faces

!==================================================================================================
function hex_lagrangian_reference_fe_get_characteristic_length ( this )
  implicit none 
  class(hex_lagrangian_reference_fe_t), intent(in) :: this 
  real(rp)  :: hex_lagrangian_reference_fe_get_characteristic_length 
  hex_lagrangian_reference_fe_get_characteristic_length =  2.0_rp
end function hex_lagrangian_reference_fe_get_characteristic_length

!**************************************************************************************************
! Deferred TBP implementors from lagrangian_reference_fe_t
!**************************************************************************************************

!==================================================================================================
function hex_lagrangian_reference_fe_get_num_subcells(this, num_refinements) result(num_subcells)
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: num_refinements
  integer(ip)                                         :: num_subcells
  num_subcells = (num_refinements+1)**this%num_dims
end function hex_lagrangian_reference_fe_get_num_subcells

!==================================================================================================
subroutine hex_lagrangian_reference_fe_get_subcells_connectivity(this, num_refinements, connectivity)
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: num_refinements
  integer(ip)                         , intent(inout) :: connectivity(:,:)
  integer(ip) :: order_vector(this%num_dims)
  integer(ip) :: num_subelems
  integer(ip) :: subelem
  integer(ip) :: geo_nnodes
  integer(ip) :: local_node
  integer(ip) :: first_coord(this%num_dims)
  integer(ip) :: local_coord(this%num_dims)
  integer(ip) :: global_coord(this%num_dims)
  integer(ip) :: ones_dim(this%num_dims)
  ones_dim = 1
  num_subelems = this%get_num_subcells(num_refinements=num_refinements)
  geo_nnodes = this%get_num_vertices()
  assert(size(connectivity,1) >= geo_nnodes)
  assert(size(connectivity,2) >= num_subelems)
  order_vector = num_refinements+1

  do subelem = 1, num_subelems
     !call this%get_node_local_coordinates(first_coord,subelem, & 
     !                                      & this%num_dims,this%order(1)-1)
     call index_to_ijk( subelem, this%num_dims, order_vector, first_coord )

     do local_node = 1, geo_nnodes
        !call this%get_node_local_coordinates(local_coord,local_node,this%num_dims,1)
        call index_to_ijk( local_node, this%num_dims, 2*ones_dim, local_coord )

        global_coord = first_coord + local_coord 
        !connectivity(local_node, subelem) = this%get_node_local_id(global_coord, &
        !                                                   & this%num_dims,this%order(1)) ! 
        connectivity(local_node, subelem) = ijk_to_index(global_coord, order_vector,this%num_dims)+1
     end do
  end do
end subroutine hex_lagrangian_reference_fe_get_subcells_connectivity

!==================================================================================================
subroutine hex_lagrangian_create_data_out_quadrature ( this, num_refinements, quadrature )
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: num_refinements
  type(quadrature_t)                  , intent(inout) :: quadrature

  integer(ip)        :: i
  type(node_array_t) :: node_array 
  integer(ip)        :: order_vector(SPACE_DIM)
  
  assert ( num_refinements >= 0 )

  call quadrature%free()
  
  order_vector = num_refinements+1
  call node_array%create( this%polytope, order_vector ) 

  call quadrature%create( this%num_dims, node_array%num_nodes )
  do i=1,this%num_dims
     quadrature%coordinates(i,:) = node_array%coordinates(i,:)*(2.0_rp/order_vector(i))-1.0_rp
  end do
  quadrature%weight = 1.0_rp
  
  call node_array%free()
end subroutine hex_lagrangian_create_data_out_quadrature

!==================================================================================================
subroutine hex_lagrangian_reference_fe_fill_quadrature ( this, quadrature ) 
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                  , intent(inout) :: quadrature
  call quadrature%fill_hex_gauss_legendre()
end subroutine hex_lagrangian_reference_fe_fill_quadrature

!==================================================================================================
subroutine hex_lagrangian_reference_fe_fill_nodal_quadrature( this, quadrature )
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this 
  type(quadrature_t)                  , intent(inout) :: quadrature
  integer(ip) :: i
  do i=1,this%num_dims
     if (this%order_vector(i) > 0 ) then 
     quadrature%coordinates(i,:) = this%node_array%coordinates(i,:)*(2.0_rp/this%order_vector(i))-1.0_rp
  else 
  quadrature%coordinates(i,:) = this%node_array%coordinates(i,:)
  end if 
  end do
  quadrature%weight = 1.0_rp
end subroutine hex_lagrangian_reference_fe_fill_nodal_quadrature

! This subroutine fills the interpolation using the polynomial_names machinery
!==================================================================================================
subroutine hex_lagrangian_reference_fe_fill_interpolation( this, quadrature, interpolation, order_vector )
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in) :: this
  type(quadrature_t)              , intent(in)    :: quadrature
  type(interpolation_t)           , intent(inout) :: interpolation    
  integer(ip) , optional          , intent(in)    :: order_vector(SPACE_DIM)
  type(tensor_product_polynomial_space_t) :: tensor_product_polynomial_space
  type(polynomial_basis_t)    :: polynomial_1D_basis(SPACE_DIM)
  type(lagrange_polynomial_t)             :: polynomial_1D

  real(rp), allocatable :: tensor_product_values(:)
  real(rp), allocatable :: tensor_product_gradients(:,:)
  real(rp), allocatable :: tensor_product_second_derivatives(:,:)

  integer(ip) :: idime, q_point

  do idime=1,interpolation%num_dims
     call polynomial_1D%generate_basis( this%order_vector(idime), polynomial_1D_basis(idime) )
  end do

  call tensor_product_polynomial_space%create(interpolation%num_dims,polynomial_1D_basis)
  call tensor_product_polynomial_space%fill( quadrature%get_coordinates() )

  !assert ( interpolation%num_shape_functions == tensor_product_polynomial_space%get_num_polynomials() )

  call memalloc(tensor_product_polynomial_space%get_num_polynomials(),tensor_product_values,__FILE__,__LINE__)
  do q_point=1, quadrature%get_num_quadrature_points()
    call tensor_product_polynomial_space%evaluate_values( q_point, tensor_product_values )
    interpolation%shape_functions(1,:,q_point) = tensor_product_values(:)
  end do
  call memfree(tensor_product_values,__FILE__,__LINE__)
  
  if(interpolation%my_duties%compute_first_derivatives_is_assigned()) then
     call memalloc(SPACE_DIM,tensor_product_polynomial_space%get_num_polynomials(),tensor_product_gradients,__FILE__,__LINE__)
     do q_point=1, quadrature%get_num_quadrature_points()
       call tensor_product_polynomial_space%evaluate_gradients( q_point, tensor_product_gradients )
       interpolation%shape_derivatives(1,:,:,q_point) = tensor_product_gradients(:,:)
     end do
     call memfree(tensor_product_gradients,__FILE__,__LINE__)
  end if
  
  if(interpolation%my_duties%compute_second_derivatives_is_assigned()) then
     call memalloc(interpolation%num_entries_symmetric_tensor,            &
                   tensor_product_polynomial_space%get_num_polynomials(), &
                   tensor_product_second_derivatives,__FILE__,__LINE__)
     do q_point=1, quadrature%get_num_quadrature_points()
       call tensor_product_polynomial_space%evaluate_second_derivatives( q_point, tensor_product_second_derivatives )
       interpolation%hessian(1,:,:,q_point) = tensor_product_second_derivatives(:,:)
     end do
     call memfree(tensor_product_second_derivatives,__FILE__,__LINE__)
  end if

  do idime=1,interpolation%num_dims
     call polynomial_1D_basis(idime)%free()
  end do
  call polynomial_1D%free()
  call tensor_product_polynomial_space%free()

end subroutine hex_lagrangian_reference_fe_fill_interpolation

! Here we define the dim-1 quadrature and next translate the nodes
! using the facet type to dim. Next, use the same machinary as for the volume with this new quadrature.
!!==================================================================================================
subroutine hex_lagrangian_reference_fe_fill_interp_restricted_to_facet( this, local_quadrature, & 
     & facet_lid, subfacet_lid, facet_interpolation )
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                  , intent(in)    :: local_quadrature
  integer(ip)                         , intent(in)    :: facet_lid
  integer(ip)                         , intent(in)    :: subfacet_lid
  type(interpolation_t)               , intent(inout) :: facet_interpolation
  type(quadrature_t) :: aux_quadrature
  integer(ip) :: c,idime,iface,n_face_index
  ! Add offset to have same numbering as in polytope
  n_face_index = facet_lid+this%get_first_facet_id()-1
  ! Create a d-dimensional quadrature as follows
  call aux_quadrature%create( this%num_dims, local_quadrature%num_quadrature_points )
  c = 0
  do idime = 0,this%num_dims-1
     if ( this%polytope%n_face_dir_is_fixed( n_face_index, idime ) == 1 ) then
        c = c+1
        aux_quadrature%coordinates(idime+1,:) = local_quadrature%coordinates(c,:)
        if ( subfacet_lid >= 0 ) then
          aux_quadrature%coordinates(idime+1,:) =                         &
            ( aux_quadrature%coordinates(idime+1,:) - 1.0_rp ) / 2.0_rp + &
            real( IBITS( subfacet_lid, c-1 , 1 ), rp )
        end if
     else if ( this%polytope%n_face_dir_coordinate( n_face_index, idime ) == 0 ) then
        aux_quadrature%coordinates(idime+1,:) = -1.0_rp
     else
        aux_quadrature%coordinates(idime+1,:) = 1.0_rp
     end if
  end do
  call this%fill_interpolation( aux_quadrature, facet_interpolation ) 
  call aux_quadrature%free()
end subroutine hex_lagrangian_reference_fe_fill_interp_restricted_to_facet

!==================================================================================================
subroutine index_to_ijk( index, ndime, n_pols_dim, ijk )
  implicit none
  integer(ip)                         , intent(in) :: index
  integer(ip)                         , intent(in) :: ndime
  integer(ip)                         , intent(in) :: n_pols_dim(SPACE_DIM)
  integer(ip)                         , intent(inout) :: ijk(SPACE_DIM)
  integer(ip) :: i,aux
  ijk = 0
  aux = (index-1)
  do i = 1,ndime-1
     ijk(i) = mod(aux, n_pols_dim(i))
     aux = aux/n_pols_dim(i)
  end do
  ijk(ndime) = aux
  !ijk(1:ndime) = ijk(1:ndime)
end subroutine index_to_ijk

! @sbadia: It could be replaced by an anisotropic quadrature
!==================================================================================================
function hex_lagrangian_reference_fe_compute_num_quadrature_points( this, degree, dimension )
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: degree
  integer(ip)                         , intent(in)    :: dimension
  integer(ip) :: hex_lagrangian_reference_fe_compute_num_quadrature_points
  hex_lagrangian_reference_fe_compute_num_quadrature_points = int(ceiling(real(degree + 1,rp)/2.0_rp)**real(dimension,rp),ip)
end function hex_lagrangian_reference_fe_compute_num_quadrature_points

!==================================================================================================
subroutine hex_lagrangian_reference_fe_fill_qpoints_permutations(this, quadrature, qpoints_perm)
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                  , intent(in)    :: quadrature
  type(allocatable_array_ip2_t)       , intent(inout) :: qpoints_perm
  integer(ip)    :: ndime, n_q_points, order
  
  ndime      = quadrature%get_num_dims()
  n_q_points = quadrature%get_num_quadrature_points()
  order      = int(real(n_q_points,rp)**(1.0_rp/real(ndime,rp)),ip)+1
  
  call this%node_array%fill_permutations( order, &
                                          ndime, &
                                          this%polytope, &
                                          qpoints_perm )
  
end subroutine hex_lagrangian_reference_fe_fill_qpoints_permutations

!==================================================================================================
subroutine hex_lagrangian_reference_fe_free ( this )
  implicit none 
  class(hex_lagrangian_reference_fe_t), intent(inout) :: this 
  call lagrangian_reference_fe_free ( this )
end subroutine hex_lagrangian_reference_fe_free

! Subroutine to deal with high order parametrizations of the boundary
!==================================================================================================
subroutine hex_lagrangian_reference_fe_blending(this,values)
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  type(point_t)                       , intent(inout) :: values(:)

  integer(ip) :: i,j, ipoin, nlocs, ndime,nnode

  assert(size(values) == this%node_array%num_nodes)

  ndime = this%num_dims
  nnode = this%node_array%num_nodes

  if(ndime==1) then
     nlocs=nnode
  else if(ndime==2) then
     nlocs=nint(sqrt(real(nnode,rp)))
  else
     nlocs=nint(real(nnode,rp)**(1.0_rp/3.0_rp))
  end if

  if(ndime==2) then
     !ipoin=0
     do j = 2, nlocs - 1
        do i = 2, nlocs - 1
           ipoin = nlocs*(j-1)+i
           !ipoin = ipoin + 1
           call blend_2D(this%nodal_quadrature%coordinates(1,ipoin), & ! reference coordinates
                &        this%nodal_quadrature%coordinates(2,ipoin), &
                &        values(1), &                 ! value at vertex 1
                &        values(nlocs), &             ! value at vertex 2
                &        values(nlocs*(nlocs-1)+1), & ! value at vertex 3
                &        values(nlocs*nlocs), &       ! value at vertex 4
                &        values(i), &                 ! value at edge 5
                &        values(nlocs*(nlocs-1)+i), & ! value at edge 6
                &        values(nlocs*(j-1)+1), &     ! value at edge 7
                &        values(nlocs*j), &           ! value at edge 8
                &        values(ipoin))               ! interpolated value

        end do
     end do
  end if

end subroutine hex_lagrangian_reference_fe_blending

!**************************************************************************************************
! Concrete TBPs of this derived data type
!**************************************************************************************************

!==================================================================================================
subroutine hex_lagrangian_reference_fe_fill_h_refinement_interpolation ( this )
  implicit none 
  class(hex_lagrangian_reference_fe_t), intent(inout) :: this
  type(quadrature_t) :: h_refined_quadrature
  integer(ip)        :: num_refinements
  num_refinements = 1
  call this%create_data_out_quadrature( max((num_refinements+1)*this%order-1,0), h_refined_quadrature )
  call this%create_interpolation( h_refined_quadrature, this%h_refinement_interpolation )
  call h_refined_quadrature%free()
end subroutine hex_lagrangian_reference_fe_fill_h_refinement_interpolation

!==================================================================================================
subroutine hex_lagrangian_reference_fe_fill_h_refinement_permutations ( this )
  implicit none 
  class(hex_lagrangian_reference_fe_t), intent(inout) :: this
  call this%fill_n_subfacet_permutation(this%num_dims-1, &
                                       this%h_refinement_subfacet_permutation)
  if ( this%num_dims == 3 ) then
     call this%fill_n_subfacet_permutation(this%num_dims-2, &
                                          this%h_refinement_subedge_permutation)
  end if
end subroutine hex_lagrangian_reference_fe_fill_h_refinement_permutations

!==================================================================================================
subroutine hex_lagrangian_reference_fe_fill_n_subfacet_permutation ( this, n_face_dime, permutation_array )
  implicit none 
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this              
  integer(ip)                         , intent(in)    :: n_face_dime
  integer(ip)           , allocatable , intent(inout) :: permutation_array(:,:,:)
  integer(ip)           :: num_refinements, num_n_faces, num_n_subfaces, num_dofs_on_n_face
  integer(ip)           :: first_n_face_id, n_face_id, n_subface_id, dof_on_n_subface_id, icomp
  type(node_array_t)    :: h_refinement_node_array   
  type(node_iterator_t) :: node_iterator_on_n_subface
  
  num_refinements    = 1
  num_n_faces        = this%get_num_n_faces_of_dim(n_face_dime)
  num_n_subfaces     = ( num_refinements + 1 ) ** n_face_dime     ! Topology-dependent
  first_n_face_id    = this%get_first_n_face_id_of_dim(n_face_dime)
  num_dofs_on_n_face = this%get_num_dofs_on_n_face(first_n_face_id) ! Only cubes and simplices

  call memalloc(num_n_faces,num_n_subfaces,num_dofs_on_n_face,permutation_array,__FILE__,__LINE__)

  call h_refinement_node_array%create( this%polytope, ( num_refinements + 1 ) * this%order_vector )
  
  do n_face_id = first_n_face_id, first_n_face_id+num_n_faces-1
     do n_subface_id = 0, num_n_subfaces-1
        dof_on_n_subface_id = 0
        node_iterator_on_n_subface = h_refinement_node_array%create_node_iterator ( this%polytope%get_n_face(n_face_id), & 
                                                                                    n_subface_id, own_boundary = .true. )
        do icomp = 1, this%num_field_components
           call node_iterator_on_n_subface%init()
           do while (.not. node_iterator_on_n_subface%has_finished() )
              dof_on_n_subface_id = dof_on_n_subface_id + 1
              permutation_array(n_face_id-first_n_face_id+1,n_subface_id+1,dof_on_n_subface_id) = node_iterator_on_n_subface%current()
              call node_iterator_on_n_subface%next()
           end do
        end do
        assert( dof_on_n_subface_id == num_dofs_on_n_face )
     end do
  end do

  call h_refinement_node_array%free()
  
end subroutine hex_lagrangian_reference_fe_fill_n_subfacet_permutation

!==================================================================================================
subroutine hex_lagrangian_reference_fe_interpolate_nodal_values_on_subcell ( this,                   &
                                                                             subcell_id,             &
                                                                             nodal_values_on_parent, & 
                                                                             nodal_values_on_child )
  implicit none 
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this              
  integer(ip)                         , intent(in)    :: subcell_id
  real(rp)                            , intent(in)    :: nodal_values_on_parent(:)
  real(rp)                            , intent(inout) :: nodal_values_on_child(:)
  integer(ip)           :: num_refinements
  integer(ip)           :: icomp, ishape_fe, ishape_coarser_fe, qpoint
  real(rp)              :: coefficient
  type(node_array_t)    :: h_refinement_node_array
  type(node_iterator_t) :: node_iterator_on_subcell
  
  num_refinements = 1
  call h_refinement_node_array%create( this%polytope, ( num_refinements + 1 ) * this%order_vector )
  
  node_iterator_on_subcell = h_refinement_node_array%create_node_iterator( this%polytope%get_n_face(this%polytope%num_n_faces), &
                                                                subcell_id, own_boundary = .true. )
  
  nodal_values_on_child = 0.0_rp
  ishape_fe = 0
  do icomp = 0, this%num_field_components-1
     call node_iterator_on_subcell%init()
     do while (.not. node_iterator_on_subcell%has_finished() )
        qpoint = node_iterator_on_subcell%current()
        ishape_fe = ishape_fe + 1
        do ishape_coarser_fe = 1, this%get_num_shape_functions()
           call this%get_h_refinement_coefficient(ishape_fe,ishape_coarser_fe,qpoint,coefficient)
           nodal_values_on_child(ishape_fe) = nodal_values_on_child(ishape_fe) + &
                                      coefficient * nodal_values_on_parent(ishape_coarser_fe)
        end do
        call node_iterator_on_subcell%next()
     end do
  end do
  assert( ishape_fe == this%get_num_shape_functions() )
  
  call h_refinement_node_array%free()
  
end subroutine hex_lagrangian_reference_fe_interpolate_nodal_values_on_subcell

!==================================================================================================
subroutine hex_lagrangian_reference_fe_project_nodal_values_on_cell ( this,                     &
                                                                      nodal_values_on_children, &
                                                                      nodal_values_on_parent )
  implicit none 
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this  
  real(rp)                            , intent(in)    :: nodal_values_on_children(:,:)
  real(rp)                            , intent(inout) :: nodal_values_on_parent(:)

  integer(ip),        allocatable :: subcell_to_cell_node_identifier(:)  
  real(rp),           allocatable :: global_patch_children_values_array(:)  
  integer(ip)                     :: subcell_id, num_shape_functions, num_child_cells_x_parent_cell, ishape, jshape
  integer(ip)                     :: num_nodes_children_patch, num_field_components, field_comp, patch_node_id, node
  
  num_nodes_children_patch   = this%get_num_nodes_children_patch()
  num_field_components       = this%get_num_field_components()
  
  ! Number of shape functions (parent cell)
  num_shape_functions        = this%get_num_shape_functions()

  ! We are assuming that the number of nodes of the coarse cell (parent)
  ! and the fine subcell (child) is the same for all subcells, i. e. the
  ! order of the finite elements (parent and child) is the same.
  num_child_cells_x_parent_cell = this%get_num_subcells(num_refinements=1)

  !this%get_num_nodes() = Number of nodes of the reference fe
  call memalloc(this%get_num_nodes(),subcell_to_cell_node_identifier,__FILE__,__LINE__)
  
  ! Allocate global_children_values_array
  call memalloc(num_nodes_children_patch*num_field_components,global_patch_children_values_array,__FILE__,__LINE__)
  
  ! Assembly the global children nodal values array
  do subcell_id = 1, num_child_cells_x_parent_cell
     call this%fill_subcell_to_cell_node_identifier(subcell_id, subcell_to_cell_node_identifier)
     do ishape = 1, num_shape_functions
        field_comp    = this%get_component_node(ishape)     
        patch_node_id = this%get_scalar_from_vector_node(ishape)
        node          = subcell_to_cell_node_identifier(patch_node_id)
        global_patch_children_values_array((field_comp-1)*num_nodes_children_patch+node) = nodal_values_on_children(subcell_id,patch_node_id)
     end do
  end do
  ! Compute the nodal values on the parent finite element
  nodal_values_on_parent(:) = 0.0_rp       
    do ishape=1, num_shape_functions
      do jshape=1, num_nodes_children_patch*num_field_components
        nodal_values_on_parent(ishape) = nodal_values_on_parent(ishape) + this%coarsening_projection_operator(ishape,jshape)*global_patch_children_values_array(jshape)
      end do
    end do
  call memfree(subcell_to_cell_node_identifier,__FILE__,__LINE__)
  call memfree(global_patch_children_values_array,__FILE__,__LINE__)
end subroutine hex_lagrangian_reference_fe_project_nodal_values_on_cell

!==================================================================================================
subroutine hex_lagrangian_reference_fe_get_h_refinement_coefficient ( this, ishape_fe,   & 
                                                                      ishape_coarser_fe, & 
                                                                      qpoint, coefficient )
  implicit none 
  class(hex_lagrangian_reference_fe_t), target, intent(in)    :: this
  integer(ip)                                 , intent(in)    :: ishape_fe
  integer(ip)                                 , intent(in)    :: ishape_coarser_fe
  integer(ip)                                 , intent(in)    :: qpoint
  real(rp)                                    , intent(inout) :: coefficient
  assert( ishape_fe >= 1 .and. ishape_fe <= this%num_shape_functions )
  assert( ishape_coarser_fe >= 1 .and. ishape_coarser_fe <= this%num_shape_functions )
  assert( qpoint >= 1 )
  if ( this%node_component_array(ishape_fe,2) == & 
       this%node_component_array(ishape_coarser_fe,2) ) then
     coefficient = this%h_refinement_interpolation%shape_functions(1, & 
                               this%node_component_array(ishape_coarser_fe,1),qpoint)
  else
     coefficient = 0.0_rp
  end if
end subroutine hex_lagrangian_reference_fe_get_h_refinement_coefficient

!==================================================================================================
subroutine hlrf_fill_scalar_coarsening_projection_operator(this)
  implicit none
  class(hex_lagrangian_reference_fe_t) , intent(inout)    ::  this
  
  real(rp),           allocatable :: coarse_mass_matrix(:,:)
  real(rp),           allocatable :: children_patch_mass_matrix(:,:)
  real(rp)                        :: cell_scaling_factor
  
  type(interpolation_duties_t)    :: interpolation_duties
  type(quadrature_t)              :: cell_quadrature
  type(interpolation_t)           :: cell_interpolation

  integer(ip)                     :: num_child_cells_x_parent_cell, num_shape_functions
  integer(ip)                     :: ierr, num_nodes_children_patch

  ! COMPUTE THE L2 PROJECTION OPERATOR FOR COARSENING
  ! This projection operator can only be computed when ENABLE_LAPACK flag 
  ! has been activated during the compilation process

#ifdef ENABLE_LAPACK
  
  num_shape_functions = this%get_num_nodes()
  num_nodes_children_patch = this%get_num_nodes_children_patch()

  ! Allocate scalar field coarsening projection operator
  call memalloc(num_shape_functions, &
                num_nodes_children_patch, &
                this%coarsening_projection_operator,__FILE__,__LINE__)
  this%coarsening_projection_operator = 0.0_rp
  
  if (this%field_type == field_type_scalar) then  
  
    ! Set-up interpolation duties
    call interpolation_duties%assign_compute_first_derivatives(.false.)
  
    !num_shape_functions = this%get_num_shape_functions()
    !num_shape_functions = this%num_shape_functions

    ! Create (coarse) cell quadrature
    call this%create_quadrature(cell_quadrature)
  
    ! We are assuming that the number of nodes of the coarse cell (parent)
    ! and the fine subcell (child) is the same for all subcells, i. e. the
    ! order of the finite elements (parent and child) is the same.
    num_child_cells_x_parent_cell = this%get_num_subcells(num_refinements=1) 

    ! Compute mass matrices
    call this%create_interpolation( cell_quadrature, cell_interpolation, interpolation_duties)  
  
    ! Allocate coarse_mass_matrix
    call memalloc(num_shape_functions,num_shape_functions,coarse_mass_matrix,__FILE__,__LINE__)
    coarse_mass_matrix = 0.0_rp

    !num_nodes_children_patch = this%get_num_nodes_children_patch()
  
    ! Allocate children patch mass matrix (global mass matrix)
    call memalloc(num_nodes_children_patch,num_nodes_children_patch,children_patch_mass_matrix,__FILE__,__LINE__)
    children_patch_mass_matrix = 0.0_rp  

    call this%compute_children_mass_matrix_for_scalar_fields(cell_quadrature, cell_interpolation, num_child_cells_x_parent_cell, & 
                                                 children_patch_mass_matrix, coarse_mass_matrix)

    ! Fine cells mass matrix scaling factor
    cell_scaling_factor = 1.0_rp/real(ISHFT(1_ip, this%num_dims),rp)
  
    ! Scale children_patch_mass_matrix
    children_patch_mass_matrix = children_patch_mass_matrix*cell_scaling_factor 

    ! Multiply the projection operator Cij-s (A) by the child mass matrix (B)  
    call DGEMM(TRANSA = 'N', & 
               TRANSB = 'N', & 
               M      = num_shape_functions, & 
               N      = num_nodes_children_patch, &
               K      = num_nodes_children_patch, & 
               ALPHA  = 1.0_rp, &
               A      = this%h_refinement_interpolation%shape_functions(1,:,:), & 
               LDA    = num_shape_functions, &
               B      = children_patch_mass_matrix, & 
               LDB    = num_nodes_children_patch, & 
               BETA   = 1.0_rp, & 
               C      = this%coarsening_projection_operator, & 
               LDC    = num_shape_functions)

    ! Cholesky factorization
    call DPOTRF(UPLO = 'U', &
                N    = num_shape_functions, &
                A    = coarse_mass_matrix, &
                LDA  = num_shape_functions, &
                INFO = ierr)

    ! Solve the L2 projection problem
    call DPOTRS(UPLO = 'U', &
                N    = num_shape_functions, &
                NRHS = num_nodes_children_patch, &
                A    = coarse_mass_matrix, &
                LDA  = num_shape_functions, &
                B    = this%coarsening_projection_operator, &
                LDB  = num_shape_functions, &
                INFO = ierr)

    call cell_quadrature%free()
    call cell_interpolation%free()
    call memfree(coarse_mass_matrix,__FILE__,__LINE__)
    call memfree(children_patch_mass_matrix,__FILE__,__LINE__)
  else
    ! Compute scalar projection operator when field_type is different from field_type_scalar
    call this%fill_multicomp_fe_scalar_projection_operator()
  end if 
#else
  write (0,*) 'Error: reference_fe.f90 was not compiled with -DENABLE_LAPACK.'
  write (0,*) 'Error: You must activate this cpp macro in order to use the LAPACK'
  check(.false.)
#endif    

end subroutine hlrf_fill_scalar_coarsening_projection_operator

!==================================================================================================
function hex_lagrangian_get_num_nodes_children_patch(this)
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)  :: this
  integer(ip)   ::  hex_lagrangian_get_num_nodes_children_patch
  hex_lagrangian_get_num_nodes_children_patch = (this%order*2+1)**this%num_dims
end function hex_lagrangian_get_num_nodes_children_patch

!==================================================================================================
function hex_lagrangian_get_num_nodes(this)
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)  :: this
  integer(ip)   ::  hex_lagrangian_get_num_nodes
  hex_lagrangian_get_num_nodes = (this%order+1)**this%num_dims
end function hex_lagrangian_get_num_nodes

!==================================================================================================
subroutine hlrf_scalar_to_multicomp_coarsening_projection_operator(this)
  implicit none
  class(hex_lagrangian_reference_fe_t) , intent(inout)    ::  this  

  type(hex_lagrangian_reference_fe_t)   :: scalar_reference_fe  
  integer(ip)                           :: num_field_components, num_scalar_shape_functions, field_component, node, epos, spos, ishape
  integer(ip)                           :: num_shape_functions_children_patch, num_nodes_children_patch
  
  ! COMPUTE THE L2 PROJECTION OPERATOR FOR COARSENING
  num_field_components                 = this%get_num_field_components()
  num_nodes_children_patch             = this%get_num_nodes_children_patch()
  num_shape_functions_children_patch   = num_nodes_children_patch*num_field_components

  ! Allocate projection_operator 
  call memrealloc(this%num_shape_functions, num_shape_functions_children_patch, &
                  this%coarsening_projection_operator,__FILE__,__LINE__)
  
  !Assembly projection operator ordered as in node_component_array
  do ishape = 1, this%num_shape_functions
     field_component = this%get_component_node(ishape)
     node            = this%get_scalar_from_vector_node(ishape)
     spos            = (field_component-1)*num_nodes_children_patch+1
     epos            = num_nodes_children_patch*field_component
     this%coarsening_projection_operator(ishape,spos:epos) = this%coarsening_projection_operator(node,1:num_nodes_children_patch)
     this%coarsening_projection_operator(ishape,1:spos-1)  = 0.0_rp
     this%coarsening_projection_operator(ishape,epos+1: )  = 0.0_rp
  end do
end subroutine hlrf_scalar_to_multicomp_coarsening_projection_operator

!==================================================================================================
subroutine hlrf_fill_multicomp_fe_scalar_projection_operator(this)
   implicit none
   class(hex_lagrangian_reference_fe_t), intent(inout)    :: this
   type(p_reference_fe_t) :: reference_fe
   integer(ip) :: istat
   assert ( this%field_type /= field_type_scalar )
   reference_fe =  make_reference_fe ( topology = this%topology, &
                                       fe_type = this%fe_type,   &
                                       num_dims = this%num_dims, &
                                       order = this%order,       &
                                       field_type = field_type_scalar, &
                                       conformity = this%conformity, &
                                       continuity = this%continuity )
   select type (reference_fe => reference_fe%p)
   class is (lagrangian_reference_fe_t)
     this%coarsening_projection_operator = reference_fe%coarsening_projection_operator
   class DEFAULT
     check(.false.)
   end select
   call reference_fe%free()
end subroutine hlrf_fill_multicomp_fe_scalar_projection_operator

!==================================================================================================
subroutine hex_lagrangian_compute_children_mass_matrix_for_scalar_fields(this, cell_quadrature, &
                                                                               cell_interpolation, &
                                                                               num_child_cells_x_parent_cell, &
                                                                               children_patch_mass_matrix, &
                                                                               coarse_mass_matrix)
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                  , intent(in)    :: cell_quadrature
  type(interpolation_t)               , intent(in)    :: cell_interpolation
  integer(ip)                         , intent(in)    :: num_child_cells_x_parent_cell
  real(rp)                            , intent(inout) :: children_patch_mass_matrix(:,:)
  real(rp)                            , intent(inout) :: coarse_mass_matrix(:,:)
  
  integer(ip),        allocatable :: subcell_to_cell_node_identifier(:)
  integer(ip)                     :: subcell_id, ishape, jshape
  integer(ip)                     :: row_id, col_id
  real(rp)                        :: mass_matrix_value
  
  assert( this%field_type == field_type_scalar )
  
  ! Allocate subcell_to_cell_node_identifier (identifier vector to assemble the children mass matrix)
  !call memalloc(cell_quadrature%num_quadrature_points,subcell_to_cell_node_identifier,__FILE__,__LINE__)  
  call memalloc(this%get_num_nodes(),subcell_to_cell_node_identifier,__FILE__,__LINE__)  

  ! Coarse mass matrix for scalar fields
  call this%compute_coarse_mass_matrix_for_scalar_fields(cell_quadrature, cell_interpolation, coarse_mass_matrix)

  ! Compute the children (patch) mass matrix
  do subcell_id = 1, num_child_cells_x_parent_cell
     call this%fill_subcell_to_cell_node_identifier(subcell_id, subcell_to_cell_node_identifier)
     do ishape=1, cell_interpolation%num_shape_functions
        do jshape=1, cell_interpolation%num_shape_functions
           row_id = subcell_to_cell_node_identifier(ishape)
           col_id = subcell_to_cell_node_identifier(jshape)
           mass_matrix_value = coarse_mass_matrix(ishape,jshape)
           children_patch_mass_matrix(row_id,col_id) = children_patch_mass_matrix(row_id,col_id) + mass_matrix_value
        end do
     end do
  end do
  call memfree(subcell_to_cell_node_identifier,__FILE__,__LINE__)  
end subroutine hex_lagrangian_compute_children_mass_matrix_for_scalar_fields

!==================================================================================================
subroutine hex_lagrangian_compute_coarse_mass_matrix_for_scalar_fields(this, cell_quadrature, cell_interpolation, coarse_mass_matrix)
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                  , intent(in)    :: cell_quadrature
  type(interpolation_t)               , intent(in)    :: cell_interpolation  
  real(rp)                         , intent(inout)    :: coarse_mass_matrix(:,:)
  
  real(rp),           allocatable  :: shape_function_values(:,:)
  real(rp),           allocatable  :: weights(:)
  
  integer(ip)                      :: qpoint, ishape, jshape
  real(rp)                         :: factor, v_shape_trial, v_shape_test

  assert( this%field_type == field_type_scalar )
  call memalloc(this%num_shape_functions,cell_quadrature%num_quadrature_points,shape_function_values,__FILE__,__LINE__)
  call memalloc(cell_quadrature%num_quadrature_points,weights,__FILE__,__LINE__)  

  ! Integration of coarse mass matrix
  ! there is not det(jacobian) in the weight due to the use of regular hexahedra (cubes) whose
  ! determinant of the jacobian = 1.0
  call cell_quadrature%get_weights(weights)
  call this%get_values(cell_interpolation,shape_function_values)
  do qpoint = 1, cell_quadrature%num_quadrature_points
     factor = weights(qpoint)
     do ishape=1, cell_interpolation%num_shape_functions
        v_shape_test = shape_function_values(ishape,qpoint)
        do jshape=1, cell_interpolation%num_shape_functions
           v_shape_trial = shape_function_values(jshape,qpoint)
              coarse_mass_matrix(ishape, jshape) = coarse_mass_matrix(ishape, jshape) + v_shape_test * v_shape_trial * factor
        end do
     end do
  end do
  call memfree(shape_function_values,__FILE__,__LINE__)
  call memfree(weights,__FILE__,__LINE__)
end subroutine hex_lagrangian_compute_coarse_mass_matrix_for_scalar_fields

!==================================================================================================
subroutine hex_lagrangian_fill_subcell_to_cell_node_identifier(this, subcell_id, subcell_to_cell_node_identifier)
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: subcell_id
  integer(ip)                         , intent(inout) :: subcell_to_cell_node_identifier(:)
  
  type(node_array_t)    ::  node_array
  type(node_iterator_t) ::  node_iterator_on_subcell
  integer(ip)           ::  num_refinements, cell_node_identifier, subcell_node_identifier
  
  assert ( size(subcell_to_cell_node_identifier) == this%get_num_nodes_on_subcell(subcell_id) )
          
  !node_iterator_on_subcell = this%node_array%create_node_iterator( this%polytope%get_n_face(this%polytope%num_n_faces), &
  !                                                                 subcell_id-1, own_boundary = .true. )     
  
  num_refinements = 1
  call node_array%create( this%polytope, ( num_refinements + 1 ) * this%order_vector )
  
  node_iterator_on_subcell = node_array%create_node_iterator( this%polytope%get_n_face(this%polytope%num_n_faces), &
                                                                subcell_id-1, own_boundary = .true. )  
  
  subcell_node_identifier = 1 
  call node_iterator_on_subcell%init()
  do while ( .not. node_iterator_on_subcell%has_finished() )
    ! We need to call %current_ijk() because it internally updates the %coordinate member
    ! variable, and it is currently the only TBP that does such an update (DIRTY)
    cell_node_identifier =  node_iterator_on_subcell%current_ijk()
    subcell_to_cell_node_identifier(subcell_node_identifier) = cell_node_identifier+1
    subcell_node_identifier = subcell_node_identifier + 1 
    call node_iterator_on_subcell%next()
  end do
  call node_array%free()
end subroutine hex_lagrangian_fill_subcell_to_cell_node_identifier

!==================================================================================================
function hex_lagrangian_get_num_nodes_on_subcell(this, subcell_id) result(num_nodes_on_subcell)
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in) :: this
  integer(ip)                            , intent(in) :: subcell_id
  integer(ip) :: num_nodes_on_subcell, num_refinements
  integer(ip) :: node_identifier, num_child_cells_x_parent_cell
  type(node_array_t)    :: node_array
  type(node_iterator_t) :: node_iterator_on_subcell

#ifdef DEBUG  
  num_child_cells_x_parent_cell = this%get_num_subcells(num_refinements=1)
  assert ( subcell_id >= 1 .and. subcell_id <= num_child_cells_x_parent_cell)
#endif  

  num_refinements = 1
  call node_array%create( this%polytope, ( num_refinements + 1 ) * this%order_vector )
  
  node_iterator_on_subcell = node_array%create_node_iterator( this%polytope%get_n_face(this%polytope%num_n_faces), &
                                                                subcell_id-1, own_boundary = .true. )

  num_nodes_on_subcell = 0
  call node_iterator_on_subcell%init()
  do while ( .not. node_iterator_on_subcell%has_finished() )
     ! We need to call %current_ijk() because it internally updates the %coordinate member
     ! variable, and it is currently the only TBP that does such an update (DIRTY)
     node_identifier =  node_iterator_on_subcell%current_ijk() 
     call node_iterator_on_subcell%next()
     num_nodes_on_subcell = num_nodes_on_subcell + 1
  end do
  call node_array%free()
end function hex_lagrangian_get_num_nodes_on_subcell

!==================================================================================================
subroutine hex_lagrangian_free_projection_operator(this)
  implicit none
  class(hex_lagrangian_reference_fe_t) , intent(inout)    ::  this  
  if ( allocated(this%coarsening_projection_operator) ) &
       call memfree ( this%coarsening_projection_operator, __FILE__, __LINE__ ) 
end subroutine hex_lagrangian_free_projection_operator

!**************************************************************************************************
! Support functions
!**************************************************************************************************

! Subroutine to deal with high order parametrizations of the boundary
! Only implemented in 2D
!==================================================================================================
subroutine blend_2D(r,s,x1,x2,x3,x4,x5,x6,x7,x8,x)
  implicit none
  real(rp), intent(in)  :: r,s
  type(point_t), intent(in)  :: x1,x2,x3,x4,x5,x6,x7,x8
  type(point_t), intent(out) :: x

  !     3---6---------4
  !     |   .         |
  !     |   .         |
  !     |   .         |
  !     7...x........ 8
  !     |   .         |
  !     1---5---------2

  x =   ( - 0.25_rp * (1-r) * (1-s)) *x1 &
       & + ( - 0.25_rp * (1+r) * (1-s)) *x2 &
       & + ( - 0.25_rp * (1-r) * (1+s)) *x3 &
       & + ( - 0.25_rp * (1+r) * (1+s)) *x4 &
       & + ( 0.5_rp * (1-s)) * x5 &
       & + ( 0.5_rp * (1+s)) * x6 &
       & + ( 0.5_rp * (1-r)) * x7 &
       & + ( 0.5_rp * (1+r)) * x8

end subroutine blend_2D
