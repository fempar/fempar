! Copyright (C) 2014 Santiago Badia, Alberto F. Martín and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine tet_nedelec_reference_fe_free ( this )
  implicit none 
  class(tet_nedelec_reference_fe_t), intent(inout) :: this
  integer(ip) :: i

  ! Free member variables of nedelec_reference_fe_t
  if ( allocated(this%change_basis_matrix) ) &
       call memfree ( this%change_basis_matrix, __FILE__, __LINE__ )     

  if ( allocated(this%basis_Sk_indices) ) &
       call memfree ( this%basis_Sk_indices, __FILE__, __LINE__ )  

  this%basis_changed  = .false. 
  do i=1, size(this%node_array_vector)
     call this%node_array_vector(i)%free()
  end do

  ! Free member variables of lagrangian_reference_fe_t
  ! (and those of its ancestors)
  call lagrangian_reference_fe_free ( this )  
end subroutine tet_nedelec_reference_fe_free

!**************************************************************************************************
! Deferred TBP implementors from reference_fe_t
!**************************************************************************************************

!==================================================================================================
function tet_nedelec_reference_fe_check_compatibility_of_n_faces                   &
     &                      (target_reference_fe,source_reference_fe, source_n_face_id,target_n_face_id)
  implicit none
  class(tet_nedelec_reference_fe_t), intent(in)  :: target_reference_fe
  class(reference_fe_t)               , intent(in)  :: source_reference_fe
  integer(ip)                         , intent(in)  :: source_n_face_id ! Local n-face ID
  integer(ip)                         , intent(in)  :: target_n_face_id ! Local n-face ID
  logical :: tet_nedelec_reference_fe_check_compatibility_of_n_faces 
  integer(ip) :: idime

  select type(source_reference_fe)
     class is(tet_nedelec_reference_fe_t)
        ! Get number nodes per dimension
     assert (target_reference_fe%num_dims == source_reference_fe%num_dims)
     do idime = 1, target_reference_fe%num_dims
        assert (target_reference_fe%order_vector(idime) == source_reference_fe%order_vector(idime))
     end do
     assert (target_reference_fe%get_n_face_dim(target_n_face_id) == source_reference_fe%get_n_face_dim(source_n_face_id))
     assert (target_reference_fe%get_n_face_dim(target_n_face_id) < 3)
     assert (target_reference_fe%num_field_components == source_reference_fe%num_field_components)
     assert (target_reference_fe%get_num_own_dofs_n_face(target_n_face_id) == source_reference_fe%get_num_own_dofs_n_face(source_n_face_id))
     tet_nedelec_reference_fe_check_compatibility_of_n_faces = .true.
     class default
     tet_nedelec_reference_fe_check_compatibility_of_n_faces = .false.
  end select

end function tet_nedelec_reference_fe_check_compatibility_of_n_faces

!=================================================================================================
function tet_nedelec_reference_fe_get_characteristic_length ( this )
  implicit none 
  class(tet_nedelec_reference_fe_t), intent(in) :: this 
  real(rp)  :: tet_nedelec_reference_fe_get_characteristic_length 
  tet_nedelec_reference_fe_get_characteristic_length =   &
       &   real(get_factorial(this%num_dims),rp)**(-1.0_rp/real(this%num_dims,rp))
end function tet_nedelec_reference_fe_get_characteristic_length

!==================================================================================================
subroutine tet_nedelec_reference_fe_generate_own_dofs_cell_permutations (this)
  implicit none
  class(tet_nedelec_reference_fe_t), intent(inout) :: this
end subroutine tet_nedelec_reference_fe_generate_own_dofs_cell_permutations

!==================================================================================================
subroutine tet_nedelec_reference_fe_fill_qpoints_permutations (this, quadrature, qpoints_perm)
  implicit none
  class(tet_nedelec_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                  , intent(in)    :: quadrature
  type(allocatable_array_ip2_t)       , intent(inout) :: qpoints_perm
  integer(ip)    :: ndime, n_q_points, i

  ndime      = quadrature%get_num_dims()
  n_q_points = quadrature%get_num_quadrature_points()


  call qpoints_perm%create(n_q_points, &    !> Number of quadrature points
       &                ndime*2**ndime)  !> Number of possible permutations x possible rotations
  forall (i = 1:qpoints_perm%nd1) qpoints_perm%a(i,:) = i

end subroutine tet_nedelec_reference_fe_fill_qpoints_permutations

!==================================================================================================
subroutine tet_nedelec_reference_fe_fill (this)
  implicit none
  class(tet_nedelec_reference_fe_t), intent(inout) :: this
  integer(ip) :: c, i, j, dimension, num_interior_nodes, num_interior_nodes_scalar
  integer(ip) :: column, inode, idime, inode_scalar, num_columns

  ! Here we put a k-1,k-1,k-1 order_vector to fill the node array of [P_{k-1,k-1,k-1}]**d
  this%order_vector = this%order-1
  call this%fill_vector()

  ! Allocate and fill Sk prebase polynomials indices  
  if ( allocated(this%basis_Sk_indices) ) call memfree(this%basis_Sk_indices, __FILE__, __LINE__ )  
  call this%create_and_fill_basis_Sk_indices()

  ! Now we assign an order vector equal to the order of the element for quadratures set up 
  this%order_vector = this%order
end subroutine tet_nedelec_reference_fe_fill
!**************************************************************************************************
! Deferred TBP implementors from nedelec_reference_fe_t
!**************************************************************************************************

subroutine tet_nedelec_reference_fe_fill_quadrature( this, quadrature )
  !-----------------------------------------------------------------------
  ! 
  !     This routine sets up the integration constants of open rules for
  !     triangles and tetrahedra mapping hexahedra quadratures
  !
  !-----------------------------------------------------------------------
  implicit none
  class(tet_nedelec_reference_fe_t)       , intent(in)     :: this
  type(quadrature_t)                      , intent(inout)  :: quadrature
  type(hex_nedelec_reference_fe_t)                         :: hex_nedelec_rfe


  if (get_quadratures_from_hex(quadrature)) then
     ! Fill quadrature corresponding to a hex element 
     call hex_nedelec_rfe%fill_quadrature ( quadrature ) 

     ! Transform quadrature to the tet element 
     if (quadrature%num_dims==1) then
        ! x' = (x+1)/2
        quadrature%coordinates(1,:) = (quadrature%coordinates(1,:)+1.0_rp) / 2.0_rp        
        ! w' = w/2
        quadrature%weight = quadrature%weight / 2.0_rp
     elseif (quadrature%num_dims==2) then
        ! x' = (x+1)/2
        quadrature%coordinates(1,:) = (quadrature%coordinates(1,:)+1.0_rp) / 2.0_rp
        ! y' = (1-x')(y+1)/2
        quadrature%coordinates(2,:) = (1.0_rp - quadrature%coordinates(1,:)) * &
             ((1.0_rp + quadrature%coordinates(2,:)) / 2.0_rp)
        ! w' = (1-x')/4
        quadrature%weight = (1.0_rp - quadrature%coordinates(1,:)) /4.0_rp * &
             quadrature%weight

     elseif (quadrature%num_dims==3) then
        ! x' = (x+1)/2
        quadrature%coordinates(1,:) = (quadrature%coordinates(1,:)+1.0_rp) / 2.0_rp
        ! y' = (1-x')(y+1)/2
        quadrature%coordinates(2,:) = (1.0_rp - quadrature%coordinates(1,:)) * &
             ((1.0_rp + quadrature%coordinates(2,:)) / 2.0_rp)
        ! z' = (1-x'-y')(z+1)/2
        quadrature%coordinates(3,:) = (1.0_rp - quadrature%coordinates(1,:)    &
             - quadrature%coordinates(2,:)) * &
             ((1.0_rp + quadrature%coordinates(3,:)) / 2.0_rp)
        ! w' = ((1-x')^2+y'(x'-1))/8
        quadrature%weight = ((1.0_rp - quadrature%coordinates(1,:))**2.0_rp + &
             quadrature%coordinates(2,:)*(quadrature%coordinates(1,:) - 1.0_rp)) / 8.0_rp * &
             quadrature%weight
     end if
  else 
     call tet_nedelec_reference_fe_fill_symmetric_quadrature ( this, quadrature ) 
  end if

end subroutine tet_nedelec_reference_fe_fill_quadrature

! =================================================================================================
subroutine tet_nedelec_reference_fe_create_and_fill_basis_Sk_indices( this ) 
  ! -----------------------------------------------------------------------------------------------
  !
  ! Prebasis functions are written with analytical expressions, see [M.Olm, S.Badia, A.F.Martin: 
  ! Simulation of High temperature superconductors and experimental validation, sec.3 ].
  !
  ! ------------------------------------------------------------------------------------------------
  class(tet_nedelec_reference_fe_t),  intent(inout) :: this 

  integer(ip)            :: k, ijk, basis_dim, coord(0:SPACE_DIM-1) 
  type(node_array_t)     :: k_order_node_array
  integer(ip)            :: k_order_vector(1:SPACE_DIM)
  integer(ip)            :: c, offcomponent
  integer(ip)            :: i, j

  k               = this%order
  k_order_vector  = this%order   
  call k_order_node_array%create( this%polytope, k_order_vector ) 

  ! Basis Sk indices [ dim(Sk), num_poynomials(k)*D ]  
  basis_dim = this%order*(this%order+2)**(this%num_dims-2) 
  call memalloc(basis_dim, k_order_node_array%num_nodes*this%num_dims, &
       this%basis_Sk_indices, __FILE__, __LINE__ )
  this%basis_Sk_indices = 0.0_rp

  coord = 0  
  c     = 1 
  if (this%num_dims == 2) then 

     do i = 1, k
        coord(0) = i-1
        coord(1) = k - i + 1
        ijk = k_order_node_array%ijk_to_index(ijk_to_index( coord, k_order_vector, this%num_dims )) 
        this%basis_Sk_indices( c, ijk ) = -1.0_rp  

        coord(0) = coord(0) + 1
        coord(1) = coord(1) - 1
        ijk = k_order_node_array%ijk_to_index(ijk_to_index( coord, k_order_vector, this%num_dims )) 
        this%basis_Sk_indices( c, k_order_node_array%num_nodes + ijk ) = 1.0_rp  
        c = c + 1
     end do

  elseif (this%num_dims == 3) then 

     do j = 1, k
        do i = 1, k+1-j 

           ! Fill first subset of functions 
           coord(0) = i - 1
           coord(1) = k - i - j + 2
           coord(2) = j - 1
           ijk = k_order_node_array%ijk_to_index(ijk_to_index( coord, k_order_vector, this%num_dims )) 
           this%basis_Sk_indices( c, ijk ) = -1.0_rp 

           coord(0) = coord(0) + 1
           coord(1) = coord(1) - 1
           ijk = k_order_node_array%ijk_to_index(ijk_to_index( coord, k_order_vector, this%num_dims )) 
           this%basis_Sk_indices( c, k_order_node_array%num_nodes + ijk ) = 1.0_rp 

           c = c + 1
           ! Fill second subset of functions 
           coord(0) = k - i - j + 1
           coord(1) = j - 1
           coord(2) = i
           ijk = k_order_node_array%ijk_to_index(ijk_to_index( coord, k_order_vector, this%num_dims )) 
           this%basis_Sk_indices( c, ijk ) = -1.0_rp 

           coord(0) = coord(0) + 1
           coord(2) = coord(2) - 1
           ijk = k_order_node_array%ijk_to_index(ijk_to_index( coord, k_order_vector, this%num_dims )) 
           this%basis_Sk_indices( c, 2*k_order_node_array%num_nodes + ijk ) = 1.0_rp 

           c = c + 1
        end do

        ! Fill third subset of functions  
        coord(0) = 0
        coord(1) = j - 1
        coord(2) = k - j + 1
        ijk = k_order_node_array%ijk_to_index(ijk_to_index( coord, k_order_vector, this%num_dims )) 
        this%basis_Sk_indices( c, k_order_node_array%num_nodes + ijk ) = -1.0_rp  

        coord(1) = coord(1) + 1
        coord(2) = coord(2) - 1
        ijk = k_order_node_array%ijk_to_index(ijk_to_index( coord, k_order_vector, this%num_dims )) 
        this%basis_Sk_indices( c, 2*k_order_node_array%num_nodes + ijk ) = 1.0_rp  
        c = c + 1
     end do

  end if
  call k_order_node_array%free() 

end subroutine tet_nedelec_reference_fe_create_and_fill_basis_Sk_indices

!==================================================================================================
subroutine tet_nedelec_reference_fe_fill_interpolation( this, quadrature, interpolation, order_vector )
  implicit none
  class(tet_nedelec_reference_fe_t)       , intent(in)         :: this
  type(quadrature_t)                      , intent(in)         :: quadrature
  type(interpolation_t)                   , intent(inout)      :: interpolation    
  integer(ip)                  , optional , intent(in)         :: order_vector(SPACE_DIM)

  type(interpolation_t) :: interpolation_pre_basis

  if ( .not. this%basis_changed ) then
     call this%fill_interpolation_pre_basis ( quadrature, interpolation, order_vector )
  else
     call interpolation_pre_basis%clone(interpolation)
     call this%fill_interpolation_pre_basis ( quadrature, interpolation_pre_basis, order_vector ) 
     call this%apply_change_basis_matrix_to_interpolation ( interpolation_pre_basis, interpolation )
     call interpolation_pre_basis%free()
  end if
end subroutine tet_nedelec_reference_fe_fill_interpolation

!==================================================================================================
subroutine tet_nedelec_reference_fe_fill_interpolation_pre_basis ( this, quadrature, interpolation, order_vector ) 
  implicit none 
  class(tet_nedelec_reference_fe_t), intent(in)    :: this
  type(quadrature_t)               , intent(in)    :: quadrature
  type(interpolation_t)            , intent(inout) :: interpolation
  integer(ip) , optional           , intent(in)    :: order_vector(SPACE_DIM)

  type(truncated_tensor_product_polynomial_space_t)  :: tet_polynomial_prebase_1
  type(truncated_tensor_product_polynomial_space_t)  :: tet_polynomial_prebase_2
  type(polynomial_basis_t)  :: monomial_1D_basis(SPACE_DIM)
  type(monomial_t)                      :: monomial_1D

  real(rp), allocatable :: values(:)
  real(rp), allocatable :: gradients(:,:)

  integer(ip)              :: c, idime, jdime, q_point, ipoly, Sk_basis_dim 
  integer(ip)              :: num_polynomials_prebase_1, N_k
  integer(ip)              :: ivalu, info, offcomponent 

  interpolation%shape_functions   = 0.0_rp
  interpolation%shape_derivatives = 0.0_rp

  ! The Nedelec tet prebasis ND_k is built as a direct sum of two prebasis, so they are built and added:  
  ! prebasis_1: [P_{k-1}]^d
  ! prebasis_2: S_k = {p in [homog(P_k)]^d | p·x = 0}
  ! ------------------------------------------
  ! ND_k = [P_{k-1}]^d + S_k
  ! this%node_array_vector(idime)  order=k-1 --> prebasis_1
  ! k_order_node_array             order=k   --> prebasis_2 

  ! First subspace, create polynomial prebase of order (k-1) 
  do idime=1,interpolation%num_dims
     call monomial_1D%generate_basis(this%order_vector(idime)-1, monomial_1D_basis(idime) )
  end do

  call tet_polynomial_prebase_1%create(interpolation%num_dims,monomial_1D_basis)
  call tet_polynomial_prebase_1%fill( quadrature%get_coordinates() )

  num_polynomials_prebase_1 = tet_polynomial_prebase_1%get_num_polynomials()
  call memalloc(num_polynomials_prebase_1,values,__FILE__,__LINE__)
  call memalloc(SPACE_DIM,num_polynomials_prebase_1,gradients,__FILE__,__LINE__)

  ! Fill first set of pre-basis functions (replicated prebase_1 in directions)
  do idime=1, interpolation%num_dims 
     do q_point=1, quadrature%get_num_quadrature_points()
        c=(idime-1)*num_polynomials_prebase_1
        call tet_polynomial_prebase_1%evaluate(q_point, values, gradients)
        do ipoly=1,num_polynomials_prebase_1
           c=c+1
           interpolation%shape_functions(idime,c,q_point) = values(ipoly)
           do jdime=1, interpolation%num_dims
              interpolation%shape_derivatives(idime,jdime,c,q_point) = gradients(jdime,ipoly)
           end do
        end do
     end do
  end do

  ! Free auxiliary memory
  if(allocated(values))    call memfree(values,__FILE__,__LINE__)
  if(allocated(gradients)) call memfree(gradients,__FILE__,__LINE__)

  do idime=1,interpolation%num_dims
     call monomial_1D_basis(idime)%free()
  end do
  call monomial_1D%free()
  call tet_polynomial_prebase_1%free()

  ! Second subspace, create polynomial prebase of order k 
  do idime=1,interpolation%num_dims
     call monomial_1D%generate_basis(this%order_vector(idime), monomial_1D_basis(idime) )
  end do

  call tet_polynomial_prebase_2%create(interpolation%num_dims,monomial_1D_basis)
  call tet_polynomial_prebase_2%fill( quadrature%get_coordinates() )

  call memalloc(tet_polynomial_prebase_2%get_num_polynomials(),values,__FILE__,__LINE__)
  call memalloc(SPACE_DIM,tet_polynomial_prebase_2%get_num_polynomials(),gradients,__FILE__,__LINE__)

  ! Fill second set of prebasis functions with order k prebase and Sk( homogeneous polynomials basis indices )  
  N_k = tet_polynomial_prebase_2%get_num_polynomials()
  Sk_basis_dim = this%order * (this%order+2)**(this%num_dims-2)
  c   = interpolation%num_dims*num_polynomials_prebase_1 
  do q_point=1, quadrature%get_num_quadrature_points()
     call tet_polynomial_prebase_2%evaluate(q_point, values, gradients)
     do ipoly=1, Sk_basis_dim 
        do idime=1, interpolation%num_dims	
           offcomponent = (idime-1)*tet_polynomial_prebase_2%get_num_polynomials()
           do ivalu=1, tet_polynomial_prebase_2%get_num_polynomials()
              interpolation%shape_functions(idime,c+ipoly,q_point) =  &	
                   interpolation%shape_functions(idime,c+ipoly,q_point) + this%basis_Sk_indices(ipoly, offcomponent + ivalu)*values(ivalu)	
              do jdime=1, interpolation%num_dims
                 interpolation%shape_derivatives(idime,jdime,c+ipoly,q_point) = & 
                      interpolation%shape_derivatives(idime,jdime,c+ipoly,q_point) + this%basis_Sk_indices(ipoly, offcomponent + ivalu)*gradients(jdime,ivalu)
              end do
           end do
        end do
     end do
  end do

  ! Free auxiliary memory
  if(allocated(values))    call memfree(values,__FILE__,__LINE__)
  if(allocated(gradients)) call memfree(gradients,__FILE__,__LINE__)

  do idime=1,interpolation%num_dims
     call monomial_1D_basis(idime)%free()
  end do
  call monomial_1D%free()
  call tet_polynomial_prebase_2%free()

end subroutine tet_nedelec_reference_fe_fill_interpolation_pre_basis

!==================================================================================================
subroutine tet_nedelec_reference_fe_fill_interpolation_restricted_to_edget( this, local_edge_id, local_quadrature, edget_interpolation )
  implicit none
  class(tet_nedelec_reference_fe_t)       , intent(in)    :: this
  integer(ip)                             , intent(in)    :: local_edge_id
  type(quadrature_t)                      , intent(in)    :: local_quadrature
  type(interpolation_t)                   , intent(inout) :: edget_interpolation
  type(quadrature_t) :: aux_quadrature
  integer(ip) :: c, idime, n_face_index, qpoin

  ! Add offset to have same numbering as in polytope
  n_face_index = local_edge_id+this%get_first_n_face_id_of_dim(1)-1

  ! Create a d-dimensional quadrature as follows: 
  ! Non-orthogonal directions are taken into account with the (1-d) factor for the free and anchor node dimension 
  call aux_quadrature%create( this%num_dims, local_quadrature%num_quadrature_points )

  do idime = 0,this%num_dims-1
     if ( (this%polytope%n_face_dir_is_fixed( n_face_index, idime )==1) .and. (this%polytope%n_face_dir_coordinate( n_face_index, idime )==0) ) then
        aux_quadrature%coordinates(idime+1,:) = local_quadrature%coordinates(1,:)	 
     elseif  ( (this%polytope%n_face_dir_is_fixed( n_face_index, idime )==0) .and. (this%polytope%n_face_dir_coordinate( n_face_index, idime )==1) ) then 
        do qpoin = 1, local_quadrature%num_quadrature_points
           aux_quadrature%coordinates(idime+1, qpoin) = 1.0_rp - local_quadrature%coordinates(1,qpoin)
        end do
     else 
        aux_quadrature%coordinates(idime+1,:) = 0.0_rp
     end if
  end do

  call this%fill_interpolation( aux_quadrature, edget_interpolation ) 
  call aux_quadrature%free()

end subroutine tet_nedelec_reference_fe_fill_interpolation_restricted_to_edget

!==================================================================================================

subroutine tet_nedelec_reference_fe_fill_interp_restricted_to_facet( this, local_quadrature, & 
     & facet_lid, subfacet_lid, facet_interpolation )
  implicit none
  class(tet_nedelec_reference_fe_t)       , intent(in)    :: this
  type(quadrature_t)                      , intent(in)    :: local_quadrature
  integer(ip)                             , intent(in)    :: facet_lid
  integer(ip)                             , intent(in)    :: subfacet_lid
  type(interpolation_t)                   , intent(inout) :: facet_interpolation
  type(quadrature_t) :: aux_quadrature
  integer(ip) :: idime,iface,n_face_index, qpoin,p_local_coordinate

  ! Exit if attempts to fill the interpolation of a subface
  if ( subfacet_lid >= 0 ) return

  ! Add offset to have same numbering as in polytope
  n_face_index = facet_lid+this%get_first_facet_id()-1

  ! Create a d-dimensional quadrature as follows
  call aux_quadrature%create( this%num_dims, local_quadrature%num_quadrature_points )
  do qpoin = 1,facet_interpolation%num_quadrature_points
     ! Transform face local coordinates to element global coordinates
     if (facet_lid <= facet_interpolation%num_dims ) then 
        ! Orthogonal face in the reference element
        p_local_coordinate = 1
        do idime = 1, facet_interpolation%num_dims
           if (idime == facet_interpolation%num_dims + 1 - facet_lid ) then
              aux_quadrature%coordinates(idime,qpoin) = 0.0_rp
           else
              aux_quadrature%coordinates(idime,qpoin) = local_quadrature%coordinates(p_local_coordinate, qpoin)
              p_local_coordinate = p_local_coordinate + 1
           end if
        end do
     else 
        ! Non-orthogonal face in the reference element
        aux_quadrature%coordinates(1,qpoin) = 1 - sum(local_quadrature%coordinates(:,qpoin))
        aux_quadrature%coordinates(2:facet_interpolation%num_dims, qpoin) = & 
             & local_quadrature%coordinates(1:facet_interpolation%num_dims-1,qpoin)
     end if
  end do

  call this%fill_interpolation( aux_quadrature, facet_interpolation ) 
  call aux_quadrature%free()
end subroutine tet_nedelec_reference_fe_fill_interp_restricted_to_facet

!=================================================================================================
function tet_nedelec_reference_fe_compute_num_quadrature_points( this, degree, dimension )
  implicit none
  class(tet_nedelec_reference_fe_t), intent(in)    :: this
  integer(ip)                             , intent(in)    :: degree
  integer(ip)                             , intent(in)    :: dimension
  integer(ip) :: tet_nedelec_reference_fe_compute_num_quadrature_points

  if( dimension == 1 ) then
     tet_nedelec_reference_fe_compute_num_quadrature_points = int(ceiling(real(degree,rp)/2.0_rp),ip)+1
  elseif( dimension == 2 ) then
     !*************************************************************************
     ! Using efficent symmetrical gaussian quadrature rules (when available). 
     if( degree <= 2 ) then
        tet_nedelec_reference_fe_compute_num_quadrature_points = 3
     elseif( degree <= 4 ) then
        tet_nedelec_reference_fe_compute_num_quadrature_points = 6
     elseif( degree <= 6 ) then
        tet_nedelec_reference_fe_compute_num_quadrature_points = 13
     elseif( degree <= 8 ) then
        tet_nedelec_reference_fe_compute_num_quadrature_points = 19
     elseif( degree <= 10 ) then
        tet_nedelec_reference_fe_compute_num_quadrature_points = 28
     else ! Quadratures based on brick quadratures transformation
        tet_nedelec_reference_fe_compute_num_quadrature_points = int((ceiling(real(degree,rp)/2.0_rp) + 1.0_rp )**2.0_rp,ip)
     end if
  elseif( dimension == 3 ) then
     !*************************************************************************
     ! Using efficent symmetrical gaussian quadrature rules (when available). 
     if( degree <= 2 ) then
        tet_nedelec_reference_fe_compute_num_quadrature_points = 4
     elseif( degree <= 4) then
        tet_nedelec_reference_fe_compute_num_quadrature_points = 11
     else ! Quadratures based on brick quadratures transformation
        tet_nedelec_reference_fe_compute_num_quadrature_points = int((ceiling(real(degree,rp)/2.0_rp) + 2.0_rp )**3.0_rp,ip)
     end if
  end if

end function tet_nedelec_reference_fe_compute_num_quadrature_points

!==================================================================================================
subroutine tet_nedelec_reference_fe_fill_symmetric_quadrature ( this, quadrature ) 
  !-----------------------------------------------------------------------
  ! 
  !     This routine sets up the integration constants of open rules for
  !     triangles and tetrahedra
  ! 
  !             NDIME = 2             NDIME = 3
  ! 
  !          NGAUS  EXACT POL.     NGAUS  EXACT POL. 
  !          -----  ----------     -----  ----------
  !            1       p1            1       p1
  !            3       p2            4       p2
  !            4       p3            5       p3
  !            6       p4           11       p4
  !            7       p5           14       p5
  !           13       p7
  !           19       p9
  !           28       p11
  !
  !-----------------------------------------------------------------------
  implicit none
  class(tet_nedelec_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                  , intent(inout) :: quadrature
  real(rp)    :: a,b,c,d,e,f,g,h,p,q,r,s,t,u,v,w,x,y,z
  real(rp)    :: w1,w2,w3,w4,w5,w6,w7,w8
  real(rp)    :: ex1,et1,ez1,ex2,et2,ez2
  integer(ip) :: ndime,ngaus

  ndime = quadrature%num_dims
  ngaus = quadrature%num_quadrature_points

  ! Line integral (the same as for brick elements)
  if(ndime==1) then
     if(ngaus==1) then
        quadrature%coordinates(1,1)=0.5_rp
        quadrature%weight(  1)=1.0_rp
     else if(ngaus==2) then
        quadrature%coordinates(1,1)= 0.211324865405187_rp
        quadrature%coordinates(1,2)= 0.788675134594813_rp
        quadrature%weight(  1)= 0.5_rp
        quadrature%weight(  2)= 0.5_rp
     else if(ngaus==3) then
        quadrature%coordinates(1,1)= 0.112701665379258_rp
        quadrature%coordinates(1,2)= 0.5_rp
        quadrature%coordinates(1,3)= 0.887298334620742_rp
        quadrature%weight(  1)= 0.277777777777778_rp
        quadrature%weight(  2)= 0.444444444444444_rp
        quadrature%weight(  3)= 0.277777777777778_rp
     else
        write(*,*) __FILE__,__LINE__,'ERROR:: Quadrature not defined',ndime,ngaus
        check(.false.)
     end if

     ! Area integral (triangles)
  else if(ndime==2) then
     if(ngaus==1) then
        quadrature%coordinates(1,1)= 1.0_rp/3.0_rp
        quadrature%coordinates(2,1)= 1.0_rp/3.0_rp
        quadrature%weight(  1)= 1.0_rp/2.0_rp
     else if(ngaus==3) then
        quadrature%coordinates(1,2)= 2.0_rp/3.0_rp
        quadrature%coordinates(2,2)= 1.0_rp/6.0_rp
        quadrature%coordinates(1,3)= 1.0_rp/6.0_rp
        quadrature%coordinates(2,3)= 2.0_rp/3.0_rp
        quadrature%coordinates(1,1)= 1.0_rp/6.0_rp
        quadrature%coordinates(2,1)= 1.0_rp/6.0_rp
        quadrature%weight(  2)= 1.0_rp/6.0_rp
        quadrature%weight(  3)= 1.0_rp/6.0_rp
        quadrature%weight(  1)= 1.0_rp/6.0_rp
     else if(ngaus==4) then
        quadrature%coordinates(1,1)= 1.0_rp/3.0_rp
        quadrature%coordinates(2,1)= 1.0_rp/3.0_rp
        quadrature%coordinates(1,2)= 1.0_rp/5.0_rp
        quadrature%coordinates(2,2)= 1.0_rp/5.0_rp
        quadrature%coordinates(1,3)= 3.0_rp/5.0_rp
        quadrature%coordinates(2,3)= 1.0_rp/5.0_rp
        quadrature%coordinates(1,4)= 1.0_rp/5.0_rp
        quadrature%coordinates(2,4)= 3.0_rp/5.0_rp
        quadrature%weight(  1)=-27.0_rp/96.0_rp
        quadrature%weight(  2)= 25.0_rp/96.0_rp
        quadrature%weight(  3)= 25.0_rp/96.0_rp
        quadrature%weight(  4)= 25.0_rp/96.0_rp 
     else if(ngaus==6) then
        ex1 = 0.816847572980459_rp
        et1 = 0.091576213509771_rp
        ez1 = 0.091576213509771_rp
        ex2 = 0.108103018168070_rp
        et2 = 0.445948490915965_rp
        ez2 = 0.445948490915965_rp
        quadrature%coordinates(1,3)= ex1
        quadrature%coordinates(2,3)= et1
        quadrature%coordinates(1,1)= et1
        quadrature%coordinates(2,1)= ez1
        quadrature%coordinates(1,6)= ez1
        quadrature%coordinates(2,6)= ex1
        quadrature%coordinates(1,4)= ex2
        quadrature%coordinates(2,4)= et2
        quadrature%coordinates(1,5)= et2
        quadrature%coordinates(2,5)= ez2
        quadrature%coordinates(1,2)= ez2
        quadrature%coordinates(2,2)= ex2
        a = 0.054975870996713638_rp
        b = 0.1116907969117165_rp    
        quadrature%weight(3)  = a
        quadrature%weight(1)  = a
        quadrature%weight(6)  = a
        quadrature%weight(4)  = b
        quadrature%weight(5)  = b
        quadrature%weight(2)  = b
     else if(ngaus==7) then
        a = 1.0_rp / 3.0_rp
        b = ( 9.0_rp + 2.0_rp * sqrt ( 15.0_rp ) ) / 21.0_rp
        c = ( 6.0_rp -          sqrt ( 15.0_rp ) ) / 21.0_rp
        d = ( 9.0_rp - 2.0_rp * sqrt ( 15.0_rp ) ) / 21.0_rp
        e = ( 6.0_rp +          sqrt ( 15.0_rp ) ) / 21.0_rp
        w1 = 0.1125_rp
        w2 = ( 155.0_rp - sqrt ( 15.0_rp ) ) / 2400.0_rp
        w3 = ( 155.0_rp + sqrt ( 15.0_rp ) ) / 2400.0_rp
        quadrature%coordinates(1,1)= a
        quadrature%coordinates(2,1)= a
        quadrature%coordinates(1,2)= b
        quadrature%coordinates(2,2)= c
        quadrature%coordinates(1,3)= c
        quadrature%coordinates(2,3)= b
        quadrature%coordinates(1,4)= c
        quadrature%coordinates(2,4)= c
        quadrature%coordinates(1,5)= d
        quadrature%coordinates(2,5)= e
        quadrature%coordinates(1,6)= e
        quadrature%coordinates(2,6)= d
        quadrature%coordinates(1,7)= e
        quadrature%coordinates(2,7)= e
        quadrature%weight(  1)= w1
        quadrature%weight(  2)= w2
        quadrature%weight(  3)= w2
        quadrature%weight(  4)= w2
        quadrature%weight(  5)= w3
        quadrature%weight(  6)= w3
        quadrature%weight(  7)= w3
     else if(ngaus==13) then
        a = 0.333333333333333_rp
        b = 0.479308067841923_rp
        c = 0.869739794195568_rp
        d = 0.638444188569809_rp
        e = 0.260345966079038_rp
        f = 0.065130102902216_rp
        g = 0.312865496004875_rp
        h = 0.048690315425316_rp
        w1=-0.149570044467670_rp/2.0_rp
        w2= 0.175615257433204_rp/2.0_rp
        w3= 0.053347235608839_rp/2.0_rp
        w4= 0.077113760890257_rp/2.0_rp
        quadrature%coordinates(1, 1)= a
        quadrature%coordinates(2, 1)= a         
        quadrature%coordinates(1, 2)= e
        quadrature%coordinates(2, 2)= e
        quadrature%coordinates(1, 3)= b
        quadrature%coordinates(2, 3)= e        
        quadrature%coordinates(1, 4)= e
        quadrature%coordinates(2, 4)= b        
        quadrature%coordinates(1, 5)= f
        quadrature%coordinates(2, 5)= f        
        quadrature%coordinates(1, 6)= c
        quadrature%coordinates(2, 6)= f        
        quadrature%coordinates(1, 7)= f
        quadrature%coordinates(2, 7)= c        
        quadrature%coordinates(1, 8)= d
        quadrature%coordinates(2, 8)= g        
        quadrature%coordinates(1, 9)= d
        quadrature%coordinates(2, 9)= h        
        quadrature%coordinates(1,10)= g
        quadrature%coordinates(2,10)= d        
        quadrature%coordinates(1,11)= g
        quadrature%coordinates(2,11)= h        
        quadrature%coordinates(1,12)= h
        quadrature%coordinates(2,12)= d        
        quadrature%coordinates(1,13)= h
        quadrature%coordinates(2,13)= g
        quadrature%weight( 1) = w1
        quadrature%weight( 2) = w2
        quadrature%weight( 3) = w2
        quadrature%weight( 4) = w2
        quadrature%weight( 5) = w3
        quadrature%weight( 6) = w3
        quadrature%weight( 7) = w3
        quadrature%weight( 8) = w4
        quadrature%weight( 9) = w4
        quadrature%weight(10) = w4
        quadrature%weight(11) = w4
        quadrature%weight(12) = w4
        quadrature%weight(13) = w4
     else if(ngaus==19) then
        a = 1.0_rp / 3.0_rp
        b = 0.02063496160252593_rp
        c = 0.4896825191987370_rp
        d = 0.1258208170141290_rp
        e = 0.4370895914929355_rp
        f = 0.6235929287619356_rp
        g = 0.1882035356190322_rp
        r = 0.9105409732110941_rp
        s = 0.04472951339445297_rp
        t = 0.7411985987844980_rp
        u = 0.03683841205473626_rp
        v = 0.22196298916076573_rp

        w1 = 0.09713579628279610_rp/2.0_rp
        w2 = 0.03133470022713983_rp/2.0_rp
        w3 = 0.07782754100477543_rp/2.0_rp
        w4 = 0.07964773892720910_rp/2.0_rp
        w5 = 0.02557767565869810_rp/2.0_rp
        w6 = 0.04328353937728940_rp/2.0_rp

        quadrature%coordinates(1, 1) = a 
        quadrature%coordinates(1, 2) = b
        quadrature%coordinates(1, 3) = c 
        quadrature%coordinates(1, 4) = c 
        quadrature%coordinates(1, 5) = d 
        quadrature%coordinates(1, 6) = e
        quadrature%coordinates(1, 7) = e
        quadrature%coordinates(1, 8) = f 
        quadrature%coordinates(1, 9) = g 
        quadrature%coordinates(1,10) = g
        quadrature%coordinates(1,11) = r
        quadrature%coordinates(1,12) = s
        quadrature%coordinates(1,13) = s
        quadrature%coordinates(1,14) = t
        quadrature%coordinates(1,15) = t
        quadrature%coordinates(1,16) = u
        quadrature%coordinates(1,17) = u
        quadrature%coordinates(1,18) = v
        quadrature%coordinates(1,19) = v

        quadrature%coordinates(2, 1) = a
        quadrature%coordinates(2, 2) = c
        quadrature%coordinates(2, 3) = b
        quadrature%coordinates(2, 4) = c
        quadrature%coordinates(2, 5) = e
        quadrature%coordinates(2, 6) = d
        quadrature%coordinates(2, 7) = e
        quadrature%coordinates(2, 8) = g
        quadrature%coordinates(2, 9) = f
        quadrature%coordinates(2,10) = g
        quadrature%coordinates(2,11) = s
        quadrature%coordinates(2,12) = r
        quadrature%coordinates(2,13) = s
        quadrature%coordinates(2,14) = u
        quadrature%coordinates(2,15) = v
        quadrature%coordinates(2,16) = t
        quadrature%coordinates(2,17) = v
        quadrature%coordinates(2,18) = t
        quadrature%coordinates(2,19) = u

        quadrature%weight( 1) = w1
        quadrature%weight( 2) = w2
        quadrature%weight( 3) = w2
        quadrature%weight( 4) = w2
        quadrature%weight( 5) = w3
        quadrature%weight( 6) = w3
        quadrature%weight( 7) = w3
        quadrature%weight( 8) = w4
        quadrature%weight( 9) = w4
        quadrature%weight(10) = w4
        quadrature%weight(11) = w5
        quadrature%weight(12) = w5
        quadrature%weight(13) = w5
        quadrature%weight(14) = w6
        quadrature%weight(15) = w6
        quadrature%weight(16) = w6
        quadrature%weight(17) = w6
        quadrature%weight(18) = w6
        quadrature%weight(19) = w6
     else if(ngaus==28) then
        a = 1.0_rp / 3.0_rp
        b = 0.9480217181434233_rp
        c = 0.02598914092828833_rp
        d = 0.8114249947041546_rp
        e = 0.09428750264792270_rp
        f = 0.01072644996557060_rp
        g = 0.4946367750172147_rp
        p = 0.5853132347709715_rp
        q = 0.2073433826145142_rp
        r = 0.1221843885990187_rp
        s = 0.4389078057004907_rp
        t = 0.6779376548825902_rp
        u = 0.04484167758913055_rp
        v = 0.27722066752827925_rp
        w = 0.8588702812826364_rp
        x = 0.0_rp
        y = 0.1411297187173636_rp

        w1 = 0.08797730116222190_rp/2.0_rp
        w2 = 0.008744311553736190_rp/2.0_rp
        w3 = 0.03808157199393533_rp/2.0_rp
        w4 = 0.01885544805613125_rp/2.0_rp
        w5 = 0.07215969754474100_rp/2.0_rp
        w6 = 0.06932913870553720_rp/2.0_rp
        w7 = 0.04105631542928860_rp/2.0_rp
        w8 = 0.007362383783300573_rp/2.0_rp

        quadrature%coordinates(1, 1) = a  
        quadrature%coordinates(1, 2) = b  
        quadrature%coordinates(1, 3) = c  
        quadrature%coordinates(1, 4) = c  
        quadrature%coordinates(1, 5) = d  
        quadrature%coordinates(1, 6) = e  
        quadrature%coordinates(1, 7) = e  
        quadrature%coordinates(1, 8) = f  
        quadrature%coordinates(1, 9) = g
        quadrature%coordinates(1,10) = g
        quadrature%coordinates(1,11) = p 
        quadrature%coordinates(1,12) = q 
        quadrature%coordinates(1,13) = q
        quadrature%coordinates(1,14) = r 
        quadrature%coordinates(1,15) = s 
        quadrature%coordinates(1,16) = s 
        quadrature%coordinates(1,17) = t 
        quadrature%coordinates(1,18) = t 
        quadrature%coordinates(1,19) = u 
        quadrature%coordinates(1,20) = u 
        quadrature%coordinates(1,21) = v 
        quadrature%coordinates(1,22) = v 
        quadrature%coordinates(1,23) = w 
        quadrature%coordinates(1,24) = w 
        quadrature%coordinates(1,25) = x 
        quadrature%coordinates(1,26) = x 
        quadrature%coordinates(1,27) = y 
        quadrature%coordinates(1,28) = y

        quadrature%coordinates(2, 1) = a  
        quadrature%coordinates(2, 2) = c  
        quadrature%coordinates(2, 3) = b  
        quadrature%coordinates(2, 4) = c  
        quadrature%coordinates(2, 5) = e  
        quadrature%coordinates(2, 6) = d  
        quadrature%coordinates(2, 7) = e  
        quadrature%coordinates(2, 8) = g  
        quadrature%coordinates(2, 9) = f  
        quadrature%coordinates(2,10) = g  
        quadrature%coordinates(2,11) = q  
        quadrature%coordinates(2,12) = p  
        quadrature%coordinates(2,13) = q
        quadrature%coordinates(2,14) = s  
        quadrature%coordinates(2,15) = r  
        quadrature%coordinates(2,16) = s  
        quadrature%coordinates(2,17) = u  
        quadrature%coordinates(2,18) = v  
        quadrature%coordinates(2,19) = t  
        quadrature%coordinates(2,20) = v  
        quadrature%coordinates(2,21) = t  
        quadrature%coordinates(2,22) = u  
        quadrature%coordinates(2,23) = x  
        quadrature%coordinates(2,24) = y  
        quadrature%coordinates(2,25) = w  
        quadrature%coordinates(2,26) = y  
        quadrature%coordinates(2,27) = w  
        quadrature%coordinates(2,28) = x

        quadrature%weight( 1) = w1 
        quadrature%weight( 2) = w2
        quadrature%weight( 3) = w2 
        quadrature%weight( 4) = w2 
        quadrature%weight( 5) = w3 
        quadrature%weight( 6) = w3 
        quadrature%weight( 7) = w3 
        quadrature%weight( 8) = w4 
        quadrature%weight( 9) = w4 
        quadrature%weight(10) = w4 
        quadrature%weight(11) = w5 
        quadrature%weight(12) = w5 
        quadrature%weight(13) = w5
        quadrature%weight(14) = w6 
        quadrature%weight(15) = w6 
        quadrature%weight(16) = w6 
        quadrature%weight(17) = w7 
        quadrature%weight(18) = w7 
        quadrature%weight(19) = w7 
        quadrature%weight(20) = w7 
        quadrature%weight(21) = w7 
        quadrature%weight(22) = w7 
        quadrature%weight(23) = w8 
        quadrature%weight(24) = w8 
        quadrature%weight(25) = w8 
        quadrature%weight(26) = w8 
        quadrature%weight(27) = w8 
        quadrature%weight(28) = w8
     else
        write(*,*) __FILE__,__LINE__,'ERROR:: Quadrature not defined',ndime,ngaus
        check(.false.)
     end if

     ! Volume integral ( tetrahedra )
  else if(ndime==3) then
     if(ngaus==1) then
        quadrature%coordinates(1,1)= 1.0_rp/4.0_rp
        quadrature%coordinates(2,1)= 1.0_rp/4.0_rp
        quadrature%coordinates(3,1)= 1.0_rp/4.0_rp
        quadrature%weight(1)  = 1.0_rp/6.0_rp
     else if(ngaus==4) then
        a=0.5854101966249685_rp
        b=0.1381966011250105_rp
        quadrature%coordinates(1,1)= b
        quadrature%coordinates(2,1)= b
        quadrature%coordinates(3,1)= b
        quadrature%coordinates(1,2)= a
        quadrature%coordinates(2,2)= b
        quadrature%coordinates(3,2)= b
        quadrature%coordinates(1,3)= b
        quadrature%coordinates(2,3)= a
        quadrature%coordinates(3,3)= b
        quadrature%coordinates(1,4)= b
        quadrature%coordinates(2,4)= b
        quadrature%coordinates(3,4)= a
        quadrature%weight(  1)= 1.0_rp/24.0_rp
        quadrature%weight(  2)= 1.0_rp/24.0_rp
        quadrature%weight(  3)= 1.0_rp/24.0_rp
        quadrature%weight(  4)= 1.0_rp/24.0_rp
     else if(ngaus==5) then
        quadrature%coordinates(1,1)= 1.0_rp/4.0_rp
        quadrature%coordinates(2,1)= 1.0_rp/4.0_rp
        quadrature%coordinates(3,1)= 1.0_rp/4.0_rp
        quadrature%coordinates(1,2)= 1.0_rp/6.0_rp
        quadrature%coordinates(2,2)= 1.0_rp/6.0_rp
        quadrature%coordinates(3,2)= 1.0_rp/6.0_rp
        quadrature%coordinates(1,3)= 1.0_rp/2.0_rp
        quadrature%coordinates(2,3)= 1.0_rp/6.0_rp
        quadrature%coordinates(3,3)= 1.0_rp/6.0_rp
        quadrature%coordinates(1,4)= 1.0_rp/6.0_rp
        quadrature%coordinates(2,4)= 1.0_rp/2.0_rp
        quadrature%coordinates(3,4)= 1.0_rp/6.0_rp
        quadrature%coordinates(1,5)= 1.0_rp/6.0_rp
        quadrature%coordinates(2,5)= 1.0_rp/6.0_rp
        quadrature%coordinates(3,5)= 1.0_rp/2.0_rp
        quadrature%weight(  1)=-2.0_rp/15.0_rp
        quadrature%weight(  2)= 1.5_rp/20.0_rp
        quadrature%weight(  3)= 1.5_rp/20.0_rp
        quadrature%weight(  4)= 1.5_rp/20.0_rp
        quadrature%weight(  5)= 1.5_rp/20.0_rp
     else if(ngaus==11) then
        a=0.3994035761667992_rp
        b=0.1005964238332008_rp
        c=343.0_rp/7500.0_rp/6.0_rp
        d=56.0_rp/375.0_rp/6.0_rp
        quadrature%coordinates(1,1) = 1.0_rp/4.0_rp
        quadrature%coordinates(2,1) = 1.0_rp/4.0_rp
        quadrature%coordinates(3,1) = 1.0_rp/4.0_rp
        quadrature%coordinates(1,2) = 11.0_rp/14.0_rp
        quadrature%coordinates(2,2) = 1.0_rp/14.0_rp
        quadrature%coordinates(3,2) = 1.0_rp/14.0_rp
        quadrature%coordinates(1,3) = 1.0_rp/14.0_rp
        quadrature%coordinates(2,3) = 11.0_rp/14.0_rp
        quadrature%coordinates(3,3) = 1.0_rp/14.0_rp
        quadrature%coordinates(1,4) = 1.0_rp/14.0_rp
        quadrature%coordinates(2,4) = 1.0_rp/14.0_rp
        quadrature%coordinates(3,4) = 11.0_rp/14.0_rp
        quadrature%coordinates(1,5) = 1.0_rp/14.0_rp
        quadrature%coordinates(2,5) = 1.0_rp/14.0_rp
        quadrature%coordinates(3,5) = 1.0_rp/14.0_rp
        quadrature%coordinates(1,6) = a
        quadrature%coordinates(2,6) = a
        quadrature%coordinates(3,6) = b
        quadrature%coordinates(1,7) = a
        quadrature%coordinates(2,7) = b
        quadrature%coordinates(3,7) = a
        quadrature%coordinates(1,8) = a
        quadrature%coordinates(2,8) = b
        quadrature%coordinates(3,8) = b
        quadrature%coordinates(1,9) = b
        quadrature%coordinates(2,9) = a
        quadrature%coordinates(3,9) = a
        quadrature%coordinates(1,10)= b
        quadrature%coordinates(2,10)= a
        quadrature%coordinates(3,10)= b
        quadrature%coordinates(1,11)= b
        quadrature%coordinates(2,11)= b
        quadrature%coordinates(3,11)= a
        quadrature%weight(1)   =-148.0_rp/1875.0_rp/6.0_rp
        quadrature%weight(2)   = c
        quadrature%weight(3)   = c
        quadrature%weight(4)   = c
        quadrature%weight(5)   = c
        quadrature%weight(6)   = d
        quadrature%weight(7)   = d
        quadrature%weight(8)   = d
        quadrature%weight(9)   = d
        quadrature%weight(10)  = d
        quadrature%weight(11)  = d
     else if(ngaus==14) then
        a=0.0673422422100983_rp
        b=0.3108859192633005_rp
        c=0.7217942490673264_rp
        d=0.0927352503108912_rp
        e=0.4544962958743506_rp
        f=0.0455037041256494_rp
        p=0.1126879257180162_rp/6.0_rp
        q=0.0734930431163619_rp/6.0_rp
        r=0.0425460207770812_rp/6.0_rp
        quadrature%coordinates(1,1) = a
        quadrature%coordinates(2,1) = b
        quadrature%coordinates(3,1) = b
        quadrature%coordinates(1,2) = b
        quadrature%coordinates(2,2) = a
        quadrature%coordinates(3,2) = b
        quadrature%coordinates(1,3) = b
        quadrature%coordinates(2,3) = b
        quadrature%coordinates(3,3) = a
        quadrature%coordinates(1,4) = b
        quadrature%coordinates(2,4) = b
        quadrature%coordinates(3,4) = b
        quadrature%coordinates(1,5) = c
        quadrature%coordinates(2,5) = d
        quadrature%coordinates(3,5) = d
        quadrature%coordinates(1,6) = d
        quadrature%coordinates(2,6) = c
        quadrature%coordinates(3,6) = d
        quadrature%coordinates(1,7) = d
        quadrature%coordinates(2,7) = d
        quadrature%coordinates(3,7) = c
        quadrature%coordinates(1,8) = d
        quadrature%coordinates(2,8) = d
        quadrature%coordinates(3,8) = d
        quadrature%coordinates(1,9) = e
        quadrature%coordinates(2,9) = e
        quadrature%coordinates(3,9) = f
        quadrature%coordinates(1,10)= e
        quadrature%coordinates(2,10)= f
        quadrature%coordinates(3,10)= e
        quadrature%coordinates(1,11)= e
        quadrature%coordinates(2,11)= f
        quadrature%coordinates(3,11)= f
        quadrature%coordinates(1,12)= f
        quadrature%coordinates(2,12)= e
        quadrature%coordinates(3,12)= e
        quadrature%coordinates(1,13)= f
        quadrature%coordinates(2,13)= e
        quadrature%coordinates(3,13)= f
        quadrature%coordinates(1,14)= f
        quadrature%coordinates(2,14)= f
        quadrature%coordinates(3,14)= e
        quadrature%weight(1)   = p
        quadrature%weight(2)   = p
        quadrature%weight(3)   = p
        quadrature%weight(4)   = p
        quadrature%weight(5)   = q
        quadrature%weight(6)   = q
        quadrature%weight(7)   = q
        quadrature%weight(8)   = q
        quadrature%weight(9)   = r
        quadrature%weight(10)  = r
        quadrature%weight(11)  = r
        quadrature%weight(12)  = r
        quadrature%weight(13)  = r
        quadrature%weight(14)  = r
     else
        write(*,*) __FILE__,__LINE__,'ERROR:: Quadrature not defined',ndime,ngaus
        check(.false.)
     end if
  end if

end subroutine tet_nedelec_reference_fe_fill_symmetric_quadrature

! ==============================================================================
subroutine tet_nedelec_reference_fe_change_basis(this) 
  implicit none
  class(tet_nedelec_reference_fe_t), intent(inout) ::  this

  ! Local variables required by edge boundary moments integration
  type(tet_lagrangian_reference_fe_t)     :: fe_1D
  type(quadrature_t)                      :: edge_quadrature
  type(interpolation_t)                   :: interpolation_1D, edget_interpolation
  type(edge_map_t)                        :: edge_map
  type(point_t), pointer                  :: edge_map_coordinates(:)
  real(rp)                                :: shape_test
  type(vector_field_t)                    :: tangent

  ! Local variables required by face boundary moments integration
  type(tet_lagrangian_reference_fe_t) :: fe_2D
  type(quadrature_t)                  :: facet_quadrature
  type(interpolation_t)               :: interpolation_2D, facet_interpolation
  integer(ip)                         :: facet_lid
  type(facet_map_t)                    :: facet_map
  type(point_t), pointer              :: facet_map_coordinates(:)
  real(rp)                            :: v_scalar_shape_test, facet_area  
  integer(ip)                         :: direction  

  ! Local variables required by interior moments integration
  type(tet_lagrangian_reference_fe_t) :: fe
  type(quadrature_t)                  :: cell_quadrature
  type(interpolation_t)               :: interpolation, cell_interpolation
  type(cell_map_t)                      :: cell_map
  type(point_t), pointer              :: cell_map_coordinates(:)
  integer(ip)                         :: reduced_order_vector(SPACE_DIM)
  integer(ip)                         :: num_interior_moments
  type(vector_field_t)                :: v_shape_test

  ! Local variables requires for both boundary/interior moments integration
  type(tet_lagrangian_reference_fe_t) :: d_fe_geo
  type(vector_field_t)                :: v_shape_trial
  integer(ip)                         :: ishape, jshape, qpoint
  real(rp)                            :: factor
  integer(ip)                         :: idime

  ! Rest of local variables
  integer(ip)                         :: c, d, i, j, istat
  integer(ip)                         :: num_rows_own_node_permutations
  integer(ip)                         :: num_cols_own_node_permutations
  type(list_iterator_t)               :: own_dofs_iterator

  ! Facets and vertices within reference cell traversal-related data structures
  type(list_iterator_t)               :: vertex_iterator
  integer(ip)                         :: vertex_within_cell_id
  integer(ip)                         :: vertex_within_edge_id
  integer(ip)                         :: vertex_within_face_id
  integer(ip)                         :: edge_id, facet_id, n_face_id

  type(allocatable_array_ip2_t), allocatable :: own_node_permutations(:)
  integer(ip) :: icomp, orient, offcomponent 

  assert ( .not. this%basis_changed )
  assert ( this%conformity .and. this%continuity )

  ! Allocate change_basis_matrix
  if ( allocated(this%change_basis_matrix) ) & 
       call memfree(this%change_basis_matrix, __FILE__, __LINE__)    

  call memalloc(this%num_shape_functions, &
       this%num_shape_functions, &
       this%change_basis_matrix, &
       __FILE__, &
       __LINE__)

  ! Create a 1D scalar lagrangian reference FE of order k-1,  ! P_{k-1}
  call fe_1D%create(topology          = this%get_topology(), &
       num_dims = 1,                   &
       order             = this%order-1,        & 
       field_type        = field_type_scalar,   &
       conformity        = .true. )

  ! Create a d-dim scalar lagrangian reference FE of order 1 (geometry)
  call d_fe_geo%create(topology          = this%get_topology(), &
       num_dims = this%num_dims, &
       order             = 1, &
       field_type        = field_type_scalar, &
       conformity        = .true. )

  call this%create_edge_quadrature( edge_quadrature )

  call fe_1D%create_interpolation( edge_quadrature, interpolation_1D )

  call edge_map%create( edge_quadrature, d_fe_geo )

  ! Initialize change of basis matrix
  this%change_basis_matrix = 0.0_rp

  d = 0
  do edge_id = this%get_first_n_face_id_of_dim(1), & 
       this%get_first_n_face_id_of_dim(1) + this%get_num_n_faces_of_dim(1)-1

     ! Get edge map coordinates
     edge_map_coordinates => edge_map%get_coordinates()

     ! Extract coordinates of the vertices within the face
     vertex_within_edge_id = 1
     vertex_iterator = this%vertices_n_face%create_iterator(edge_id)
     do while ( .not. vertex_iterator%is_upper_bound () )
        vertex_within_cell_id = vertex_iterator%get_current()
        call edge_map_coordinates(vertex_within_edge_id)%init(d_fe_geo%nodal_quadrature%coordinates(:, vertex_within_cell_id))
        call vertex_iterator%next()
        vertex_within_edge_id = vertex_within_edge_id + 1
     end do

     ! Update edge_map on current edge
     call edge_map%update(local_edge_id = edge_id - d_fe_geo%get_first_n_face_id_of_dim(1)+1, &
          reference_fe  = d_fe_geo, &
          quadrature    = edge_quadrature ) 

     ! Edge quadrature is updated to every edge of the reference_fe 
     call this%create_interpolation_restricted_to_edget (edge_id - d_fe_geo%get_first_n_face_id_of_dim(1)+1, &
          edge_quadrature,                                          &
          edget_interpolation )

     ! Integrate edge boundary moments int_edge(u.t q), q \in P_k-1
     do qpoint = 1, edge_quadrature%num_quadrature_points
        factor = edge_map%get_det_jacobian(qpoint) * edge_quadrature%get_weight(qpoint)
        call edge_map%get_tangent(qpoint, tangent)

        do ishape=1, interpolation_1D%num_shape_functions
           call fe_1D%get_value(interpolation_1D, ishape, qpoint, shape_test)
           do jshape=1, edget_interpolation%num_shape_functions
              call this%get_value(edget_interpolation, jshape, qpoint, v_shape_trial)
              this%change_basis_matrix(d+ishape,jshape) = this%change_basis_matrix(d+ishape,jshape) &
                   + shape_test * v_shape_trial * tangent * factor
           end do
        end do
     end do
     d = d + interpolation_1D%num_shape_functions
  end do

  if ( this%num_dims == 3 .and. this%order > 1 ) then 
     ! Create a 2D scalar reference_fe of order P_{k-2,k-2} x P_{k-2,k-2}
     call fe_2D%create(topology          = this%get_topology(), &
          num_dims = 2,                   &
          order             = this%order-2,        &
          field_type        = field_type_scalar,   &
          conformity        = .true. )

     call this%create_facet_quadrature( facet_quadrature )
     call fe_2D%create_interpolation( facet_quadrature, interpolation_2D )
     call facet_map%create( facet_quadrature, d_fe_geo )

     do facet_id = this%get_first_facet_id(), this%get_first_facet_id() + this%get_num_facets()-1

        ! Get face map coordinates
        facet_map_coordinates => facet_map%get_coordinates()

        ! Extract coordinates of the vertices within the face
        vertex_within_face_id = 1
        vertex_iterator = this%vertices_n_face%create_iterator(facet_id)
        do while ( .not. vertex_iterator%is_upper_bound () )
           vertex_within_cell_id = vertex_iterator%get_current()
           call facet_map_coordinates(vertex_within_face_id)%init(d_fe_geo%nodal_quadrature%coordinates(:, vertex_within_cell_id))
           call vertex_iterator%next()
           vertex_within_face_id = vertex_within_face_id + 1
        end do

        ! Update facet_map on current face
        facet_lid = facet_id - d_fe_geo%get_first_facet_id()+1
        call facet_map%update(reorientation_factor   = d_fe_geo%get_normal_orientation_factor(facet_lid), &
             quadrature             = facet_quadrature ) 

        call this%create_interpolation_restricted_to_facet (facet_id - d_fe_geo%get_first_facet_id()+1, &
             -1, facet_quadrature,                           &
             facet_interpolation )

        ! Integrate face boundary moments int_Face(u^n q), q \in P_{k-2,k-2} P_{k-2,k-2}
        do qpoint = 1, facet_quadrature%num_quadrature_points
           factor = facet_map%get_det_jacobian(qpoint) * facet_quadrature%get_weight(qpoint)		   
           facet_area = 0.5_rp*facet_map%get_det_jacobian(qpoint) 
           ! Each scalar test function is endowed with vector field type  
           ! through v_scalar_shape_test * tangent vectors to the face 
           do direction=1,2
              c = (direction-1)*interpolation_2D%num_shape_functions
              call facet_map%get_jacobian_column(direction,qpoint,tangent) ! x_i - x^0_i (not normalized)
              do ishape=1, interpolation_2D%num_shape_functions
                 call fe_2D%get_value(interpolation_2D, ishape, qpoint, v_scalar_shape_test)   
                 do jshape=1, facet_interpolation%num_shape_functions
                    call this%get_value(facet_interpolation, jshape, qpoint, v_shape_trial)   	
                    this%change_basis_matrix(d+ishape+c,jshape) = this%change_basis_matrix(d+ishape+c,jshape) &
                         + 1/facet_area * v_shape_trial * v_scalar_shape_test * tangent * factor
                 end do
              end do
           end do
        end do
        d = d + interpolation_2D%num_shape_functions*fe_2D%num_dims 
     end do
  end if

  ! Compute number interior shape functions shape functions
  if ( this%num_dims == 2) then 
     num_interior_moments = this%order_vector(1)*(this%order_vector(1)-1) ! k(k-1)
  elseif (this%num_dims == 3) then 
     num_interior_moments = this%order_vector(1)*(this%order_vector(1)-1)*(this%order_vector(1)-2)/2 ! k(k-1)(k-2)/2
  end if

  if ( num_interior_moments > 0 ) then 

     ! Create dim-D Lagrangian polynomial of order k-d 
     call fe%create(topology           = this%get_topology(),               &
          num_dims  = this%num_dims,            &
          order              = this%order-this%num_dims, &
          field_type         = field_type_vector,                 &
          conformity         = .true.                            )

     call this%create_quadrature( cell_quadrature )
     call fe%create_interpolation( cell_quadrature, interpolation )

     ! Create PRE-BASIS cell-interpolation from this NEDELEC REF FE 
     call this%create_interpolation( cell_quadrature, cell_interpolation )

     ! Create + Update cell map 
     call cell_map%create(cell_quadrature, d_fe_geo )
     cell_map_coordinates => cell_map%get_coordinates()
     do vertex_within_cell_id=1,d_fe_geo%get_num_vertices()
        call cell_map_coordinates(vertex_within_cell_id)%init(d_fe_geo%nodal_quadrature%coordinates(:, vertex_within_cell_id))
     end do
     call cell_map%update(cell_quadrature)

     ! Integration of interior moments 
     ! 2D CASE: int_K (u·q), q \in P_{k-2,k-2} x Q_{k-2,k-2} 
     ! 3D CASE: int_K (u·q), q \in P_{k-3,k-3,k-3} x Q_{k-3,k-3,k-3} x Q_{k-3,k-3,k-3}     
     do qpoint = 1, cell_quadrature%num_quadrature_points
        factor = cell_map%get_det_jacobian(qpoint) * cell_quadrature%get_weight(qpoint)
        do ishape=1, interpolation%num_shape_functions*fe%num_dims
           call fe%get_value(interpolation, ishape, qpoint, v_shape_test)
           do jshape=1, cell_interpolation%num_shape_functions
              call this%get_value(cell_interpolation, jshape, qpoint, v_shape_trial)
              this%change_basis_matrix(d+ishape,jshape) = this%change_basis_matrix(d+ishape,jshape) + v_shape_test * v_shape_trial * factor
           end do
        end do
     end do

  end if

  ! Invert change_basis_matrix
  call this%invert_change_basis_matrix()

  ! Transform type(list_t) member variables of this to reflect change of basis
  call this%own_dofs_n_face%create( this%num_n_faces + 1 )

  if ( this%conformity .and. this%continuity ) then
     do edge_id = this%get_first_n_face_id_of_dim(1), & 
          this%get_first_n_face_id_of_dim(1) + this%get_num_n_faces_of_dim(1)-1
        call this%own_dofs_n_face%sum_to_pointer_index(edge_id, interpolation_1D%num_shape_functions )           
     end do

     if (this%num_dims == 3 .and. this%order > 1) then
        do facet_id = this%get_first_facet_id(), this%get_first_facet_id() + this%get_num_facets()-1
           call this%own_dofs_n_face%sum_to_pointer_index(facet_id, interpolation_2D%num_shape_functions*fe_2D%num_dims )
        end do
     end if

     call this%own_dofs_n_face%sum_to_pointer_index(this%num_n_faces + 1, num_interior_moments)
     call this%own_dofs_n_face%calculate_header()
     call this%own_dofs_n_face%allocate_list_from_pointer()

     c=1
     do idime=1, this%num_dims
        do n_face_id = this%get_first_n_face_id_of_dim(idime), & 
             this%get_first_n_face_id_of_dim(idime) + this%get_num_n_faces_of_dim(idime)-1
           own_dofs_iterator = this%own_dofs_n_face%create_iterator(n_face_id)
           do while ( .not. own_dofs_iterator%is_upper_bound() )
              call own_dofs_iterator%set_current(c)
              c = c + 1
              call own_dofs_iterator%next()
           end do
           call own_dofs_iterator%next()
        end do
     end do
  else 

     call this%own_dofs_n_face%sum_to_pointer_index( this%own_dofs_n_face%get_num_pointers(), this%num_shape_functions)
     call this%own_dofs_n_face%calculate_header()
     call this%own_dofs_n_face%allocate_list_from_pointer()
     own_dofs_iterator = this%own_dofs_n_face%create_iterator()
     i=1
     do while(.not. own_dofs_iterator%is_upper_bound())
        call own_dofs_iterator%set_current(i)
        call own_dofs_iterator%next()
        i = i + 1 
     enddo

  end if
  this%dofs_n_face = this%own_dofs_n_face

  ! Flag change of basis
  this%basis_changed = .true.

  ! Free all local data structures required for edge moments integration
  call d_fe_geo%free()
  call fe_1D%free()
  call edge_quadrature%free()
  call interpolation_1D%free()
  call edget_interpolation%free()
  call edge_map%free()

  ! Free all local data structures required for face moments integration
  call fe_2D%free()
  call facet_quadrature%free()
  call interpolation_2D%free()
  call facet_interpolation%free()
  call facet_map%free()

  ! Free all local data structures required for element itself moments integration 
  call fe%free() 
  call interpolation%free()
  call cell_quadrature%free()
  call cell_interpolation%free()
  call cell_map%free()

end subroutine tet_nedelec_reference_fe_change_basis

!==================================================================================================
function tet_nedelec_reference_fe_compute_permutation_index(source_reference_fe, target_reference_fe,          &
     &                                                         source_n_face_id, target_n_face_id,         &
     &                                                         source_n_faces, target_n_faces)
  implicit none
  class(tet_nedelec_reference_fe_t), intent(in)  :: source_reference_fe
  class(reference_fe_t)               , intent(in)  :: target_reference_fe
  integer(ip)                         , intent(in)  :: source_n_face_id ! Local n-face ID
  integer(ip)                         , intent(in)  :: target_n_face_id ! Local n-face ID
  integer(ip)                         , intent(in)  :: source_n_faces(:)
  integer(ip)                         , intent(in)  :: target_n_faces(:) 
  integer(ip) :: tet_nedelec_reference_fe_compute_permutation_index
  tet_nedelec_reference_fe_compute_permutation_index = 1
end function tet_nedelec_reference_fe_compute_permutation_index

!==================================================================================================
function tet_nedelec_reference_fe_permute_dof_LID_n_face(this,source_dof_lid_n_face,n_face_dim,permutation_index)
  implicit none
  class(tet_nedelec_reference_fe_t), intent(in)  :: this
  integer(ip)                         , intent(in)  :: source_dof_lid_n_face
  integer(ip)                         , intent(in)  :: n_face_dim
  integer(ip)                         , intent(in)  :: permutation_index
  integer(ip) :: tet_nedelec_reference_fe_permute_dof_LID_n_face
  tet_nedelec_reference_fe_permute_dof_LID_n_face = source_dof_lid_n_face
end function tet_nedelec_reference_fe_permute_dof_LID_n_face

 !==================================================================================================
subroutine tet_nedelec_reference_fe_evaluate_vector_function_moments(this, cell_map, vector_function, dof_values)
  implicit none
  class(tet_nedelec_reference_fe_t), intent(in)    :: this
  class(cell_map_t)            , intent(in)    :: cell_map
  class(vector_function_t)     , intent(in)    :: vector_function
  real(rp) , allocatable       , intent(inout) :: dof_values(:) 

  type(point_t)                , pointer    :: coordinates(:)
  type(tet_lagrangian_reference_fe_t)       :: d_fe_geo

  ! Edges 
  type(hex_lagrangian_reference_fe_t) :: fe_1D
  type(interpolation_t)               :: interpolation_1D
  type(quadrature_t)                  :: edge_quadrature
  type(edge_map_t)                    :: edge_map
  type(vector_field_t)                :: tangent
  type(list_iterator_t)               :: vertex_iterator 
  type(point_t), pointer              :: edge_map_coordinates(:)
  integer(ip)                         :: edge_id  
  integer(ip)                         :: vertex_within_edge_id  

  ! Common integration 
		integer(ip)                         :: vertex_within_cell_id
  real(rp)                            :: shape_test, factor 
  integer(ip)                         :: idime, ishape
  integer(ip)                         :: qpoint, num_quad_points 
  type(vector_field_t), allocatable   :: function_values(:) 
  type(point_t), pointer              :: quad_points_coordinates(:)

  integer(ip)  :: d, istat 
		
  coordinates => cell_map%get_coordinates()

  ! Create a 1D scalar lagrangian reference FE of order k-1
  call fe_1D%create(topology          = this%get_topology(), &
                    num_dims          = 1, &
                    order             = this%order-1, &
                    field_type        = field_type_scalar, &
                    conformity        = .true. )

  ! Create a d-dim scalar lagrangian reference FE of order 1 (geometry)
  call d_fe_geo%create(topology    = this%get_topology(),    &
                       num_dims    = this%num_dims,          &
                       order       = 1,                      &
                       field_type  = field_type_scalar,      &
                       conformity  = .false. )

  call this%create_edge_quadrature( edge_quadrature )
  call edge_map%create( edge_quadrature, d_fe_geo )
  call fe_1D%create_interpolation( edge_quadrature, interpolation_1D )

  num_quad_points  = edge_quadrature%get_num_quadrature_points()
  allocate (function_values(num_quad_points), stat=istat); check(istat==0)

  d = 0
		dof_values = 0.0_rp 
  do edge_id = this%get_first_n_face_id_of_dim(1), this%get_first_n_face_id_of_dim(1) + this%get_num_n_faces_of_dim(1)-1

     edge_map_coordinates => edge_map%get_coordinates()   

     vertex_within_edge_id = 1
     vertex_iterator = this%vertices_n_face%create_iterator(edge_id)
     do while ( .not. vertex_iterator%is_upper_bound () )
        vertex_within_cell_id = vertex_iterator%get_current()
        do idime=1,this%num_dims  
           call edge_map_coordinates(vertex_within_edge_id)%set(idime, coordinates(vertex_within_cell_id)%get(idime) )
        end do
        call vertex_iterator%next()
        vertex_within_edge_id = vertex_within_edge_id + 1
     end do

     ! Update edge_map on current edge
     call edge_map%update(local_edge_id = edge_id - this%get_first_n_face_id_of_dim(1)+1, &
                          reference_fe  = this,                                           &
                          quadrature    = edge_quadrature )

     ! Extract quadrature points coordinates 
     quad_points_coordinates => edge_map%get_quadrature_points_coordinates()

     ! Fill vector function values restricted to edge 
     call vector_function%get_values_set(quad_points_coordinates, function_values)
					
     ! Integrate edge boundary moments int_edge(f.tau q), q \in P_k-1
     do qpoint = 1, num_quad_points
        factor = edge_map%get_det_jacobian(qpoint) * edge_quadrature%get_weight(qpoint)
        call edge_map%get_tangent(qpoint, tangent)
        do ishape=1, interpolation_1D%num_shape_functions
           call fe_1D%get_value(interpolation_1D, ishape, qpoint, shape_test)
           dof_values(d+ishape) = dof_values(d+ishape) + 1.0_rp / tangent%nrm2() * function_values(qpoint) * shape_test * tangent * factor 
        end do
     end do

     d = d + interpolation_1D%num_shape_functions
  end do

				 ! Free all local data structures required for edge moments integration
  call d_fe_geo%free()
  call fe_1D%free()
  call edge_quadrature%free()
  call interpolation_1D%free()
  call edge_map%free()
		deallocate (function_values, stat=istat); check(istat==0)
	
end subroutine tet_nedelec_reference_fe_evaluate_vector_function_moments

!==================================================================================================
subroutine tet_nedelec_reference_fe_evaluate_boundary_function_moments(this, facet_map, function_scalar_components, dof_values)
  class(tet_nedelec_reference_fe_t)      , intent(in)    :: this
		class(facet_map_t)                     , intent(in)    :: facet_map
		type(p_scalar_function_t), allocatable , intent(in)    :: function_scalar_components(:)
		real(rp) , allocatable                 , intent(inout) :: dof_values(:) 
		! To develop 
end subroutine tet_nedelec_reference_fe_evaluate_boundary_function_moments
