! Copyright (C) 2014 Santiago Badia, Alberto F. Martín and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  
subroutine create_projector( projector, reference_fe, projector_type)  
  implicit none 
  class(projector_t) , allocatable        , intent(inout) :: projector
  class(reference_fe_t)                   , intent(in)    :: reference_fe 
  integer(ip), optional                   , intent(in)    :: projector_type   

		! Allocation of projector_t based on the reference_fe. Other projections 
		! could be implemented not depending on the reference_fe, then an optional 
		! argument must be passed indicating projector_type
		select type ( reference_fe ) 
		class is (hex_nedelec_reference_fe_t ) 
  allocate( hex_Hcurl_projector_t :: projector )
		class is ( tet_nedelec_reference_fe_t ) 
		allocate( tet_Hcurl_projector_t :: projector ) 
		class is ( hex_lagrangian_reference_fe_t ) 
		allocate ( H1_projector_t :: projector ) 
		class is ( tet_lagrangian_reference_fe_t ) 
		allocate ( H1_projector_t :: projector ) 
		class DEFAULT
		check(.false.) 
		end select 
		
		! Init variables
		projector%topology   = reference_fe%topology   
  projector%num_dims   = reference_fe%num_dims 
  projector%order      = reference_fe%order
		projector%field_type = reference_fe%field_type  

end subroutine create_projector

! ================================================================================
subroutine projector_update( this, cell_map )
  implicit none
  class(projector_t)          , intent(inout) :: this
  type(cell_map_t)            , intent(in)    :: cell_map 

  this%cell_coordinates => cell_map%get_coordinates()

end subroutine projector_update

! ================================================================================
subroutine Hcurl_projector_evaluate_scalar_function_moments( this, scalar_function, dof_values ) 
  implicit none
  class(Hcurl_projector_t)        , intent(inout) :: this
  class(scalar_function_t)     , intent(in)    :: scalar_function
  real(rp) , allocatable       , intent(inout) :: dof_values(:) 
		! Does not apply for vector FEs
  assert(.false.) 
end subroutine Hcurl_projector_evaluate_scalar_function_moments

! ================================================================================
subroutine hex_Hcurl_projector_init( this )
  implicit none
  class(hex_Hcurl_projector_t)      , intent(inout) :: this 
  integer(ip)                         :: reduced_order_vector(SPACE_DIM)
  integer(ip)                         :: num_interior_moments
  integer(ip)                         :: idime, istat 

   ! Create a d-dim Nedelec reference FE. Conformity=true  
	 	! is important to compute own_dofs_x_vef information 
  call this%reference_fe%create(topology    = this%topology,       &
                                num_dims    = this%num_dims,       &
                                order       = this%order,          &
                                field_type  = field_type_vector,   &
                                conformity  = .true. )

  ! Create a d-dim scalar lagrangian reference FE of order 1 (geometry)
  call this%d_fe_geo%create(topology    = this%topology,          &
                            num_dims    = this%num_dims,          &
                            order       = 1,                      &
                            field_type  = field_type_scalar,      &
                            conformity  = .false. )

  ! Create a 1D scalar lagrangian reference FE of order k-1
  call this%fe_1D%create(topology          = this%topology,       &
                         num_dims          = 1,                   &
                         order             = this%order-1,        &
                         field_type        = field_type_scalar,   &
                         conformity        = .true. )

  call this%reference_fe%create_edge_quadrature( this%edge_quadrature )
  call this%edge_map%create( this%edge_quadrature, this%d_fe_geo )
  call this%fe_1D%create_interpolation( this%edge_quadrature, this%edge_interpolation )
  allocate (this%edge_function_values(this%edge_quadrature%get_num_quadrature_points()), stat=istat); check(istat==0)
		call memalloc ( this%edge_quadrature%get_num_quadrature_points(), 1, this%scalar_function_values_on_edge, __FILE__, __LINE__)

  if ( this%num_dims == 3 .and. this%order > 1 ) then 
  ! Create a 2D Nedelec reference FE of order k-1
    call this%fe_2D%create(topology   = this%topology,     &
                           num_dims   = 2,                 &
                           order      = this%order-1,      &
                           field_type = field_type_vector, &
                           conformity = .false. )

   call this%reference_fe%create_facet_quadrature( this%facet_quadrature )
   call this%fe_2D%create_interpolation( this%facet_quadrature, this%facet_interpolation )
   call this%facet_map%create( this%facet_quadrature, this%d_fe_geo )
   allocate (this%facet_function_values(this%facet_quadrature%get_num_quadrature_points()), stat=istat); check(istat==0)
			call memalloc ( this%facet_quadrature%get_num_quadrature_points(), 1, this%scalar_function_values_on_facet, __FILE__, __LINE__)

  end if 

  ! Q_{k-1,k-2} x Q_{k-2,k-1}
  reduced_order_vector(1)   = this%reference_fe%order_vector(1)
  reduced_order_vector(2:3) = this%reference_fe%order_vector(2:3)-2

  ! compute number shape functions for reduced order element
  num_interior_moments = 1
  do idime = 1, this%num_dims
     num_interior_moments = num_interior_moments*(reduced_order_vector(idime)+1)
  end do
  num_interior_moments = num_interior_moments*this%num_dims

  if ( num_interior_moments > 0 ) then 

      ! Create a Raviart-Thomas reference FE of order k-2
     call this%fe%create(topology          = this%topology,       &
                         num_dims          = this%num_dims,       &
                         order             = this%order-2,        &
                         field_type        = field_type_vector,   &
                         conformity        = .false. )

   call this%reference_fe%create_quadrature( this%cell_quadrature )

    ! create reduced order interpolation
     call this%cell_interpolation%create( this%num_dims,                         &
                                          num_interior_moments,                  &
                                          this%cell_quadrature%num_quadrature_points, &
                                          num_entries_symmetric_tensor=0,        &
                                          compute_hessian = .false. )

   call this%reference_fe%fill_interpolation_pre_basis( this%cell_quadrature,     & 
                                                        this%cell_interpolation,  & 
                                                        reduced_order_vector)

   call this%cell_map%create( this%cell_quadrature, this%d_fe_geo )
   allocate (this%cell_function_values(this%cell_quadrature%get_num_quadrature_points()), stat=istat); check(istat==0)

  end if 

end subroutine hex_Hcurl_projector_init

! ================================================================================
subroutine hex_Hcurl_projector_evaluate_vector_function_moments( this, vector_function, dof_values ) 
  implicit none
  class(hex_Hcurl_projector_t) , intent(inout) :: this
  class(vector_function_t)     , intent(in)    :: vector_function
  real(rp) , allocatable       , intent(inout) :: dof_values(:) 
  
  ! Edge moments evaluation 
  type(vector_field_t)                :: tangent 
  type(list_iterator_t)               :: vertex_iterator 
  type(point_t), pointer              :: edge_map_coordinates(:)
  integer(ip)                         :: edge_id  
  integer(ip)                         :: vertex_within_edge_id 

  ! Faces moments integration  
  type(point_t), pointer              :: facet_map_coordinates(:)
  type(vector_field_t)                :: normal
  type(vector_field_t)                :: cross_product_function_normal
  type(vector_field_t)                :: cross_product_function_normal_proj
  type(vector_field_t)                :: col_jacobian
  integer(ip)                         :: facet_id, facet_lid
  integer(ip)                         :: vertex_within_facet_id

 ! Local variables required by interior moments integration
  type(point_t), pointer              :: cell_map_coordinates(:)
  type(interpolation_t)               :: mapped_cell_interpolation
  type(vector_field_t)                :: v_shape_test

  ! Common integration 
  integer(ip)                         :: vertex_within_cell_id
  real(rp)                            :: shape_test, factor 
  integer(ip)                         :: idime, ishape
  integer(ip)                         :: qpoint, num_quad_points 
  type(vector_field_t), allocatable   :: function_values(:) 
  type(point_t), pointer              :: quad_points_coordinates(:)

  integer(ip) :: d, istat 

  d = 0
  dof_values = 0.0_rp 
  do edge_id = this%reference_fe%get_first_n_face_id_of_dim(1), & 
       this%reference_fe%get_first_n_face_id_of_dim(1) + this%reference_fe%get_num_n_faces_of_dim(1)-1

     edge_map_coordinates => this%edge_map%get_coordinates()   

     vertex_within_edge_id = 1
     vertex_iterator = this%reference_fe%vertices_n_face%create_iterator(edge_id)
     do while ( .not. vertex_iterator%is_upper_bound () )
        vertex_within_cell_id = vertex_iterator%get_current()
        call edge_map_coordinates(vertex_within_edge_id)%init( this%cell_coordinates(vertex_within_cell_id)%get_value() )
        call vertex_iterator%next()
        vertex_within_edge_id = vertex_within_edge_id + 1
     end do

     ! Update edge_map on current edge
     call this%edge_map%update(local_edge_id = edge_id - this%reference_fe%get_first_n_face_id_of_dim(1)+1, &
          reference_fe  = this%reference_fe,                                           &
          quadrature    = this%edge_quadrature )

     ! Extract quadrature points coordinates 
     quad_points_coordinates => this%edge_map%get_quadrature_points_coordinates()

     ! Fill vector function values restricted to edge 
     call vector_function%get_values_set(quad_points_coordinates, this%edge_function_values)

     ! Integrate edge boundary moments int_edge(f.tau q), q \in P_k-1
     do qpoint = 1, this%edge_quadrature%get_num_quadrature_points() 
        factor = this%edge_map%get_det_jacobian(qpoint) * this%edge_quadrature%get_weight(qpoint)
        call this%edge_map%get_tangent(qpoint, tangent)
        do ishape=1, this%edge_interpolation%num_shape_functions
           call this%fe_1D%get_value(this%edge_interpolation, ishape, qpoint, shape_test)
           dof_values(d+ishape) = dof_values(d+ishape) + 1.0_rp / tangent%nrm2() * & 
                this%edge_function_values(qpoint) * shape_test * tangent * factor 
        end do
     end do

     d = d + this%edge_interpolation%num_shape_functions
  end do

  if ( this%num_dims == 3 .and. this%order > 1 ) then

     do facet_id = this%reference_fe%get_first_facet_id(), & 
                   this%reference_fe%get_first_facet_id() + this%reference_fe%get_num_facets()-1

        ! Get face map coordinates
        facet_map_coordinates => this%facet_map%get_coordinates()

        ! Extract coordinates of the vertices within the face
        vertex_within_facet_id = 1
        vertex_iterator = this%reference_fe%vertices_n_face%create_iterator(facet_id)
        do while ( .not. vertex_iterator%is_upper_bound () )
           vertex_within_cell_id = vertex_iterator%get_current()
           call facet_map_coordinates(vertex_within_facet_id)%init( this%cell_coordinates(vertex_within_cell_id)%get_value() )
           call vertex_iterator%next()
           vertex_within_facet_id = vertex_within_facet_id + 1
        end do

        ! Update facet_map on current face
        facet_lid = facet_id - this%d_fe_geo%get_first_facet_id()+1
        call this%facet_map%update(reorientation_factor   = this%d_fe_geo%get_normal_orientation_factor(facet_lid), &
                                   quadrature             = this%facet_quadrature ) 

        ! Extract quadrature points coordinates 
        quad_points_coordinates => this%facet_map%get_quadrature_points_coordinates()

        ! Fill vector function values restricted to edge 
        call vector_function%get_values_set(quad_points_coordinates, this%facet_function_values)
        call cross_product_function_normal_proj%init(0.0_rp)

        ! Integrate face boundary moments int_Face(u x n q), q \in Q_k-2,k-1 x Q_k-1,k-2
        do qpoint = 1, this%facet_quadrature%get_num_quadrature_points()
           factor = this%facet_map%get_det_jacobian(qpoint) * this%facet_quadrature%get_weight(qpoint)
           call this%facet_map%get_normal(qpoint, normal)   
           normal = (-1.0_rp)**(this%reference_fe%orientation%a(facet_id)) * normal

           ! Compute g x n
           cross_product_function_normal = cross_product(this%facet_function_values(qpoint),normal)
           do idime=1,this%num_dims-1 
              call this%facet_map%get_jacobian_column(idime,qpoint,col_jacobian)
              col_jacobian = col_jacobian * (1.0_rp/col_jacobian%nrm2()) 
              call cross_product_function_normal_proj%set(idime, col_jacobian*cross_product_function_normal)
           end do

           do ishape=1, this%facet_interpolation%num_shape_functions
              call this%fe_2D%get_value(this%facet_interpolation, ishape, qpoint, v_shape_test)   

              ! WARNING: Update 2D interpolation for the Nedelec test functions ( J**{-T} will only work in HEX structured meshes! )
              do idime=1, this%num_dims-1
                 call this%facet_map%get_jacobian_column(idime,qpoint,col_jacobian)
                 call v_shape_test%set(idime, v_shape_test%get(idime)/col_jacobian%nrm2() )
              end do

              dof_values(d+ishape) = dof_values(d+ishape) + cross_product_function_normal_proj * v_shape_test * factor
           end do
        end do
        d = d + this%facet_interpolation%num_shape_functions
     end do

  end if

  if ( this%order>1 ) then 
      ! Get cell map coordinates
        cell_map_coordinates => this%cell_map%get_coordinates()
        do vertex_within_cell_id = 1, size(this%cell_coordinates) 
        call cell_map_coordinates(vertex_within_cell_id)%init( this%cell_coordinates(vertex_within_cell_id)%get_value() )
        end do 

     ! Update cell map 
       call this%cell_map%update(this%cell_quadrature)
 
     ! Extract quadrature points coordinates 
     quad_points_coordinates => this%cell_map%get_quadrature_points_coordinates()

     ! Fill vector function values restricted to edge 
     call vector_function%get_values_set(quad_points_coordinates, this%cell_function_values)

     ! Update interpolation on the physical space 
     call mapped_cell_interpolation%clone( this%cell_interpolation ) 
     call this%fe%apply_cell_map( this%cell_map, this%cell_interpolation, mapped_cell_interpolation) 

     ! Integration of interior moments int_K (u.q), q \in Q_{k-1,k-2,k-2} x Q_{k-2,k-1,k-2} x Q_{k-2,k-2,k-1}
     do qpoint = 1, this%cell_quadrature%num_quadrature_points
        factor = this%cell_map%get_det_jacobian(qpoint) * this%cell_quadrature%get_weight(qpoint)
        do ishape=1, mapped_cell_interpolation%num_shape_functions
           call this%reference_fe%get_value(mapped_cell_interpolation, ishape, qpoint, v_shape_test)
           dof_values(d+ishape) = dof_values(d+ishape) + this%cell_function_values(qpoint) * v_shape_test * factor
        end do
     end do
  
     call mapped_cell_interpolation%free() 
  end if

end subroutine hex_Hcurl_projector_evaluate_vector_function_moments

!==================================================================================================
subroutine hex_Hcurl_projector_evaluate_boundary_function_moments(this, vef_lid, function_scalar_components, dof_values, time)
  class(hex_Hcurl_projector_t)            , intent(inout) :: this
  integer(ip)                             , intent(in)    :: vef_lid 
  type(p_scalar_function_t), allocatable  , intent(in)    :: function_scalar_components(:)
  real(rp) , allocatable                  , intent(inout) :: dof_values(:)  
  real(rp) , optional                     , intent(in)    :: time 

  ! Edges 
  type(vector_field_t)                :: tangent
  type(list_iterator_t)               :: vertex_iterator 
  type(point_t), pointer              :: edge_map_coordinates(:)
  integer(ip)                         :: edge_id  
  integer(ip)                         :: vertex_within_edge_id  

  ! Faces 
  integer(ip)                         :: facet_lid
  type(point_t), pointer              :: facet_map_coordinates(:)
  type(vector_field_t)                :: normal
  type(vector_field_t)                :: cross_product_function_normal
  type(vector_field_t)                :: cross_product_function_normal_proj
  type(vector_field_t)                :: col_jacobian
  integer(ip)                         :: vertex_within_facet_id 

  ! Common integration 
  real(rp)                            :: time_(1)  
  integer(ip)                         :: vertex_within_cell_id
  real(rp)                            :: shape_test, factor 
  type(vector_field_t)                :: v_shape_test 
  integer(ip)                         :: idime, ishape, idof 
  integer(ip)                         :: qpoint, num_quad_points 
  type(point_t), pointer              :: quad_points_coordinates(:)
  type(list_iterator_t)               :: own_dofs

  integer(ip)                         :: i, iedge, icomp, istat

  ! Nedelec elements do not contain DOFs on vertices 
  if ( this%reference_fe%get_n_face_dim(vef_lid) == 0) then 
     return 
  end if

  dof_values = 0.0_rp		
  if ( present(time) ) time_(1) = time 	

  if ( this%reference_fe%get_n_face_dim(vef_lid) == 1) then 			

     num_quad_points = this%edge_quadrature%get_num_quadrature_points()
     edge_map_coordinates => this%edge_map%get_coordinates()

     vertex_within_edge_id = 1
     vertex_iterator = this%reference_fe%vertices_n_face%create_iterator(vef_lid)
     do while ( .not. vertex_iterator%is_upper_bound () )
        vertex_within_cell_id = vertex_iterator%get_current()
								call edge_map_coordinates(vertex_within_edge_id)%init( this%cell_coordinates(vertex_within_cell_id)%get_value() )
        call vertex_iterator%next()
        vertex_within_edge_id = vertex_within_edge_id + 1
     end do

     ! Update edge_map on current edge
     call this%edge_map%update(local_edge_id = vef_lid - this%reference_fe%get_first_n_face_id_of_dim(1)+1, &
          reference_fe  = this%reference_fe,                                           &
          quadrature    = this%edge_quadrature )

     ! Extract quadrature points coordinates 
     quad_points_coordinates => this%edge_map%get_quadrature_points_coordinates()

     ! Fill vector function values restricted to edge 
     select case(this%reference_fe%get_field_type())
     case ( field_type_scalar )
        ! reference_fe MUST BE a vector-valued FE
        assert (.false.)
     case ( field_type_vector )
        do icomp=1, this%reference_fe%get_num_field_components()
           if(present(time)) then
              call function_scalar_components(icomp)%p%get_values_set_space_time(quad_points_coordinates,time_,this%scalar_function_values_on_edge(1:num_quad_points,:))
           else
              call function_scalar_components(icomp)%p%get_values_set_space(quad_points_coordinates,this%scalar_function_values_on_edge(1:num_quad_points,1))
           end if
           do qpoint = 1, num_quad_points
              call this%edge_function_values(qpoint)%set(icomp,this%scalar_function_values_on_edge(qpoint,1))
           end do
        end do
     case ( field_type_tensor )
        ! reference_fe MUST BE a vector-valued FE
        assert(.false.)
     end select

     own_dofs = this%reference_fe%own_dofs_n_face%create_iterator(vef_lid)
     ! Integrate edge boundary moments int_edge(g·tau q), q \in P_k-1
     do qpoint = 1, num_quad_points
        factor = this%edge_map%get_det_jacobian(qpoint) * this%edge_quadrature%get_weight(qpoint)
        call this%edge_map%get_tangent(qpoint, tangent)								
        call own_dofs%begin() 
        do ishape = 1, this%edge_interpolation%num_shape_functions 
           idof = own_dofs%get_current() 
           call this%fe_1D%get_value(this%edge_interpolation, ishape, qpoint, shape_test)
           dof_values(idof) = dof_values(idof) + 1.0_rp / tangent%nrm2() * this%edge_function_values(qpoint) * shape_test * tangent * factor 
           call own_dofs%next() 
        end do
     end do

  elseif ( this%reference_fe%get_n_face_dim(vef_lid) == 2 ) then 

     if ( this%num_dims == 3 .and. this%order > 1 ) then

					   ! Get face map coordinates
        num_quad_points  =  this%facet_quadrature%get_num_quadrature_points()
        facet_map_coordinates   => this%facet_map%get_coordinates()

        ! Extract coordinates of the vertices within the face
        vertex_within_facet_id = 1
        vertex_iterator = this%reference_fe%vertices_n_face%create_iterator(vef_lid)
        do while ( .not. vertex_iterator%is_upper_bound () )
           vertex_within_cell_id = vertex_iterator%get_current()
											call facet_map_coordinates(vertex_within_facet_id)%init( this%cell_coordinates(vertex_within_cell_id)%get_value() )
           call vertex_iterator%next()
           vertex_within_facet_id = vertex_within_facet_id + 1
        end do

        ! Update facet_map on current face
        facet_lid = vef_lid - this%d_fe_geo%get_first_facet_id()+1
        call this%facet_map%update(reorientation_factor   = this%d_fe_geo%get_normal_orientation_factor(facet_lid), &
                                   quadrature             = this%facet_quadrature ) 

        ! Extract quadrature points coordinates 
        quad_points_coordinates => this%facet_map%get_quadrature_points_coordinates()

        ! Fill vector function values restricted to face 
        select case(this%reference_fe%get_field_type())
        case ( field_type_scalar )
           ! reference_fe MUST BE a vector-valued FE
           assert (.false.)
        case ( field_type_vector )
           do icomp=1, this%reference_fe%get_num_field_components()
              if(present(time)) then
                 call function_scalar_components(icomp)%p%get_values_set_space_time(quad_points_coordinates,time_,this%scalar_function_values_on_facet(1:num_quad_points,:))
              else
                 call function_scalar_components(icomp)%p%get_values_set_space(quad_points_coordinates,this%scalar_function_values_on_facet(1:num_quad_points,1))
              end if
              do qpoint = 1, num_quad_points
                 call this%facet_function_values(qpoint)%set(icomp,this%scalar_function_values_on_facet(qpoint,1))
              end do
           end do
        case ( field_type_tensor )
           ! reference_fe MUST BE a vector-valued FE
           assert(.false.)
        end select

        ! Integrate face boundary moments int_Face(g x n q), q \in Q_k-2,k-1 x Q_k-1,k-2
        do qpoint = 1, this%facet_quadrature%num_quadrature_points
           factor = this%facet_map%get_det_jacobian(qpoint) * this%facet_quadrature%get_weight(qpoint)
           call this%facet_map%get_normal(qpoint, normal)

           !! IMPORTANT NOTE: trick to have normals associated to each pair of faces pointing
           !!                 to the same direction. This only works provided we have an "oriented"
           !!                 triangulation.
           normal = (-1.0_rp)**(this%reference_fe%orientation%a(vef_lid)) * normal

           ! Compute g x n
           call cross_product_function_normal%init(0.0_rp) 
           cross_product_function_normal = cross_product(this%facet_function_values(qpoint),normal)

           ! Multiply the transpose of the jacobian with normalized columns by g x n
           ! This is required to transform g x n in a vector contained within the face
           call cross_product_function_normal_proj%init(0.0_rp)
           do i=1,this%num_dims-1
              call this%facet_map%get_jacobian_column(i,qpoint,col_jacobian)
              col_jacobian = col_jacobian * (1.0_rp/col_jacobian%nrm2())
              call cross_product_function_normal_proj%set(i, col_jacobian*cross_product_function_normal)
           end do

           ! Apply face_map to v_shape_test 
           own_dofs = this%reference_fe%own_dofs_n_face%create_iterator(vef_lid)
           do ishape=1, this%facet_interpolation%num_shape_functions
              idof = own_dofs%get_current() 
              call this%fe_2D%get_value(this%facet_interpolation, ishape, qpoint, v_shape_test)    
              ! WARNING: Update 2D interpolation for the Nedelec test functions ( J**{-T} will only work in HEX structured meshes! )
              do i=1, this%num_dims-1
                 call this%facet_map%get_jacobian_column(i,qpoint,col_jacobian)
                 call v_shape_test%set(i, v_shape_test%get(i)/col_jacobian%nrm2() )
              end do

              dof_values(idof) = dof_values(idof) + cross_product_function_normal_proj * v_shape_test * factor
              call own_dofs%next() 
           end do
        end do

     end if
  end if

end subroutine hex_Hcurl_projector_evaluate_boundary_function_moments

! ================================================================================
subroutine hex_Hcurl_projector_free( this ) 
  implicit none
  class(hex_Hcurl_projector_t)   , intent(inout) :: this
  integer(ip) :: istat 

  call this%reference_fe%free() 
  call this%d_fe_geo%free()
 
  ! Edge related data  
  call this%fe_1D%free()
  call this%edge_quadrature%free() 
  call this%edge_map%free() 
  call this%edge_interpolation%free()  

  ! Face related data  
  call this%fe_2D%free()
  call this%facet_quadrature%free() 
  call this%facet_map%free() 
  call this%facet_interpolation%free() 

  ! Element related data  
  call this%fe%free()
  call this%cell_quadrature%free() 
  call this%cell_map%free() 
  call this%cell_interpolation%free() 

  ! Functions evaluations
  if ( allocated(this%edge_function_values))  deallocate( this%edge_function_values , stat=istat); check(istat==0) 
  if ( allocated(this%facet_function_values)) deallocate( this%facet_function_values , stat=istat); check(istat==0) 
  if ( allocated(this%cell_function_values))  deallocate( this%cell_function_values , stat=istat); check(istat==0) 
		
		if ( allocated(this%scalar_function_values_on_edge) )  call memfree( this%scalar_function_values_on_edge, __FILE__, __LINE__ ) 
		if ( allocated(this%scalar_function_values_on_facet) ) call memfree( this%scalar_function_values_on_facet, __FILE__, __LINE__ )

end subroutine hex_Hcurl_projector_free
