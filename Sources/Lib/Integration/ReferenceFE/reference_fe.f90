! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
module reference_fe_names
  use allocatable_array_ip1_names
  use allocatable_array_ip2_names
  use field_names
  use types_names
  use list_types_names
  use memor_names
  use sort_names
  use polynomial_names
  
#ifdef ENABLE_BLAS
 use blas77_interfaces_names
#endif
  
#ifdef ENABLE_LAPACK   
 use lapack77_interfaces_names
#endif  
  
  
  implicit none
# include "debug.i90"

  private

  ! This module includes all the reference FE related machinery that is required
  ! to integrate FE schemes. It includes the following types:
  !
  ! * reference_fe_t: the basic reference_fe object, which is an abstract type
  ! * lagrangian_reference_fe_t: an intermediate abstract class 
  ! * hex_lagrangian_reference_fe_t: one particular concrete version of the 
  !   lagrangian_reference_fe_t for quadrilaterals and hexahedra
  ! * hex_lagrangian_reference_fe_t: one particular concrete version of the 
  !   lagrangian_reference_fe_t for triangles and tetrahedra
  ! * quadrature_t: Set of points and weights to perform numerical integration.
  !   It is created by the concrete reference_fe_t by providing the maximum order
  !   to be integrated exactly for zero order terms, e.g., mass matrix
  ! * interpolation_t: The value of the reference FE shape functions (first and second
  !   order derivatives) on the quadrature points. It is generated by a concrete 
  !   reference_fe_t and a quadrature_t. It is computed in the concrete reference_fe_t
  ! * cell_map_t: It provides the mapping from a physical FE to the reference FE
  !   (jacobian, etc.)
  ! * cell_integrator_t: It aggregates all the aforementioned structures to be
  !   used in the FE element integration subroutine. In particular, one 
  !   reference_fe_t for the unknowns and one for the geometry (for non-isoparametric
  !   cases), one quadrature, and the corresponding interpolation. Further, it 
  !   includes the physical FE to the reference one in a cell_map_t and the
  !   composition of the FE map and the interpolation, to provide derivatives in the
  !   physical space

  type quadrature_t
     !private
     integer(ip)           ::   &
          num_dims,    &
          num_quadrature_points
     real(rp), allocatable :: &
          coordinates(:,:),   &   
          weight(:)                         
   contains
     procedure, non_overridable :: create                         => quadrature_create
     procedure, non_overridable :: free                           => quadrature_free
     procedure, non_overridable :: print                          => quadrature_print
     procedure, non_overridable :: get_num_dims                   => quadrature_get_num_dims
     procedure, non_overridable :: get_num_quadrature_points      => quadrature_get_num_quadrature_points
     procedure, non_overridable :: get_coordinates                => quadrature_get_coordinates
     procedure, non_overridable :: get_coordinates_as_points      => quadrature_get_coordinates_as_points
     procedure, non_overridable :: get_weight                     => quadrature_get_weight
     procedure, non_overridable :: get_weights                    => quadrature_get_weights
     procedure, non_overridable :: get_pointer_weights            => quadrature_get_pointer_weights

     procedure, non_overridable          :: fill_tet_gauss_legendre            => quadrature_fill_tet_gauss_legendre
     procedure, non_overridable, private :: fill_tet_gauss_legendre_hard_coded => quadrature_fill_tet_gauss_legendre_symmetric_hard_coded
     procedure, non_overridable          :: fill_hex_gauss_legendre            => quadrature_fill_hex_gauss_legendre
  end type quadrature_t

  interface assignment(=)
     module procedure assign_quadrature, assign_quadrature_array
  end interface assignment(=)

  type p_quadrature_t
     type(quadrature_t), pointer :: p => NULL()
   contains
     procedure :: allocate => p_quadrature_allocate
     procedure :: free     => p_quadrature_free
  end type p_quadrature_t

  ! Types
  public :: quadrature_t, p_quadrature_t

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#define duties interpolation_duties
#define task_01 compute_first_derivatives
#define task_02 compute_second_derivatives
#include "duties_header.i90"

  type interpolation_t
     private
     type(interpolation_duties_t)   :: my_duties
     integer(ip)                    :: &
          num_dims = 0              ,  &      
          num_shape_functions = 0   ,  &      
          num_quadrature_points = 0 ,  &      
          num_entries_symmetric_tensor = 0
     real(rp), allocatable        ::   &
          shape_functions(:,:,:),      &   
          shape_derivatives(:,:,:,:),  &   
          hessian(:,:,:,:)     
   contains
     procedure, non_overridable :: create => interpolation_create
     procedure, non_overridable :: free   => interpolation_free
     procedure, non_overridable :: copy   => interpolation_copy
     procedure, non_overridable :: clone  => interpolation_clone
     procedure, non_overridable :: print  => interpolation_print
     procedure, non_overridable, private :: is_needed_to_allocate => interpolation_is_needed_to_allocate
  end type interpolation_t

  public :: interpolation_t, interpolation_duties_t

  type base_map_t
    private

    integer(ip)                 :: num_dims
    integer(ip)                 :: num_nodes
    integer(ip)                 :: num_quadrature_points
    
    ! Map's Jacobian (SPACE_DIM,SPACE_DIM,num_quadrature_points)
    real(rp), allocatable       :: jacobian(:,:,:)

    ! Map's Jacobian det (num_quadrature_points)  
    real(rp), allocatable       :: det_jacobian(:) 

    ! Coordinates of git points (SPACE_DIM,num_quadrature_points)
    type(point_t), allocatable  :: quadrature_points_coordinates(:)  
    
    ! Coordinates of evaluation points (SPACE_DIM,num_corners of element/face)
    type(point_t), allocatable  :: nodes_coordinates(:) 
    
    ! Geometry interpolation_t in the reference element domain    
    type(interpolation_t)       :: interpolation   
    
    ! Characteristic length of the reference element
    real(rp)                    :: reference_fe_characteristic_length
    
    ! Measure of the map of the real element 
    real(rp)                    :: measure 
  contains
    procedure                  :: free                                  => base_map_free
    procedure, non_overridable :: copy                                  => base_map_copy
    procedure                  :: update_interpolation                  => base_map_update_interpolation
    procedure, non_overridable :: get_coordinates                       => base_map_get_coordinates
    procedure, non_overridable :: get_quadrature_points_coordinates     => base_map_get_quadrature_points_coordinates
    procedure, non_overridable :: compute_quadrature_points_coordinates => base_map_compute_quadrature_points_coordinates
    procedure, non_overridable :: compute_jacobian                      => base_map_compute_jacobian
    procedure, non_overridable :: get_det_jacobian                      => base_map_get_det_jacobian
    procedure, non_overridable :: get_det_jacobians                     => base_map_get_det_jacobians
    procedure, non_overridable :: get_pointer_det_jacobians             => base_map_get_pointer_det_jacobians
    procedure, non_overridable :: get_jacobian_column                   => base_map_get_jacobian_column
    procedure, non_overridable :: get_reference_h                       => base_map_get_reference_h
    procedure, non_overridable :: get_measure                           => base_map_get_measure 
  end type base_map_t

#define duties cell_map_duties
#define task_01 compute_jacobian_inverse
#define task_02 compute_jacobian_derivative
#include "duties_header.i90"
  
  ! The type of (exploitable) ressemblance of the current visited cell 
  ! compared to the previous visited one in a loop over all cells
  ! The sort of ressemblance does not allow us to exploit anything
  integer(ip), parameter :: no_ressemblance          = 0
  integer(ip), parameter :: is_only_translated       = 1
  integer(ip), parameter :: is_scaled_and_translated = 2
  ! Anything else we would like to exploit?

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type, extends(base_map_t) ::  cell_map_t
     private
     type(cell_map_duties_t)  :: my_duties
     ! Map's Jacobian inverse (SPACE_DIM,SPACE_DIM,num_quadrature_points)
     real(rp), allocatable    :: inv_jacobian(:,:,:)     
 
     ! Map's 2nd derivatives (num_dime,num_dime,num_dime,num_quadrature_points)         
     integer(ip)           :: num_entries_symmetric_tensor
     real(rp), allocatable :: d2sdx(:,:,:,:)
     ! and temporary arrays to update them
     real(rp), allocatable :: wmat1(:,:,:)
     real(rp), allocatable :: wmat2(:,:,:), wvec1(:)

     ! Map's Jacobian sign
     logical                  :: det_jacobian_positiveness
   contains
     procedure, non_overridable :: create                            => cell_map_create
     procedure, non_overridable :: restricted_to_edget               => cell_map_restricted_to_edget
     procedure, non_overridable :: restricted_to_facet               => cell_map_restricted_to_facet
     procedure                  :: free                              => cell_map_free
     procedure, non_overridable :: update                            => cell_map_update
     procedure, non_overridable :: update_interpolation_restricted_to_facet => cell_map_update_interpolation_restricted_to_facet
     procedure, non_overridable :: print                             => cell_map_print
     procedure, non_overridable :: compute_h                         => cell_map_compute_h
     procedure, non_overridable :: compute_h_min                     => cell_map_compute_h_min
     procedure, non_overridable :: compute_h_max                     => cell_map_compute_h_max
     procedure, non_overridable :: get_inv_jacobian_tensor           => cell_map_get_inv_jacobian_tensor
     procedure, non_overridable :: apply_jacobian                    => cell_map_apply_jacobian
     procedure, non_overridable :: apply_inv_jacobian                => cell_map_apply_inv_jacobian
     procedure, non_overridable :: apply_transposed_inv_jacobian     => cell_map_apply_transposed_inv_jacobian
     procedure, non_overridable :: is_det_jacobian_positive          => cell_map_is_det_jacobian_positive
  end type cell_map_t
  
  interface assignment(=)
     module procedure assign_cell_map, assign_cell_map_array
  end interface assignment(=)

  ! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type, extends(base_map_t) ::  facet_map_t
     private
     ! Vector normals outside the face (only allocated when using cell_map to integrate on faces) 
     real(rp), allocatable    :: normals(:,:)
   contains
     procedure, non_overridable :: create            => facet_map_create
     procedure, non_overridable :: update            => facet_map_update
     procedure                  :: update_interpolation => facet_map_update_interpolation
     procedure                  :: free              => facet_map_free
     procedure, non_overridable :: get_normal        => facet_map_get_normal
     procedure, non_overridable :: get_raw_normals   => facet_map_get_raw_normals
     procedure, non_overridable :: update_coordinates => facet_map_update_coordinates 
  end type facet_map_t
  
  interface assignment(=)
     module procedure assign_facet_map, assign_facet_map_array
  end interface assignment(=)
  
  ! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type, extends(base_map_t) ::  edge_map_t
     private
     ! Vector tangents to edges. Vector tangents to edges are required e.g. 
     ! by type(hex_nedelec_reference_fe_t) on the reference cell.
     real(rp), allocatable    :: tangents(:,:) 
   contains
     procedure, non_overridable :: create       => edge_map_create
     procedure, non_overridable :: update       => edge_map_update
     procedure                  :: free         => edge_map_free
     procedure, non_overridable :: get_tangent  => edge_map_get_tangent
     procedure, non_overridable :: update_coordinates => edge_map_update_coordinates 
  end type edge_map_t
  
  type p_cell_map_t
     class(cell_map_t), pointer :: p => NULL()   
   contains
     procedure :: allocate => p_cell_map_allocate
     procedure :: free     => p_cell_map_free
  end type p_cell_map_t

  public :: cell_map_t, facet_map_t, edge_map_t, p_cell_map_t
  public :: cell_map_duties_t
  public :: no_ressemblance, is_only_translated, is_scaled_and_translated

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   type cell_map_edget_restriction_t
     private
     integer(ip)                 :: num_edgets = 0
     integer(ip)                 :: current_edget_lid
     type(cell_map_t), allocatable :: cell_map(:)
   contains
     procedure, non_overridable :: create               => cell_map_edget_restriction_create
     procedure, non_overridable :: update               => cell_map_edget_restriction_update
     procedure, non_overridable :: free                 => cell_map_edget_restriction_free
     procedure, non_overridable :: copy                 => cell_map_edget_restriction_copy
     procedure, non_overridable :: get_coordinates      => cell_map_edget_restriction_get_coordinates
     procedure, non_overridable :: get_current_cell_map => cell_map_edget_restriction_get_current_cell_map 
  end type cell_map_edget_restriction_t
  
  public :: cell_map_edget_restriction_t
  
  type cell_map_facet_restriction_t
     private
     integer(ip)                 :: num_facets = 0
     integer(ip)                 :: num_subfacets = 0
     integer(ip)                 :: current_facet_lid
     integer(ip)                 :: current_subfacet_lid
     type(cell_map_t), allocatable :: cell_map(:)
   contains
     procedure, non_overridable :: create               => cell_map_facet_restriction_create
     procedure, non_overridable :: update               => cell_map_facet_restriction_update
     procedure, non_overridable :: update_interpolation => cell_map_facet_restriction_update_interpolation
     procedure, non_overridable :: free                 => cell_map_facet_restriction_free
     procedure, non_overridable :: copy                 => cell_map_facet_restriction_copy
     procedure, non_overridable :: get_coordinates      => cell_map_facet_restriction_get_coordinates
     procedure, non_overridable :: get_current_cell_map => cell_map_facet_restriction_get_current_cell_map 
  end type cell_map_facet_restriction_t
  
  public :: cell_map_facet_restriction_t

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
  type polytope_t
     private
     integer(ip)              :: num_dims
     integer(ip)              :: topology
     integer(ip)              :: root
     integer(ip)              :: num_n_faces 
     integer(ip), allocatable :: n_face_array(:)     
     integer(ip), allocatable :: ijk_to_index(:)
   contains
     procedure          :: create                   => polytope_create 
     procedure          :: create_facet_iterator    => polytope_create_facet_iterator
     procedure          :: get_n_face               => polytope_get_n_face
     procedure          :: get_n_face_dim           => polytope_get_n_face_dim
     procedure          :: n_face_type              => polytope_n_face_type
     procedure          :: n_face_dir_is_fixed      => polytope_n_face_dir_is_fixed 
     procedure          :: n_face_dir_coordinate    => polytope_n_face_dir_coordinate
     procedure          :: n_face_coordinate        => polytope_n_face_coordinate
     procedure          :: get_num_n_faces          => polytope_get_num_n_faces
     procedure          :: get_ijk_to_index         => polytope_get_ijk_to_index
     procedure          :: print                    => polytope_print
     procedure          :: free                     => polytope_free
     procedure, private :: fill_polytope_chain 
  end type polytope_t

  public :: polytope_t

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type node_array_t
     private
     type(polytope_t), pointer :: polytope
     integer(ip)                    :: order(SPACE_DIM)
     integer(ip)                    :: num_nodes
     integer(ip), allocatable       :: node_array(:)
     integer(ip), allocatable       :: ijk_to_index(:)
     integer(ip), allocatable       :: coordinates(:,:)
   contains
     procedure                  :: create                            => node_array_create
     procedure                  :: print                             => node_array_print
     procedure                  :: free                              => node_array_free
     procedure        , private :: create_node_iterator_on_n_face    => node_array_create_node_iterator_on_n_face
     procedure        , private :: create_node_iterator_on_n_subface => node_array_create_node_iterator_on_n_subface
     generic                    :: create_node_iterator              => create_node_iterator_on_n_face, &
                                                                        create_node_iterator_on_n_subface 
     procedure                  :: get_num_nodes                  => node_array_get_num_nodes
     procedure        , private :: fill                              => node_array_fill
     procedure, nopass, private :: fill_permutations                 => node_array_fill_permutations
     procedure, nopass, private :: compute_num_rot_and_perm          => node_array_compute_num_rot_and_perm
  end type node_array_t

  public :: node_array_t

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type facet_iterator_t
     private 
     type(polytope_t), pointer :: polytope
     integer(ip)                  :: root
     integer(ip)                  :: component
     integer(ip)                  :: coordinate
   contains
     procedure :: create        => facet_iterator_create     
     procedure :: current       => facet_iterator_current
     procedure :: init          => facet_iterator_init
     procedure :: next          => facet_iterator_next
     procedure :: has_finished  => facet_iterator_has_finished
     procedure :: print         => facet_iterator_print
     procedure, private :: current_ijk   => facet_iterator_current_ijk 
     procedure, private :: is_admissible => facet_iterator_is_admissible   
  end type facet_iterator_t

  public :: facet_iterator_t

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type node_iterator_t
     private 
     type(node_array_t), pointer :: node_array
     logical                     :: own_boundary
     integer(ip)                 :: n_face
     integer(ip)                 :: topology
     integer(ip)                 :: displacement(0:SPACE_DIM-1)
     integer(ip)                 :: coordinate(0:SPACE_DIM-1)
     logical                     :: overflow
     integer(ip)                 :: min_value(0:SPACE_DIM-1) ! 0 or 1
     integer(ip)                 :: max_value(0:SPACE_DIM-1) ! order or order-1
   contains
     procedure, private :: create_on_n_face    => node_iterator_create_on_n_face
     procedure, private :: create_on_n_subface => node_iterator_create_on_n_subface   
     generic            :: create              => create_on_n_face, create_on_n_subface     
     procedure          :: current             => node_iterator_current
     procedure          :: init                => node_iterator_init
     procedure          :: next                => node_iterator_next
     procedure          :: has_finished        => node_iterator_has_finished
     !procedure          :: free                => node_iterator_free
     procedure          :: print               => node_iterator_print
     procedure, private :: current_ijk         => node_iterator_current_ijk  
     procedure, private :: in_bound            => node_iterator_in_bound 
  end type node_iterator_t

  public :: node_iterator_t

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  character(*), parameter :: field_type_scalar           = 'scalar'
  character(*), parameter :: field_type_vector           = 'vector'
  character(*), parameter :: field_type_tensor           = 'tensor'
  character(*), parameter :: field_type_symmetric_tensor = 'symmetric_tensor'

  character(*), parameter :: topology_hex = "hex"
  character(*), parameter :: topology_tet = "tet"
  character(*), parameter :: fe_type_lagrangian = "Lagrangian"
  character(*), parameter :: fe_type_raviart_thomas = "Raviart_Thomas"
  character(*), parameter :: fe_type_nedelec = "Nedelec"
  character(*), parameter :: fe_type_void = "Void"


  ! Abstract reference_fe
  type, abstract ::  reference_fe_t
     private
     character(:), allocatable :: &
          topology,               &    ! topology of element, 'tet', 'quad', 'prism', ...
          fe_type,                &    ! 'Lagrangian', 'RT', ...
          field_type                   ! 'scalar', 'vector', 'tensor', 'symmetric_tensor'

     integer(ip)              ::    &        
          num_dims,        &
          order,                    &
          num_field_components

     logical                  ::    &
          conformity,           &      ! Is the discrete space of functions conforming with its continuous counterpart?
          continuity                   ! Does the infinite-dimensional functional space include discontinuous functions?  

     integer(ip)              ::    &
          num_n_faces,              &        
          num_shape_functions,             &        
          ptr_n_faces_x_dim(SPACE_DIM+2)

     type(polytope_t)              :: polytope
     type(node_array_t)            :: node_array
     type(node_array_t)            :: vertex_array
     type(allocatable_array_ip1_t)  :: orientation      ! orientation of the n-faces 
     type(list_t)                   :: vertices_n_face  ! vertices per n-face
     type(list_t)                   :: facets_n_face    ! all facets per n-face
     type(list_t)                   :: n_faces_n_face   ! all n-faces per n-face
     type(list_t)                   :: dofs_n_face      ! all DoFs per n-face
     type(list_t)                   :: own_dofs_n_face  ! owned DoFs per n-face

     integer(ip), allocatable :: num_rotations_x_dim(:)
     integer(ip), allocatable :: num_orientations_x_dim(:)
     type(allocatable_array_ip2_t), allocatable :: own_dof_permutations(:)
     
     type(interpolation_t)    :: h_refinement_interpolation
     integer(ip), allocatable :: h_refinement_subfacet_permutation(:,:,:)
     integer(ip), allocatable :: h_refinement_subedge_permutation(:,:,:)
   contains
     ! TBPs
     ! Fill topology, fe_type, num_dims, order, continuity                                                              
     procedure(create_interface), private, deferred :: create 
     ! TBP to create a quadrature for a reference_fe_t
     procedure(create_quadrature_interface)             , deferred :: create_quadrature
     procedure(create_facet_quadrature_interface)        , deferred :: create_facet_quadrature
     procedure(create_edge_quadrature_interface)        , deferred :: create_edge_quadrature 
     ! TBP to create an interpolation from a quadrature_t and reference_fe_t, 
     ! i.e., the value of the shape functions of the reference element on the quadrature points. 
     procedure(create_interpolation_interface)          , deferred :: create_interpolation 
     procedure(create_interpolation_restricted_to_facet_interface), deferred :: create_interpolation_restricted_to_facet
     procedure(create_interpolation_restricted_to_edget_interface), deferred :: create_interpolation_restricted_to_edget
     procedure(create_facet_interpolation_interface)    , deferred :: create_facet_interpolation
     procedure(create_edget_interpolation_interface)    , deferred :: create_edget_interpolation
     procedure(assign_cell_map_duties_interface)        , deferred :: assign_cell_map_duties
     procedure(apply_cell_map_interface)                , deferred :: apply_cell_map
     procedure(get_component_node_interface)            , deferred :: get_component_node
     procedure(get_scalar_from_vector_node_interface)   , deferred :: get_scalar_from_vector_node
     
     ! Returns the maximum order among the orders of the polynomial spaces associated to the components of the FE space
     procedure(get_max_order_interface)                 , deferred :: get_max_order

     procedure(get_value_scalar_interface)              , deferred :: get_value_scalar
     procedure(get_value_vector_interface)              , deferred :: get_value_vector
     !procedure(get_value_tensor_interface)             , deferred :: get_value_tensor           ! Pending
     !procedure(get_value_symmetric_tensor_interface)   , deferred :: get_value_symmetric_tensor ! Pending_vec
     generic :: get_value => get_value_scalar,get_value_vector!                                      &
     !          &                !,get_value_tensor,get_value_symmetric_tensor
     
     procedure(get_values_scalar_interface)              , deferred :: get_values_scalar
     procedure(get_values_vector_interface)              , deferred :: get_values_vector
     !procedure(get_value_tensor_interface)             , deferred :: get_value_tensor           ! Pending
     !procedure(get_value_symmetric_tensor_interface)   , deferred :: get_value_symmetric_tensor ! Pending
     generic :: get_values => get_values_scalar,get_values_vector!                                      &
     !          &                !,get_value_tensor,get_value_symmetric_tensor

     procedure(get_gradient_scalar_interface)          , deferred :: get_gradient_scalar
     procedure(get_gradient_vector_interface)          , deferred :: get_gradient_vector
     !procedure(get_gradient_tensor_interface)          , deferred :: get_gradient_tensor ! Pending
     generic :: get_gradient => get_gradient_scalar,get_gradient_vector!                             &
     !          &                   !,get_value_tensor,get_value_symmetric_tensor
     
     procedure(get_gradients_scalar_interface)          , deferred :: get_gradients_scalar
     procedure(get_gradients_vector_interface)          , deferred :: get_gradients_vector
     !procedure(get_gradient_tensor_interface)          , deferred :: get_gradient_tensor ! Pending
     generic :: get_gradients => get_gradients_scalar, get_gradients_vector!                             &
     !          &                   !,get_value_tensor,get_value_symmetric_tensor
     

     !procedure(get_symmetric_gradient_vector_interface), deferred :: get_symmetric_gradient_vector ! Pending
     !generic :: get_symmetric_gradient => get_symmetric_gradient_scalar

     procedure(get_divergence_vector_interface)        , deferred :: get_divergence_vector
     !  procedure(get_divergence_tensor_interface)        , deferred :: get_divergence_tensor ! Pending
     generic :: get_divergence => get_divergence_vector !, get_divergence_tensor
     
     procedure(get_divergences_vector_interface)        , deferred :: get_divergences_vector
     !  procedure(get_divergence_tensor_interface)        , deferred :: get_divergence_tensor ! Pending
     generic :: get_divergences => get_divergences_vector !, get_divergence_tensor

     procedure(get_curl_vector_interface)              , deferred :: get_curl_vector
     generic :: get_curl => get_curl_vector
     
     procedure(get_curls_vector_interface)              , deferred :: get_curls_vector
     generic :: get_curls => get_curls_vector

     procedure(get_laplacian_scalar_interface)       , deferred :: get_laplacian_scalar
     procedure(get_laplacian_vector_interface)       , deferred :: get_laplacian_vector
     generic :: get_laplacian => get_laplacian_scalar, get_laplacian_vector

     procedure(get_laplacians_scalar_interface)       , deferred :: get_laplacians_scalar
     procedure(get_laplacians_vector_interface)       , deferred :: get_laplacians_vector
     generic :: get_laplacians => get_laplacians_scalar, get_laplacians_vector

     procedure(evaluate_fe_function_scalar_interface), deferred :: evaluate_fe_function_scalar
     procedure(evaluate_fe_function_vector_interface), deferred :: evaluate_fe_function_vector
     procedure(evaluate_fe_function_tensor_interface), deferred :: evaluate_fe_function_tensor
     generic :: evaluate_fe_function => evaluate_fe_function_scalar, &
          & evaluate_fe_function_vector, &
          & evaluate_fe_function_tensor

     procedure(evaluate_gradient_fe_function_scalar_interface), deferred :: evaluate_gradient_fe_function_scalar
     procedure(evaluate_gradient_fe_function_vector_interface), deferred :: evaluate_gradient_fe_function_vector
     generic :: evaluate_gradient_fe_function => evaluate_gradient_fe_function_scalar, &
          & evaluate_gradient_fe_function_vector

     procedure(evaluate_laplacian_fe_function_scalar_interface), deferred :: evaluate_laplacian_fe_function_scalar
     procedure(evaluate_laplacian_fe_function_vector_interface), deferred :: evaluate_laplacian_fe_function_vector
     generic :: evaluate_laplacian_fe_function => evaluate_laplacian_fe_function_scalar, &
          & evaluate_laplacian_fe_function_vector

     procedure (check_compatibility_of_n_faces_interface), deferred :: &
          &     check_compatibility_of_n_faces
     procedure (get_characteristic_length_interface) , deferred :: get_characteristic_length
     
     procedure(generate_own_dofs_cell_permutations_interface), deferred :: generate_own_dofs_cell_permutations
     procedure(fill_qpoints_permutations_interface), deferred :: fill_qpoints_permutations
     procedure(get_default_quadrature_degree_interface), deferred :: get_default_quadrature_degree 
     procedure (create_data_out_quadrature_interface), deferred :: create_data_out_quadrature 
     procedure (get_num_subcells_interface      )    , deferred :: get_num_subcells
     procedure (get_subcells_connectivity_interface) , deferred :: get_subcells_connectivity
     
     procedure (get_h_refinement_coefficient_interface)          , deferred :: get_h_refinement_coefficient 
     procedure (interpolate_nodal_values_on_subcell_interface)   , deferred :: interpolate_nodal_values_on_subcell 
     procedure (project_nodal_values_on_cell_interface)          , deferred :: project_nodal_values_on_cell
     
     ! generic part of the subroutine above
     procedure :: free  => reference_fe_free
     procedure :: print => reference_fe_print

     ! Set num_dims, order, continuity, field_type, num_field_components
     procedure :: set_common_data => reference_fe_set_common_data
     procedure :: set_topology => reference_fe_set_topology
     procedure :: set_fe_type => reference_fe_set_fe_type

     ! Getters
     procedure :: get_topology => reference_fe_get_topology
     procedure :: get_fe_type => reference_fe_get_fe_type
     procedure :: get_field_type => reference_fe_get_field_type
     procedure :: get_num_dims => reference_fe_get_num_dims
     procedure :: get_order => reference_fe_get_order
     procedure :: get_continuity => reference_fe_get_continuity
     procedure :: get_conformity => reference_fe_get_conformity
     procedure :: get_num_field_components => reference_fe_get_num_field_components
     procedure :: get_num_n_faces => reference_fe_get_num_n_faces
     procedure :: get_num_vertices => reference_fe_get_num_vertices
     !procedure :: get_first_vertex_id => reference_fe_get_first_vertex_id
     !procedure :: get_num_vertices_x_edge => reference_fe_get_num_vertices_x_edge
     !procedure :: get_num_vertices_x_face => reference_fe_get_num_vertices_x_face
     procedure :: get_num_edgets => reference_fe_get_num_edgets
     !procedure :: get_first_edge_id => reference_fe_get_first_edge_id
     procedure :: get_num_facets => reference_fe_get_num_facets
     procedure :: get_first_facet_id => reference_fe_get_first_facet_id
     procedure :: get_num_n_faces_of_dim  => reference_fe_get_num_n_faces_of_dim
     procedure :: get_first_n_face_id_of_dim => reference_fe_get_first_n_face_id_of_dim 
     procedure :: get_num_shape_functions => reference_fe_get_num_shape_functions
     procedure :: get_n_face_dim  => reference_fe_get_n_face_dim
     procedure :: get_vertices_n_face  =>   reference_fe_get_vertices_n_face
     procedure :: get_n_faces_n_face  => reference_fe_get_n_faces_n_face
     procedure :: create_vertices_n_face_iterator => reference_fe_create_vertices_n_face_iterator
     procedure :: create_n_faces_n_face_iterator  => reference_fe_create_n_faces_n_face_iterator
     procedure :: create_dofs_n_face_iterator => reference_fe_create_dofs_n_face_iterator
     procedure :: get_dofs_n_face => reference_fe_get_dofs_n_face
     procedure :: get_own_dofs_n_face =>  reference_fe_get_own_dofs_n_face
                    
     procedure :: get_facets_n_face   =>   reference_fe_get_facets_n_face
     procedure :: get_num_vertices_n_face => reference_fe_get_num_vertices_n_face
     procedure :: get_num_dofs_on_n_face => reference_fe_get_num_dofs_on_n_face
     procedure :: create_dofs_on_n_face_iterator => reference_fe_create_dofs_on_n_face_iterator

     procedure :: get_num_own_dofs_n_face => reference_fe_get_num_own_dofs_n_face
     procedure :: create_own_dofs_on_n_face_iterator => reference_fe_create_own_dofs_on_n_face_iterator
     procedure :: translate_dof_lid_n_face_to_dof_lid_cell => rfe_translate_dof_lid_n_face_to_dof_lid_cell

     procedure :: has_nodal_quadrature => reference_fe_has_nodal_quadrature
     procedure :: get_nodal_quadrature => reference_fe_get_nodal_quadrature
	 
     procedure :: compute_permutation_index     => reference_fe_compute_permutation_index
     procedure :: permute_dof_LID_n_face        => reference_fe_permute_dof_LID_n_face
     procedure :: get_normal_orientation_factor => reference_fe_get_normal_orientation_factor
     procedure :: get_num_subfacets => reference_fe_get_num_subfacets
     procedure :: get_h_refinement_interpolation => reference_fe_get_h_refinement_interpolation 
     procedure :: get_h_refinement_subedge_permutation => reference_fe_get_h_refinement_subedge_permutation 
     procedure :: get_h_refinement_subfacet_permutation => reference_fe_get_h_refinement_subfacet_permutation 
  end type reference_fe_t

  type p_reference_fe_t
     class(reference_fe_t), pointer :: p => NULL()
   contains
     procedure :: free => p_reference_fe_free
  end type p_reference_fe_t

  abstract interface
     subroutine create_interface ( this, topology, num_dims, order, field_type, &
          conformity, continuity )
       import :: reference_fe_t, ip, SPACE_DIM
       implicit none 
       class(reference_fe_t), intent(inout) :: this 
       character(*)         , intent(in)    :: topology
       integer(ip)          , intent(in)    :: num_dims
       integer(ip)          , intent(in)    :: order
       character(*)         , intent(in)    :: field_type
       logical              , intent(in)    :: conformity
       logical, optional    , intent(in)    :: continuity
     end subroutine create_interface

     subroutine create_quadrature_interface ( this, quadrature, degree )
       import :: reference_fe_t, quadrature_t, ip
       implicit none 
       class(reference_fe_t), intent(in)    :: this
       type(quadrature_t)   , intent(inout) :: quadrature
       integer(ip), optional, intent(in)    :: degree
     end subroutine create_quadrature_interface

     subroutine create_facet_quadrature_interface ( this, quadrature, degree  )
       import :: reference_fe_t, quadrature_t, ip
       implicit none
       class(reference_fe_t), intent(in)    :: this
       type(quadrature_t)   , intent(inout) :: quadrature
       integer(ip), optional, intent(in)    :: degree
     end subroutine create_facet_quadrature_interface
     
     subroutine create_edge_quadrature_interface ( this, quadrature, degree  )
       import :: reference_fe_t, quadrature_t, ip
       implicit none
       class(reference_fe_t), intent(in)    :: this
       type(quadrature_t)   , intent(inout) :: quadrature
       integer(ip), optional, intent(in)    :: degree
     end subroutine create_edge_quadrature_interface

     subroutine create_interpolation_interface ( this, quadrature, interpolation, interpolation_duties )
       import :: reference_fe_t, quadrature_t, interpolation_t, interpolation_duties_t
       implicit none 
       class(reference_fe_t), intent(in)    :: this 
       type(quadrature_t)   , intent(in)    :: quadrature
       type(interpolation_t), intent(inout) :: interpolation
       type(interpolation_duties_t), optional, intent(in) :: interpolation_duties
     end subroutine create_interpolation_interface

     subroutine create_interpolation_restricted_to_facet_interface ( this, facet_lid , subfacet_lid, &
                                                      local_quadrature, facet_interpolation )
       import :: reference_fe_t, ip, quadrature_t, interpolation_t
       implicit none 
       class(reference_fe_t), intent(in)    :: this
       integer(ip)          , intent(in)    :: facet_lid
       integer(ip)          , intent(in)    :: subfacet_lid
       type(quadrature_t)   , intent(in)    :: local_quadrature
       type(interpolation_t), intent(inout) :: facet_interpolation
     end subroutine create_interpolation_restricted_to_facet_interface
     
     subroutine create_interpolation_restricted_to_edget_interface ( this, edget_lid, &
                                                      local_quadrature, edget_interpolation )
       import :: reference_fe_t, ip, quadrature_t, interpolation_t
       implicit none 
       class(reference_fe_t), intent(in)    :: this
       integer(ip)          , intent(in)    :: edget_lid
       type(quadrature_t)   , intent(in)    :: local_quadrature
       type(interpolation_t), intent(inout) :: edget_interpolation
     end subroutine create_interpolation_restricted_to_edget_interface

     subroutine create_facet_interpolation_interface ( this, quadrature, facet_interpolation)
       import :: reference_fe_t, ip, quadrature_t, interpolation_t
       implicit none
       class(reference_fe_t), intent(in)    :: this
       type(quadrature_t)   , intent(in)    :: quadrature
       type(interpolation_t), intent(inout) :: facet_interpolation
     end subroutine create_facet_interpolation_interface
     
     subroutine create_edget_interpolation_interface ( this, quadrature, edget_interpolation)
       import :: reference_fe_t, ip, quadrature_t, interpolation_t
       implicit none
       class(reference_fe_t), intent(in)    :: this
       type(quadrature_t)   , intent(in)    :: quadrature
       type(interpolation_t), intent(inout) :: edget_interpolation
     end subroutine create_edget_interpolation_interface

     function get_component_node_interface( this, node )
       import :: reference_fe_t, ip
       implicit none
       class(reference_fe_t), intent(in) :: this 
       integer(ip)          , intent(in) :: node
       integer(ip) :: get_component_node_interface
     end function get_component_node_interface

     function get_scalar_from_vector_node_interface( this, node )
       import :: reference_fe_t, ip
       implicit none
       class(reference_fe_t), intent(in) :: this 
       integer(ip)          , intent(in) :: node
       integer(ip) :: get_scalar_from_vector_node_interface
     end function get_scalar_from_vector_node_interface

     function get_num_nodes_scalar_interface(this) result(num_nodes_scalar)
       import :: reference_fe_t, ip
       implicit none
       class(reference_fe_t), intent(in) :: this
       integer(ip)                       :: num_nodes_scalar
     end function get_num_nodes_scalar_interface

     function get_max_order_interface( this )
       import :: reference_fe_t, ip
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       integer(ip) :: get_max_order_interface
     end function get_max_order_interface
     
     subroutine get_value_scalar_interface( this, actual_cell_interpolation, ishape, qpoint,        &
          &                                 scalar_field )
       import :: reference_fe_t, interpolation_t, ip, rp
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       integer(ip)          , intent(in)    :: ishape
       integer(ip)          , intent(in)    :: qpoint
       real(rp)             , intent(inout) :: scalar_field
     end subroutine get_value_scalar_interface

     subroutine get_value_vector_interface( this, actual_cell_interpolation, ishape, qpoint,        &
          &                                 vector_field )
       import :: reference_fe_t, interpolation_t, vector_field_t, ip
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       integer(ip)          , intent(in)    :: ishape
       integer(ip)          , intent(in)    :: qpoint
       type(vector_field_t) , intent(inout) :: vector_field
     end subroutine get_value_vector_interface
     
     subroutine get_values_scalar_interface( this, actual_cell_interpolation, values, qpoints_perm )
       import :: reference_fe_t, interpolation_t, rp, ip
       implicit none
       class(reference_fe_t), intent(in)    :: this
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       real(rp), allocatable, intent(inout) :: values(:,:)
       integer(ip), optional, intent(in)    :: qpoints_perm(:)
     end subroutine get_values_scalar_interface

     subroutine get_values_vector_interface( this, actual_cell_interpolation, values, qpoints_perm )
       import :: reference_fe_t, interpolation_t, vector_field_t, ip
       implicit none
       class(reference_fe_t)            , intent(in)    :: this 
       type(interpolation_t)            , intent(in)    :: actual_cell_interpolation 
       type(vector_field_t), allocatable, intent(inout) :: values(:,:)
       integer(ip), optional, intent(in)    :: qpoints_perm(:)
     end subroutine get_values_vector_interface

     subroutine get_gradient_scalar_interface( this, actual_cell_interpolation, ishape, qpoint,     &
          &                                    vector_field )
       import :: reference_fe_t, interpolation_t, vector_field_t, ip
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       integer(ip)          , intent(in)    :: ishape
       integer(ip)          , intent(in)    :: qpoint
       type(vector_field_t) , intent(inout) :: vector_field
     end subroutine get_gradient_scalar_interface

     subroutine get_gradient_vector_interface( this, actual_cell_interpolation, ishape, qpoint,     &
          &                                    tensor_field )
       import :: reference_fe_t, interpolation_t, tensor_field_t, ip
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       integer(ip)          , intent(in)    :: ishape
       integer(ip)          , intent(in)    :: qpoint
       type(tensor_field_t) , intent(inout) :: tensor_field
     end subroutine get_gradient_vector_interface
     
     subroutine get_gradients_scalar_interface( this, actual_cell_interpolation, gradients, qpoints_perm )
       import :: reference_fe_t, interpolation_t, vector_field_t, ip
       implicit none
       class(reference_fe_t)             , intent(in)    :: this 
       type(interpolation_t)             , intent(in)    :: actual_cell_interpolation
       type(vector_field_t) , allocatable, intent(inout) :: gradients(:,:)
       integer(ip)          , optional   , intent(in)    :: qpoints_perm(:)
     end subroutine get_gradients_scalar_interface

     subroutine get_gradients_vector_interface( this, actual_cell_interpolation, gradients, qpoints_perm )
       import :: reference_fe_t, interpolation_t, tensor_field_t, ip
       implicit none
       class(reference_fe_t)             , intent(in)    :: this 
       type(interpolation_t)             , intent(in)    :: actual_cell_interpolation
       type(tensor_field_t) , allocatable, intent(inout) :: gradients(:,:)
       integer(ip)          , optional   , intent(in)    :: qpoints_perm(:)
     end subroutine get_gradients_vector_interface
     
     subroutine get_divergence_vector_interface( this, actual_cell_interpolation, ishape, qpoint,        &
          &                                 scalar_field )
       import :: reference_fe_t, interpolation_t, ip, rp
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       integer(ip)          , intent(in)    :: ishape
       integer(ip)          , intent(in)    :: qpoint
       real(rp)             , intent(inout) :: scalar_field
     end subroutine get_divergence_vector_interface
     
     subroutine get_divergences_vector_interface( this, actual_cell_interpolation, divergences, qpoints_perm  )
       import :: reference_fe_t, interpolation_t, rp, ip
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       real(rp), allocatable, intent(inout) :: divergences(:,:)
       integer(ip), optional, intent(in)    :: qpoints_perm(:)
     end subroutine get_divergences_vector_interface
     
     subroutine get_curl_vector_interface( this, actual_cell_interpolation, ishape, qpoint, vector_field )
       import :: reference_fe_t, interpolation_t, vector_field_t, ip
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation
       integer(ip)          , intent(in)    :: ishape
       integer(ip)          , intent(in)    :: qpoint
       type(vector_field_t) , intent(inout) :: vector_field
     end subroutine get_curl_vector_interface
       
     subroutine get_curls_vector_interface( this, actual_cell_interpolation, curls, qpoints_perm )
       import :: reference_fe_t, interpolation_t, vector_field_t, ip
       implicit none
       class(reference_fe_t)             , intent(in)    :: this 
       type(interpolation_t)             , intent(in)    :: actual_cell_interpolation 
       type(vector_field_t) , allocatable, intent(inout) :: curls(:,:)
       integer(ip)          , optional   , intent(in)    :: qpoints_perm(:)
     end subroutine get_curls_vector_interface

     subroutine get_laplacian_scalar_interface( this, actual_cell_interpolation, ishape, qpoint,        &
          &                                     scalar_field )
       import :: reference_fe_t, interpolation_t, ip, rp
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       integer(ip)          , intent(in)    :: ishape
       integer(ip)          , intent(in)    :: qpoint
       real(rp)             , intent(inout) :: scalar_field
     end subroutine get_laplacian_scalar_interface

     subroutine get_laplacian_vector_interface( this, actual_cell_interpolation, ishape, qpoint,        &
          &                                     vector_field )
       import :: reference_fe_t, interpolation_t, vector_field_t, ip
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       integer(ip)          , intent(in)    :: ishape
       integer(ip)          , intent(in)    :: qpoint
       type(vector_field_t) , intent(inout) :: vector_field
     end subroutine get_laplacian_vector_interface

     subroutine get_laplacians_scalar_interface( this, actual_cell_interpolation, laplacians, qpoints_perm )
       import :: reference_fe_t, interpolation_t, rp, ip
       implicit none
       class(reference_fe_t), intent(in)    :: this
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       real(rp), allocatable, intent(inout) :: laplacians(:,:)
       integer(ip), optional, intent(in)    :: qpoints_perm(:)
     end subroutine get_laplacians_scalar_interface

     subroutine get_laplacians_vector_interface( this, actual_cell_interpolation, laplacians, qpoints_perm )
       import :: reference_fe_t, interpolation_t, vector_field_t, ip
       implicit none
       class(reference_fe_t)            , intent(in)    :: this 
       type(interpolation_t)            , intent(in)    :: actual_cell_interpolation 
       type(vector_field_t), allocatable, intent(inout) :: laplacians(:,:)
       integer(ip), optional, intent(in)    :: qpoints_perm(:)
     end subroutine get_laplacians_vector_interface

     subroutine evaluate_fe_function_scalar_interface( this,                      &
                                                       actual_cell_interpolation, &
                                                       nodal_values,              &
                                                       quadrature_points_values)
       import :: reference_fe_t, interpolation_t, rp
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       real(rp)             , intent(in)    :: nodal_values(:)
       real(rp), allocatable, intent(inout) :: quadrature_points_values(:)
     end subroutine evaluate_fe_function_scalar_interface

     subroutine evaluate_fe_function_vector_interface( this,                      &
          & actual_cell_interpolation, &
          & nodal_values,              &
          & quadrature_points_values)
       import :: reference_fe_t, interpolation_t, rp, vector_field_t
       implicit none
       class(reference_fe_t)            , intent(in)    :: this 
       type(interpolation_t)            , intent(in)    :: actual_cell_interpolation 
       real(rp)                         , intent(in)    :: nodal_values(:)
       type(vector_field_t), allocatable, intent(inout) :: quadrature_points_values(:)
     end subroutine evaluate_fe_function_vector_interface

     subroutine evaluate_fe_function_tensor_interface( this,                      &
          & actual_cell_interpolation, &
          & nodal_values,              &
          & quadrature_points_values)
       import :: reference_fe_t, interpolation_t, rp, tensor_field_t
       implicit none
       class(reference_fe_t)            , intent(in)    :: this 
       type(interpolation_t)            , intent(in)    :: actual_cell_interpolation 
       real(rp)                         , intent(in)    :: nodal_values(:)
       type(tensor_field_t), allocatable, intent(inout) :: quadrature_points_values(:)
     end subroutine evaluate_fe_function_tensor_interface

     subroutine evaluate_gradient_fe_function_scalar_interface( this,             &
          & actual_cell_interpolation, &
          & nodal_values,              &
          & quadrature_points_values)
       import :: reference_fe_t, interpolation_t, rp, vector_field_t
       implicit none
       class(reference_fe_t)             , intent(in)    :: this 
       type(interpolation_t)             , intent(in)    :: actual_cell_interpolation 
       real(rp)                          , intent(in)    :: nodal_values(:)
       type(vector_field_t) , allocatable, intent(inout) :: quadrature_points_values(:)
     end subroutine evaluate_gradient_fe_function_scalar_interface

     subroutine evaluate_gradient_fe_function_vector_interface( this,             &
          & actual_cell_interpolation, &
          & nodal_values,              &
          & quadrature_points_values)
       import :: reference_fe_t, interpolation_t, rp, tensor_field_t
       implicit none
       class(reference_fe_t)             , intent(in)    :: this 
       type(interpolation_t)             , intent(in)    :: actual_cell_interpolation 
       real(rp)                          , intent(in)    :: nodal_values(:)
       type(tensor_field_t) , allocatable, intent(inout) :: quadrature_points_values(:)
     end subroutine evaluate_gradient_fe_function_vector_interface
     
     subroutine evaluate_laplacian_fe_function_scalar_interface( this,                      &
                                                                 actual_cell_interpolation, &
                                                                 nodal_values,              &
                                                                 quadrature_points_values)
       import :: reference_fe_t, interpolation_t, rp
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       real(rp)             , intent(in)    :: nodal_values(:)
       real(rp), allocatable, intent(inout) :: quadrature_points_values(:)
     end subroutine evaluate_laplacian_fe_function_scalar_interface

     subroutine evaluate_laplacian_fe_function_vector_interface( this,                      &
                                                               & actual_cell_interpolation, &
                                                               & nodal_values,              &
                                                               & quadrature_points_values)
       import :: reference_fe_t, interpolation_t, rp, vector_field_t
       implicit none
       class(reference_fe_t)            , intent(in)    :: this 
       type(interpolation_t)            , intent(in)    :: actual_cell_interpolation 
       real(rp)                         , intent(in)    :: nodal_values(:)
       type(vector_field_t), allocatable, intent(inout) :: quadrature_points_values(:)
     end subroutine evaluate_laplacian_fe_function_vector_interface
     
     function check_compatibility_of_n_faces_interface(target_reference_fe, &
          &                       source_reference_fe, source_n_face_id,target_n_face_id)
       import :: reference_fe_t, ip
       implicit none
       class(reference_fe_t), intent(in)    :: target_reference_fe
       class(reference_fe_t), intent(in)    :: source_reference_fe
       integer(ip)          , intent(in)    :: source_n_face_id
       integer(ip)          , intent(in)    :: target_n_face_id 
       logical :: check_compatibility_of_n_faces_interface
     end function  check_compatibility_of_n_faces_interface

     function get_characteristic_length_interface( this)
       import :: reference_fe_t, rp
       implicit none 
       class(reference_fe_t), intent(in) :: this 
       real(rp)  :: get_characteristic_length_interface 
     end function get_characteristic_length_interface

     subroutine assign_cell_map_duties_interface (this, interpolation_duties,cell_map_duties)
        import :: reference_fe_t, interpolation_duties_t, cell_map_duties_t
        class(reference_fe_t)       , intent(in)  :: this 
        type(interpolation_duties_t), intent(in)  :: interpolation_duties
        type(cell_map_duties_t)     , intent(inout) :: cell_map_duties
      end subroutine assign_cell_map_duties_interface

     subroutine apply_cell_map_interface ( this, &
                                           cell_ressemblance, &
                                           cell_map, &
                                           interpolation_reference_cell, &
                                           interpolation_real_cell, &
                                           scaling_factor )
       import :: rp,  ip, reference_fe_t, cell_map_t, interpolation_t
       implicit none 
       class(reference_fe_t), intent(in)    :: this 
       integer(ip)          , intent(in)    :: cell_ressemblance
       type(cell_map_t)     , intent(in)    :: cell_map
       type(interpolation_t), intent(in)    :: interpolation_reference_cell
       type(interpolation_t), intent(inout) :: interpolation_real_cell
       real(rp), optional   , intent(in)    :: scaling_factor
     end subroutine apply_cell_map_interface

     subroutine create_nodal_quadrature_interface ( this )
       import :: reference_fe_t
       implicit none
       class(reference_fe_t), intent(inout) :: this 
     end subroutine create_nodal_quadrature_interface
     
     subroutine generate_own_dofs_cell_permutations_interface (this)
        import :: reference_fe_t
        implicit none
        class(reference_fe_t), intent(inout) :: this 
     end subroutine
     
     subroutine fill_qpoints_permutations_interface (this, quadrature, qpoints_perm)
        import :: reference_fe_t, allocatable_array_ip2_t, quadrature_t
        implicit none
        class(reference_fe_t)        , intent(in)    :: this 
        type(quadrature_t)           , intent(in)    :: quadrature
        type(allocatable_array_ip2_t), intent(inout) :: qpoints_perm
     end subroutine
     
     ! Assuming that no hint comes from the user with respect to the degree of the quadrature to be used,
     ! this deferred binding lets the reference_fe_t implementor to automatically decide
     ! the polynomial degree for which the integral numerically evaluated using the quadrature created by default 
     ! is to be exact (i.e., the quadrature degree)
     function get_default_quadrature_degree_interface(this)
        import :: reference_fe_t, ip
        implicit none
        class(reference_fe_t)        , intent(in)    :: this 
        integer(ip) :: get_default_quadrature_degree_interface
     end function get_default_quadrature_degree_interface
     
     subroutine create_data_out_quadrature_interface ( this, num_refinements, quadrature )
        import :: reference_fe_t, ip, quadrature_t
        implicit none
        class(reference_fe_t), intent(in)    :: this
        integer(ip)                     , intent(in)    :: num_refinements
        type(quadrature_t)              , intent(inout) :: quadrature
     end subroutine create_data_out_quadrature_interface

     function get_num_subcells_interface(this, num_refinements) result(num_subcells)
        import :: reference_fe_t, ip
        implicit none
        class(reference_fe_t), intent(in)    :: this
        integer(ip),                      intent(in)    :: num_refinements
        integer(ip)                                     :: num_subcells
     end function get_num_subcells_interface

     subroutine get_subcells_connectivity_interface(this, num_refinements, connectivity)
        import :: reference_fe_t, ip
        implicit none
        class(reference_fe_t), intent(in)    :: this
        integer(ip),                      intent(in)    :: num_refinements
        integer(ip),                      intent(inout) :: connectivity(:,:)
     end subroutine get_subcells_connectivity_interface
     
     !==================================================================================================
     subroutine get_h_refinement_coefficient_interface ( this, ishape_fe,   & 
                                                         ishape_coarser_fe, & 
                                                         qpoint, coefficient )
       import :: reference_fe_t, ip, rp 
       implicit none 
       class(reference_fe_t), target, intent(in)    :: this
       integer(ip)                  , intent(in)    :: ishape_fe
       integer(ip)                  , intent(in)    :: ishape_coarser_fe
       integer(ip)                  , intent(in)    :: qpoint
       real(rp)                     , intent(inout) :: coefficient
     end subroutine get_h_refinement_coefficient_interface

     subroutine interpolate_nodal_values_on_subcell_interface ( this,                   &
                                                                subcell_id,             &
                                                                nodal_values_on_parent, & 
                                                                nodal_values_on_child )
       import :: reference_fe_t, ip, rp 
       implicit none 
       class(reference_fe_t), intent(in)    :: this              
       integer(ip)          , intent(in)    :: subcell_id
       real(rp)             , intent(in)    :: nodal_values_on_parent(:)
       real(rp)             , intent(inout) :: nodal_values_on_child(:)
     end subroutine interpolate_nodal_values_on_subcell_interface

     subroutine project_nodal_values_on_cell_interface ( this,                     &
                                                         nodal_values_on_children, &
                                                         nodal_values_on_parent )
       import :: reference_fe_t, rp 
       implicit none 
       class(reference_fe_t), intent(in)    :: this  
       real(rp)             , intent(in)    :: nodal_values_on_children(:,:)
       real(rp)             , intent(inout) :: nodal_values_on_parent(:)
     end subroutine project_nodal_values_on_cell_interface
          
  end interface

  public :: reference_fe_t, p_reference_fe_t
  public :: field_type_scalar, field_type_vector, field_type_tensor, field_type_symmetric_tensor
  public :: topology_hex, topology_tet, fe_type_lagrangian, fe_type_raviart_thomas, fe_type_nedelec, fe_type_void

  type p_lagrangian_reference_fe_t
     class(lagrangian_reference_fe_t), pointer :: p => NULL()
   contains
     procedure :: free => p_lagrangian_reference_fe_free
  end type p_lagrangian_reference_fe_t

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type, abstract, extends(reference_fe_t) :: lagrangian_reference_fe_t
  private
  integer(ip)              :: order_vector(SPACE_DIM)
  integer(ip), allocatable :: node_component_array(:,:)
  integer(ip), allocatable :: node_array_component(:,:)
  type(quadrature_t)       :: nodal_quadrature
contains
  ! Additional deferred methods
  procedure (fill_quadrature_interface)             , private, deferred :: fill_quadrature
  procedure (fill_nodal_quadrature_interface)       , private, deferred :: fill_nodal_quadrature
  procedure (fill_interpolation_interface)          , private, deferred :: fill_interpolation
  procedure (fill_interp_restricted_to_facet_interface) , private, deferred :: fill_interp_restricted_to_facet
  procedure (fill_interp_restricted_to_edget_interface) , private, deferred :: fill_interp_restricted_to_edget
  procedure (compute_num_quadrature_points_interface), private, deferred :: compute_num_quadrature_points
  ! Blending function to generate interpolations in the interior (given values on the boundary)
  procedure(blending_interface), deferred :: blending

  procedure :: create                    => lagrangian_reference_fe_create
  procedure :: fill_scalar               => lagrangian_reference_fe_fill_scalar
  procedure :: create_quadrature         => lagrangian_reference_fe_create_quadrature
  procedure :: create_facet_quadrature    => lagrangian_reference_fe_create_facet_quadrature
  procedure :: create_edge_quadrature     => lagrangian_reference_fe_create_edge_quadrature
  procedure :: create_interpolation      => lagrangian_reference_fe_create_interpolation
  procedure :: create_interpolation_restricted_to_facet => lrfe_create_interpolation_restricted_to_facet
  procedure :: create_interpolation_restricted_to_edget => lrfe_create_interpolation_restricted_to_edget 
  procedure :: create_facet_interpolation  => lagrangian_reference_fe_create_facet_interpolation
  procedure :: create_edget_interpolation  => lagrangian_reference_fe_create_edget_interpolation
  procedure :: assign_cell_map_duties      => lagrangian_reference_fe_assign_cell_map_duties
  procedure :: apply_cell_map            => lagrangian_reference_fe_apply_cell_map
  procedure :: get_component_node        => lagrangian_reference_fe_get_component_node
  procedure :: get_scalar_from_vector_node  => lagrangian_reference_fe_get_scalar_from_vector_node
  procedure :: get_max_order             => lagrangian_reference_fe_get_max_order
  procedure :: get_value_scalar          => lagrangian_reference_fe_get_value_scalar
  procedure :: get_value_vector          => lagrangian_reference_fe_get_value_vector
  procedure :: get_values_scalar         => lagrangian_reference_fe_get_values_scalar
  procedure :: get_values_vector         => lagrangian_reference_fe_get_values_vector
  procedure :: get_gradient_scalar       => lagrangian_reference_fe_get_gradient_scalar
  procedure :: get_gradient_vector       => lagrangian_reference_fe_get_gradient_vector
  procedure :: get_gradients_scalar      => lagrangian_reference_fe_get_gradients_scalar
  procedure :: get_gradients_vector      => lagrangian_reference_fe_get_gradients_vector
  procedure :: get_divergence_vector     => lagrangian_reference_fe_get_divergence_vector
  procedure :: get_divergences_vector    => lagrangian_reference_fe_get_divergences_vector
  procedure :: get_curl_vector           => lagrangian_reference_fe_get_curl_vector
  procedure :: get_curls_vector          => lagrangian_reference_fe_get_curls_vector
  procedure :: get_laplacian_scalar      => lagrangian_reference_fe_get_laplacian_scalar
  procedure :: get_laplacian_vector      => lagrangian_reference_fe_get_laplacian_vector
  procedure :: get_laplacians_scalar     => lagrangian_reference_fe_get_laplacians_scalar
  procedure :: get_laplacians_vector     => lagrangian_reference_fe_get_laplacians_vector
  procedure :: create_nodal_quadrature   => lagrangian_reference_fe_create_nodal_quadrature
  procedure :: has_nodal_quadrature      => lagrangian_reference_fe_has_nodal_quadrature
  procedure :: get_nodal_quadrature      => lagrangian_reference_fe_get_nodal_quadrature
  procedure :: evaluate_fe_function_scalar          &
       & => lagrangian_reference_fe_evaluate_fe_function_scalar
  procedure :: evaluate_fe_function_vector          & 
       & => lagrangian_reference_fe_evaluate_fe_function_vector
  procedure :: evaluate_fe_function_tensor          & 
       & => lagrangian_reference_fe_evaluate_fe_function_tensor
  procedure :: evaluate_gradient_fe_function_scalar & 
       & => lagrangian_reference_fe_evaluate_gradient_fe_function_scalar
  procedure :: evaluate_gradient_fe_function_vector &
       & => lagrangian_reference_fe_evaluate_gradient_fe_function_vector
  procedure :: evaluate_laplacian_fe_function_scalar          &
       & => lagrangian_reference_fe_evaluate_laplacian_fe_function_scalar
  procedure :: evaluate_laplacian_fe_function_vector          & 
       & => lagrangian_reference_fe_evaluate_laplacian_fe_function_vector
  procedure :: free                      => lagrangian_reference_fe_free
  ! Concrete TBPs of this derived data type
  procedure, private :: fill                         & 
       & => lagrangian_reference_fe_fill
  procedure :: generate_own_dofs_cell_permutations           &
       & => lagrangian_reference_fe_generate_own_dofs_cell_permutations
  procedure :: fill_qpoints_permutations           &
       & => lagrangian_reference_fe_fill_qpoints_permutations
  procedure, private, non_overridable :: fill_field_components        & 
       & => lagrangian_reference_fe_fill_field_components

  !     procedure, private, non_overridable :: get_node_coordinates_array   & 
  !      & => lagrangian_reference_fe_get_node_coordinates_array
  procedure, private, non_overridable :: extend_list_components       & 
       & => lagrangian_reference_fe_extend_list_components
  procedure, private :: apply_cell_map_to_interpolation & 
       & => lagrangian_reference_fe_apply_cell_map_to_interpolation
  procedure  :: get_default_quadrature_degree &
       & => lagrangian_reference_fe_get_default_quadrature_degree
  procedure  :: get_h_refinement_coefficient & 
       & => lagrangian_reference_fe_get_h_refinement_coefficient 
  procedure :: interpolate_nodal_values_on_subcell & 
       & => lagrangian_reference_fe_interpolate_nodal_values_on_subcell
  procedure :: project_nodal_values_on_cell & 
       & => lagrangian_reference_fe_project_nodal_values_on_cell
end type lagrangian_reference_fe_t

abstract interface
  subroutine fill_scalar_interface ( this )
    import :: lagrangian_reference_fe_t
    implicit none 
    class(lagrangian_reference_fe_t), intent(inout) :: this 
  end subroutine fill_scalar_interface
  
  subroutine fill_quadrature_interface ( this, quadrature )
    import :: lagrangian_reference_fe_t, quadrature_t
    implicit none 
    class(lagrangian_reference_fe_t), intent(in)    :: this
    type(quadrature_t)              , intent(inout) :: quadrature       
  end subroutine fill_quadrature_interface

  subroutine fill_nodal_quadrature_interface ( this, quadrature ) 
    import :: lagrangian_reference_fe_t, quadrature_t
    implicit none 
    class(lagrangian_reference_fe_t), intent(in)    :: this
    type(quadrature_t)              , intent(inout) :: quadrature  
  end subroutine fill_nodal_quadrature_interface

  subroutine fill_interpolation_interface ( this, quadrature, interpolation, order_vector )
    import :: lagrangian_reference_fe_t, interpolation_t, ip, rp, quadrature_t, SPACE_DIM
    implicit none 
    class(lagrangian_reference_fe_t), intent(in)    :: this
    type(quadrature_t)              , intent(in)    :: quadrature
    type(interpolation_t)           , intent(inout) :: interpolation
    integer(ip)           , optional, intent(in)    :: order_vector(SPACE_DIM)
  end subroutine fill_interpolation_interface

  subroutine fill_interp_restricted_to_facet_interface ( this,             &
                                                 local_quadrature, &
                                                 facet_lid,    &
                                                 subfacet_lid, &
                                                 facet_interpolation )
    import :: lagrangian_reference_fe_t, interpolation_t, quadrature_t, ip
    implicit none 
    class(lagrangian_reference_fe_t), intent(in)    :: this
    type(quadrature_t)              , intent(in)    :: local_quadrature
    integer(ip)                     , intent(in)    :: facet_lid
    integer(ip)                     , intent(in)    :: subfacet_lid
    type(interpolation_t)           , intent(inout) :: facet_interpolation
  end subroutine fill_interp_restricted_to_facet_interface
  
    subroutine fill_interp_restricted_to_edget_interface ( this,             &
                                                          local_edge_id,    &
                                                          local_quadrature, &
                                                          edget_interpolation )
    import :: lagrangian_reference_fe_t, interpolation_t, quadrature_t, ip
    implicit none 
    class(lagrangian_reference_fe_t), intent(in)    :: this
    integer(ip)                     , intent(in)    :: local_edge_id 
    type(quadrature_t)              , intent(in)    :: local_quadrature
    type(interpolation_t)           , intent(inout) :: edget_interpolation
  end subroutine fill_interp_restricted_to_edget_interface
  
  function compute_num_quadrature_points_interface ( this, degree, dimension )
    import :: lagrangian_reference_fe_t, ip, SPACE_DIM
    implicit none 
    class(lagrangian_reference_fe_t), intent(in)    :: this
    integer(ip)                     , intent(in)    :: degree
    integer(ip)                     , intent(in)    :: dimension
    integer(ip) :: compute_num_quadrature_points_interface
  end function compute_num_quadrature_points_interface

  subroutine blending_interface( this,values)
    import :: lagrangian_reference_fe_t, point_t
    implicit none
    class(lagrangian_reference_fe_t), intent(in)    :: this 
    type(point_t)                   , intent(inout) :: values(:)     
  end subroutine blending_interface
end interface

public :: lagrangian_reference_fe_t, p_lagrangian_reference_fe_t 


!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type, abstract, extends(lagrangian_reference_fe_t) :: raviart_thomas_reference_fe_t
private
type(node_array_t)    :: node_array_vector(SPACE_DIM)
real(rp), allocatable :: change_basis_matrix(:,:)
logical               :: basis_changed
contains
procedure (change_basis_interface), private, deferred :: change_basis
procedure :: create                           => raviart_thomas_create
procedure :: free                             => raviart_thomas_free
procedure :: create_facet_interpolation  => raviart_thomas_create_facet_interpolation
procedure :: blending                         => raviart_thomas_blending
procedure :: create_data_out_quadrature       => raviart_thomas_create_data_out_quadrature
procedure :: get_num_subcells              => raviart_thomas_get_num_subcells
procedure :: get_subcells_connectivity        => raviart_thomas_get_subcells_connectivity
procedure :: has_nodal_quadrature             => raviart_thomas_has_nodal_quadrature
procedure :: get_nodal_quadrature             => raviart_thomas_get_nodal_quadrature    
procedure :: get_value_scalar                 => raviart_thomas_get_value_scalar
procedure :: get_value_vector                 => raviart_thomas_get_value_vector
procedure :: get_values_scalar                => raviart_thomas_get_values_scalar
procedure :: get_values_vector                => raviart_thomas_get_values_vector
procedure :: get_gradient_scalar              => raviart_thomas_get_gradient_scalar
procedure :: get_gradient_vector              => raviart_thomas_get_gradient_vector
procedure :: get_gradients_scalar             => raviart_thomas_get_gradients_scalar
procedure :: get_gradients_vector             => raviart_thomas_get_gradients_vector
procedure :: get_divergence_vector            => raviart_thomas_get_divergence_vector
procedure :: get_divergences_vector           => raviart_thomas_get_divergences_vector
procedure :: get_curl_vector                  => raviart_thomas_get_curl_vector
procedure :: get_curls_vector                  => raviart_thomas_get_curls_vector
procedure :: create_interpolation             => raviart_thomas_create_interpolation
procedure :: create_interpolation_restricted_to_facet        => rt_create_interpolation_restricted_to_facet
procedure :: create_interpolation_restricted_to_edget        => rt_create_interpolation_restricted_to_edget
procedure :: evaluate_fe_function_scalar          &
    & => raviart_thomas_evaluate_fe_function_scalar
procedure :: evaluate_fe_function_vector          & 
    & => raviart_thomas_evaluate_fe_function_vector
procedure :: evaluate_fe_function_tensor          & 
    & => raviart_thomas_evaluate_fe_function_tensor
procedure, private :: apply_cell_map_to_interpolation & 
    & => raviart_thomas_apply_cell_map_to_interpolation
procedure, private :: fill                         & 
    & => raviart_thomas_fill
procedure, private :: fill_vector                         & 
    & => raviart_thomas_fill_vector    
procedure, private :: fill_nodal_quadrature &
    & => raviart_thomas_fill_nodal_quadrature
procedure, private :: invert_change_basis_matrix &
    & => raviart_thomas_invert_change_basis_matrix
procedure, private :: apply_change_basis_matrix_to_interpolation &
    & => rt_apply_change_basis_matrix_to_interpolation 
procedure          :: apply_change_basis_matrix_to_nodal_values &
    & => rt_apply_change_basis_matrix_to_nodal_values
procedure, private :: fill_interp_restricted_to_edget & 
    & => rt_fill_interp_restricted_to_edget 
end type raviart_thomas_reference_fe_t 

abstract interface
  subroutine change_basis_interface ( this )
    import :: raviart_thomas_reference_fe_t 
    implicit none 
    class(raviart_thomas_reference_fe_t), intent(inout) :: this 
  end subroutine change_basis_interface
end interface  


public :: raviart_thomas_reference_fe_t  


!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type, abstract, extends(lagrangian_reference_fe_t) :: nedelec_reference_fe_t
private
type(node_array_t)    :: node_array_vector(SPACE_DIM)
real(rp), allocatable :: change_basis_matrix(:,:)
real(rp), allocatable :: inverse_change_basis_matrix_h_refinement(:,:) 
logical               :: basis_changed
contains

procedure (nedelec_change_basis_interface) , private, deferred :: change_basis

procedure :: create                          => nedelec_create
procedure :: free                            => nedelec_free
procedure :: blending                        => nedelec_blending
procedure :: create_data_out_quadrature      => nedelec_create_data_out_quadrature
procedure :: get_num_subcells             => nedelec_get_num_subcells
procedure :: get_subcells_connectivity       => nedelec_get_subcells_connectivity
procedure :: has_nodal_quadrature            => nedelec_has_nodal_quadrature
procedure :: get_nodal_quadrature            => nedelec_get_nodal_quadrature 
procedure :: get_value_scalar                => nedelec_get_value_scalar
procedure :: get_value_vector                => nedelec_get_value_vector
procedure :: get_values_scalar               => nedelec_get_values_scalar
procedure :: get_values_vector               => nedelec_get_values_vector
procedure :: get_gradient_scalar             => nedelec_get_gradient_scalar
procedure :: get_gradient_vector             => nedelec_get_gradient_vector
procedure :: get_gradients_scalar            => nedelec_get_gradients_scalar
procedure :: get_gradients_vector            => nedelec_get_gradients_vector
procedure :: get_divergence_vector           => nedelec_get_divergence_vector
procedure :: get_divergences_vector          => nedelec_get_divergences_vector
procedure :: get_curl_vector                 => nedelec_get_curl_vector
procedure :: get_curls_vector                => nedelec_get_curls_vector
procedure :: create_interpolation            => nedelec_create_interpolation
procedure :: create_interpolation_restricted_to_facet       => nedelec_create_interpolation_restricted_to_facet
procedure :: create_interpolation_restricted_to_edget       => nedelec_create_interpolation_restricted_to_edget 
procedure :: create_facet_interpolation      => nedelec_create_facet_interpolation
procedure :: create_edget_interpolation      => nedelec_create_edget_interpolation
procedure :: assign_cell_map_duties          => nedelec_assign_cell_map_duties
procedure :: evaluate_fe_function_scalar          &
    & => nedelec_evaluate_fe_function_scalar
procedure :: evaluate_fe_function_vector          & 
    & => nedelec_evaluate_fe_function_vector
procedure :: evaluate_fe_function_tensor          & 
    & => nedelec_evaluate_fe_function_tensor
procedure, private :: apply_cell_map_to_interpolation & 
    & => nedelec_apply_cell_map_to_interpolation
procedure, private :: fill_vector                         & 
    & => nedelec_fill_vector    
procedure, private :: fill_nodal_quadrature &
    & => nedelec_fill_nodal_quadrature
procedure, private :: invert_change_basis_matrix &
    & => nedelec_invert_change_basis_matrix
procedure, private :: apply_change_basis_matrix_to_interpolation &
    & => nedelec_apply_change_basis_matrix_to_interpolation 
procedure          :: apply_change_basis_matrix_to_nodal_values &
    & => nedelec_apply_change_basis_matrix_to_nodal_values
  procedure :: get_component_node           => nedelec_reference_fe_get_component_node
  procedure :: get_scalar_from_vector_node  => nedelec_reference_fe_get_scalar_from_vector_node
end type nedelec_reference_fe_t 

abstract interface

  subroutine nedelec_change_basis_interface ( this )
    import :: nedelec_reference_fe_t 
    implicit none 
    class(nedelec_reference_fe_t), intent(inout) :: this 
  end subroutine nedelec_change_basis_interface

end interface 

public :: nedelec_reference_fe_t


!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type, extends(lagrangian_reference_fe_t) :: tet_lagrangian_reference_fe_t
private
  logical               :: basis_changed
  real(rp), allocatable :: change_basis_matrix(:,:)
contains 
  ! Deferred TBP implementors from reference_fe_t
   procedure :: create  => tet_lagrangian_reference_fe_create
   procedure :: check_compatibility_of_n_faces                                          &
             &  => tet_lagrangian_reference_fe_check_compatibility_of_n_faces
   procedure :: get_characteristic_length                                               &
             &  => tet_lagrangian_reference_fe_get_characteristic_length
   procedure :: get_num_subcells                                                     &
             &  => tet_lagrangian_reference_fe_get_num_subcells
   procedure :: get_subcells_connectivity                                               &
             &  => tet_lagrangian_reference_fe_get_subcells_connectivity
   procedure :: blending                                                                &
             &  => tet_lagrangian_reference_fe_blending 
   procedure :: generate_own_dofs_cell_permutations                                               &
             &  => tet_lagrangian_reference_fe_generate_own_dofs_cell_permutations
   procedure :: fill_qpoints_permutations                                               &
             &  => tet_lagrangian_reference_fe_fill_qpoints_permutations
   ! Deferred TBP implementors from lagrangian_reference_fe_t
   procedure :: create_data_out_quadrature                                              & 
             &  => tet_lagrangian_create_data_out_quadrature
   procedure, private :: fill_quadrature                                                &
             &  => tet_lagrangian_reference_fe_fill_quadrature
   procedure, private :: fill_nodal_quadrature                                          &
             &  => tet_lagrangian_reference_fe_fill_nodal_quadrature
   procedure, private :: fill_interpolation                                             &
             &  => tet_lagrangian_reference_fe_fill_interpolation
   procedure, private :: fill_interp_restricted_to_facet                                        &
             &  => tet_lagrangian_reference_fe_fill_interp_restricted_to_facet
   procedure, private :: fill_interp_restricted_to_edget              &
             & => tet_lagrangian_reference_fe_fill_interp_restricted_to_edget
   procedure, private :: compute_num_quadrature_points                                   &
             &  => tet_lagrangian_reference_fe_compute_num_quadrature_points
   procedure, private :: get_node_local_id                                              &
             &  => tet_lagrangian_reference_fe_get_node_local_id
   procedure, private :: set_permutation_2D                                             &
             &  => tet_lagrangian_reference_fe_set_permutation_2D     
   procedure, private :: compute_num_nodes_scalar                                    &
             &  => tet_lagrangian_reference_fe_compute_num_nodes_scalar
   ! Concrete TBPs of this derived data type
   procedure :: free    => tet_lagrangian_reference_fe_free
   procedure, private, non_overridable :: fill_nodes_n_face                             &
             & => tet_lagrangian_reference_fe_fill_nodes_n_face
   procedure, private, non_overridable :: fill_n_face_dim_and_vertices            &
             & => tet_lagrangian_reference_fe_fill_n_face_dim_and_vertices
   procedure, private, non_overridable :: compute_num_interior_dofs                 &
             & => tet_lagrangian_reference_fe_compute_num_interior_dofs
   procedure, private, non_overridable :: compute_sum_of_dofs_in_simplices             &
             & => tet_lagrangian_reference_fe_compute_sum_of_dofs_in_simplices
   procedure, private, non_overridable :: get_n_face_orientation                        &
             & => tet_lagrangian_reference_fe_get_n_face_orientation
   procedure, private :: fill_interpolation_pre_basis                                   &
             & => tet_lagrangian_reference_fe_fill_interpolation_pre_basis
   procedure, private :: change_basis                                                   &
             & => tet_lagrangian_reference_fe_change_basis
   procedure, private :: invert_change_basis_matrix                                     &
             & => tet_lagrangian_reference_fe_invert_change_basis_matrix
   procedure, private :: apply_change_basis_matrix_to_interpolation                     &
             & => tet_lagrangian_ref_fe_apply_change_basis_to_interpolation
   procedure :: compute_permutation_index                                               &
             & => tet_lagrangian_reference_fe_compute_permutation_index
   procedure :: permute_dof_LID_n_face                                                  &
             & => tet_lagrangian_reference_fe_permute_dof_LID_n_face
end type tet_lagrangian_reference_fe_t

public :: tet_lagrangian_reference_fe_t

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type, extends(raviart_thomas_reference_fe_t) :: tet_raviart_thomas_reference_fe_t
private
contains 
  ! Deferred TBP implementors from reference_fe_t
procedure :: check_compatibility_of_n_faces                                 &
&   => tet_raviart_thomas_check_compatibility_of_n_faces
procedure :: get_characteristic_length                                   &
&   => tet_raviart_thomas_get_characteristic_length
! Deferred TBP implementors from lagrangian_reference_fe_t
!procedure, private :: fill_scalar                                        &
!      & => tet_raviart_thomas_fill_scalar
procedure, private :: fill_quadrature                                    &
& => tet_raviart_thomas_fill_quadrature
procedure, private :: fill_interpolation                                 &
& => tet_raviart_thomas_fill_interpolation
procedure, private :: fill_interp_restricted_to_facet                            &
& => tet_raviart_thomas_fill_interp_restricted_to_facet
procedure, private :: set_permutation_2D                                 &
& => tet_raviart_thomas_set_permutation_2D
procedure, private :: compute_num_quadrature_points                       &
& => tet_raviart_thomas_compute_num_quadrature_points
procedure, private :: get_node_local_id                   &
& => tet_raviart_thomas_get_node_local_id
! Concrete TBPs of this derived data type
procedure, private, non_overridable :: raviart_thomas_fill_nodes_n_face                    &
& => tet_raviart_thomas_fill_nodes_n_face
procedure, private, non_overridable :: raviart_thomas_fill_n_face_dim_and_vertices   &
& => tet_raviart_thomas_fill_n_face_dim_and_vertices
procedure, private, non_overridable :: compute_num_interior_dofs     &
& => tet_raviart_thomas_compute_num_interior_dofs
procedure, private, non_overridable :: raviart_thomas_compute_sum_of_dofs_in_simplices &
& => tet_raviart_thomas_compute_sum_of_dofs_in_simplices
procedure, private, non_overridable :: raviart_thomas_evaluate_interpolation            &
& => tet_raviart_thomas_evaluate_interpolation
procedure, private, non_overridable :: raviart_thomas_get_n_face_orientation               &
& => tet_raviart_thomas_get_n_face_orientation
procedure, private :: change_basis &
& => tet_raviart_thomas_reference_fe_change_basis
end type tet_raviart_thomas_reference_fe_t

public :: tet_raviart_thomas_reference_fe_t

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type, extends(lagrangian_reference_fe_t) :: hex_lagrangian_reference_fe_t
private

contains 

procedure :: create => hex_lagrangian_reference_fe_create

  ! Deferred TBP implementors from reference_fe_t
procedure :: check_compatibility_of_n_faces                                 &
&   => hex_lagrangian_reference_fe_check_compatibility_of_n_faces
procedure :: get_characteristic_length                                   &
&   => hex_lagrangian_reference_fe_get_characteristic_length
procedure :: get_num_subcells                                         &
&   => hex_lagrangian_reference_fe_get_num_subcells
procedure :: get_subcells_connectivity                                   &
&   => hex_lagrangian_reference_fe_get_subcells_connectivity
procedure :: blending                                                    &
&   => hex_lagrangian_reference_fe_blending           
! Deferred TBP implementors from lagrangian_reference_fe_t
procedure          :: create_data_out_quadrature                         & 
    => hex_lagrangian_create_data_out_quadrature
procedure, private :: fill_quadrature                                    &
& => hex_lagrangian_reference_fe_fill_quadrature
procedure, private :: fill_nodal_quadrature                              &
& => hex_lagrangian_reference_fe_fill_nodal_quadrature
procedure, private :: fill_interpolation                                 &
& => hex_lagrangian_reference_fe_fill_interpolation
procedure, private :: fill_interp_restricted_to_facet                    &
& => hex_lagrangian_reference_fe_fill_interp_restricted_to_facet
procedure, private :: fill_interp_restricted_to_edget                    &
& => hex_lagrangian_reference_fe_fill_interp_restricted_to_edget
! Overwriten TBPs from lagrangian_reference_fe_t
procedure :: free                                                        &
& => hex_lagrangian_reference_fe_free
! Concrete TBPs of this derived data type
procedure, private :: fill_h_refinement_interpolation                    &
& => hex_lagrangian_reference_fe_fill_h_refinement_interpolation
procedure, private :: fill_h_refinement_permutations                     &
& => hex_lagrangian_reference_fe_fill_h_refinement_permutations
procedure, private :: fill_n_subfacet_permutation                         &
& => hex_lagrangian_reference_fe_fill_n_subfacet_permutation
procedure          :: interpolate_nodal_values_on_subcell                &
& => hex_lagrangian_reference_fe_interpolate_nodal_values_on_subcell
procedure          :: project_nodal_values_on_cell                       &
& => hex_lagrangian_reference_fe_project_nodal_values_on_cell
procedure          :: get_h_refinement_coefficient                       &
& => hex_lagrangian_reference_fe_get_h_refinement_coefficient
procedure, private :: compute_num_quadrature_points                   &
& => hex_lagrangian_reference_fe_compute_num_quadrature_points
procedure :: fill_qpoints_permutations                                   &
& => hex_lagrangian_reference_fe_fill_qpoints_permutations
end type hex_lagrangian_reference_fe_t

public :: hex_lagrangian_reference_fe_t

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type, extends(raviart_thomas_reference_fe_t) :: hex_raviart_thomas_reference_fe_t
private
contains 
  ! Deferred TBP implementors from reference_fe_t
procedure :: check_compatibility_of_n_faces                                 &
&   => hex_raviart_thomas_reference_fe_check_compatibility_of_n_faces
procedure :: get_characteristic_length                                   &
&   => hex_raviart_thomas_reference_fe_get_characteristic_length

! Deferred TBP implementors from raviart_thomas_reference_fe_t
procedure, private :: fill_quadrature                                    &
& => hex_raviart_thomas_reference_fe_fill_quadrature
procedure, private :: fill_interpolation                                 &
& => hex_raviart_thomas_reference_fe_fill_interpolation
procedure, private :: fill_interpolation_pre_basis                       &
& => hex_raviart_thomas_reference_fe_fill_interpolation_pre_basis
procedure, private :: fill_interp_restricted_to_facet                            &
& => hex_raviart_thomas_reference_fe_fill_interp_restricted_to_facet
procedure, private :: compute_num_quadrature_points                       &
& => hrtrf_compute_num_quadrature_points
procedure, private :: change_basis &
& => hex_raviart_thomas_reference_fe_change_basis
procedure :: fill_qpoints_permutations                                   &
       & => hrtrf_fill_qpoints_permutations
       
end type hex_raviart_thomas_reference_fe_t

public :: hex_raviart_thomas_reference_fe_t

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type, extends(nedelec_reference_fe_t) :: hex_nedelec_reference_fe_t
private
integer(ip), allocatable :: h_refinement_subcell_permutation(:,:,:)
contains 
  ! Deferred TBP implementors from reference_fe_t
procedure :: check_compatibility_of_n_faces                              &
&   => hex_nedelec_reference_fe_check_compatibility_of_n_faces
procedure :: get_characteristic_length                                   &
&   => hex_nedelec_reference_fe_get_characteristic_length
procedure, private :: fill                                               &
& => hex_nedelec_reference_fe_fill 

! Deferred TBP implementors from nedelec_reference_fe_t
procedure :: create  => hex_nedelec_reference_fe_create
procedure :: free    => hex_nedelec_reference_fe_free
procedure, private :: fill_quadrature                                    &
& => hex_nedelec_reference_fe_fill_quadrature
procedure, private :: fill_interpolation                                 &
& => hex_nedelec_reference_fe_fill_interpolation
procedure :: fill_interpolation_pre_basis                       &
& => hex_nedelec_reference_fe_fill_interpolation_pre_basis
procedure, private :: fill_interp_restricted_to_facet                            &
& => hex_nedelec_reference_fe_fill_interp_restricted_to_facet
procedure, private :: fill_interp_restricted_to_edget                            &
& => hex_nedelec_reference_fe_fill_interp_restricted_to_edget
procedure, private :: compute_num_quadrature_points                       &
& => hex_nedelec_reference_fe_compute_num_quadrature_points
procedure, private :: change_basis &
& => hex_nedelec_reference_fe_change_basis
procedure :: fill_qpoints_permutations                              &
& =>  hex_nedelec_reference_fe_fill_qpoints_permutations 
! Implementors of nedelec refinement 
procedure, private :: fill_h_refinement_interpolation               &
& => hex_nedelec_reference_fe_fill_h_refinement_interpolation
procedure, private :: fill_interpolation_pre_basis_quadrature_array &
& => hex_nedelec_rf_fill_interpolation_pre_basis_quadrature_array
procedure :: create_prebasis_nodal_quadrature                       &
=> hex_nedelec_create_prebasis_nodal_quadrature 
procedure, private :: fill_h_refinement_permutations                &
& => hex_nedelec_reference_fe_fill_h_refinement_permutations
procedure, private :: fill_n_subcell_permutation                    &
& => hex_nedelec_reference_fe_fill_n_subcell_permutation
procedure, private :: fill_n_subfacet_permutation                   &
& => hex_nedelec_reference_fe_fill_n_subfacet_permutation
procedure  :: get_h_refinement_coefficient                          & 
& => hex_nedelec_reference_fe_get_h_refinement_coefficient 
procedure          :: get_h_refinement_subcell_permutation          &
& => hex_nedelec_reference_fe_get_h_refinement_subcell_perm
end type hex_nedelec_reference_fe_t

public :: hex_nedelec_reference_fe_t

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type, extends(nedelec_reference_fe_t) :: tet_nedelec_reference_fe_t
private
real(rp), allocatable :: basis_Sk_indices(:,:)
contains 
procedure :: free => tet_nedelec_reference_fe_free 
  ! Deferred TBP implementors from reference_fe_t
procedure :: check_compatibility_of_n_faces                              &
&   => tet_nedelec_reference_fe_check_compatibility_of_n_faces
procedure :: get_characteristic_length                                   &
&   => tet_nedelec_reference_fe_get_characteristic_length
procedure :: generate_own_dofs_cell_permutations                                   &
&  => tet_nedelec_reference_fe_generate_own_dofs_cell_permutations
procedure :: fill_qpoints_permutations                                   &
&  => tet_nedelec_reference_fe_fill_qpoints_permutations
procedure, private :: fill                                               & 
&   => tet_nedelec_reference_fe_fill 

! Deferred TBP implementors from nedelec_reference_fe_t
procedure, private :: fill_quadrature                                    &
& => tet_nedelec_reference_fe_fill_quadrature
procedure, private :: create_and_fill_basis_Sk_indices                   & 
& => tet_nedelec_reference_fe_create_and_fill_basis_Sk_indices
procedure, private :: fill_interpolation                                 &
& => tet_nedelec_reference_fe_fill_interpolation
procedure :: fill_interpolation_pre_basis                       &
& => tet_nedelec_reference_fe_fill_interpolation_pre_basis   
procedure, private :: fill_interp_restricted_to_facet                            &
& => tet_nedelec_reference_fe_fill_interp_restricted_to_facet
procedure, private :: fill_interp_restricted_to_edget              &
& => tet_nedelec_reference_fe_fill_interp_restricted_to_edget
procedure, private :: compute_num_quadrature_points                   &
&  => tet_nedelec_reference_fe_compute_num_quadrature_points
procedure, private :: change_basis                                       &
& => tet_nedelec_reference_fe_change_basis
procedure :: compute_permutation_index                                   &
& => tet_nedelec_reference_fe_compute_permutation_index
procedure :: permute_dof_LID_n_face                                      &
& => tet_nedelec_reference_fe_permute_dof_LID_n_face
end type tet_nedelec_reference_fe_t

public :: tet_nedelec_reference_fe_t

 !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type, extends(reference_fe_t) :: void_reference_fe_t
  private
contains
  procedure :: create                      => void_reference_fe_create
  procedure :: create_quadrature           => void_reference_fe_create_quadrature
  procedure :: create_facet_quadrature      => void_reference_fe_create_facet_quadrature
  procedure :: create_edge_quadrature      => void_reference_fe_create_edge_quadrature 
  procedure :: create_interpolation        => void_reference_fe_create_interpolation
  procedure :: create_interpolation_restricted_to_facet   => void_reference_fe_create_interpolation_restricted_to_facet
  procedure :: create_interpolation_restricted_to_edget   => void_reference_fe_create_interpolation_restricted_to_edget
  procedure :: create_facet_interpolation  => void_reference_fe_create_facet_interpolation
  procedure :: create_edget_interpolation  => void_reference_fe_create_edget_interpolation
  procedure :: assign_cell_map_duties      => void_reference_fe_assign_cell_map_duties
  procedure :: apply_cell_map              => void_reference_fe_apply_cell_map
  procedure :: get_component_node          => void_reference_fe_get_component_node
  procedure :: get_scalar_from_vector_node => void_reference_fe_get_scalar_from_vector_node
  procedure :: get_max_order               => void_reference_fe_get_max_order
  procedure :: get_value_scalar            => void_reference_fe_get_value_scalar
  procedure :: get_value_vector            => void_reference_fe_get_value_vector
  procedure :: get_values_scalar           => void_reference_fe_get_values_scalar
  procedure :: get_values_vector           => void_reference_fe_get_values_vector
  procedure :: get_gradient_scalar         => void_reference_fe_get_gradient_scalar
  procedure :: get_gradient_vector         => void_reference_fe_get_gradient_vector
  procedure :: get_gradients_scalar        => void_reference_fe_get_gradients_scalar
  procedure :: get_gradients_vector        => void_reference_fe_get_gradients_vector
  procedure :: get_divergence_vector       => void_reference_fe_get_divergence_vector
  procedure :: get_divergences_vector      => void_reference_fe_get_divergences_vector
  procedure :: get_curl_vector             => void_reference_fe_get_curl_vector
  procedure :: get_curls_vector            => void_reference_fe_get_curls_vector
  procedure :: get_laplacian_scalar        => void_reference_fe_get_laplacian_scalar
  procedure :: get_laplacian_vector        => void_reference_fe_get_laplacian_vector
  procedure :: get_laplacians_scalar       => void_reference_fe_get_laplacians_scalar
  procedure :: get_laplacians_vector       => void_reference_fe_get_laplacians_vector
  procedure :: evaluate_fe_function_scalar => void_reference_fe_evaluate_fe_function_scalar
  procedure :: evaluate_fe_function_vector => void_reference_fe_evaluate_fe_function_vector
  procedure :: evaluate_fe_function_tensor => void_reference_fe_evaluate_fe_function_tensor
  procedure :: evaluate_gradient_fe_function_scalar => void_reference_fe_evaluate_gradient_fe_function_scalar
  procedure :: evaluate_gradient_fe_function_vector => void_reference_fe_evaluate_gradient_fe_function_vector
  procedure :: evaluate_laplacian_fe_function_scalar          &
       & => void_reference_fe_evaluate_laplacian_fe_function_scalar
  procedure :: evaluate_laplacian_fe_function_vector          & 
       & => void_reference_fe_evaluate_laplacian_fe_function_vector
  procedure :: check_compatibility_of_n_faces       => void_reference_fe_check_compatibility_of_n_faces
  procedure :: get_characteristic_length            => void_reference_fe_get_characteristic_length  
  procedure :: generate_own_dofs_cell_permutations            => void_reference_fe_generate_own_dofs_cell_permutations
  procedure :: fill_qpoints_permutations            => void_reference_fe_fill_qpoints_permutations     
  procedure :: free                                 => void_reference_fe_free
  procedure :: get_default_quadrature_degree        => void_reference_fe_get_default_quadrature_degree
  ! Concrete TBPs of this derived data type
  procedure, private :: fill                        => void_reference_fe_fill
  procedure :: create_data_out_quadrature  => void_reference_fe_create_data_out_quadrature
  procedure :: get_num_subcells            => void_reference_fe_get_num_subcells
  procedure :: get_subcells_connectivity   => void_reference_fe_get_subcells_connectivity
  procedure :: get_h_refinement_coefficient => void_reference_fe_get_h_refinement_coefficient 
  procedure :: interpolate_nodal_values_on_subcell  => void_reference_fe_interpolate_nodal_values_on_subcell
  procedure :: project_nodal_values_on_cell         => void_reference_fe_project_nodal_values_on_cell
end type void_reference_fe_t

public :: void_reference_fe_t

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type cell_integrator_t 
private
integer(ip)                    :: num_shape_functions
integer(ip)                    :: num_quadrature_points
class(reference_fe_t), pointer :: reference_fe
type(interpolation_t)          :: interpolation_reference_cell      ! Unknown interpolation_t in the reference element domain
type(interpolation_t)          :: interpolation_real_cell! Unknown interpolation_t in the physical element domain
contains

procedure, non_overridable :: create         => cell_integrator_create
procedure, non_overridable :: restricted_to_facet => cell_integrator_restricted_to_facet
procedure, non_overridable :: free           => cell_integrator_free
procedure, non_overridable :: update         => cell_integrator_update
procedure, non_overridable :: print          => cell_integrator_print
procedure, non_overridable :: update_interpolation  => cell_integrator_update_interpolation
procedure, non_overridable :: update_interpolation_restricted_to_facet  => cell_integrator_update_interpolation_restricted_to_facet

procedure, non_overridable :: get_interpolation_reference_cell =>                               &
&                                   cell_integrator_get_interpolation_reference_cell
procedure, non_overridable :: get_interpolation_real_cell =>                                    &
&                                   cell_integrator_get_interpolation_real_cell

procedure, non_overridable :: get_interpolation_duties_real_cell =>                             &
&                                   cell_integrator_get_interpolation_duties_real_cell

procedure, non_overridable, private :: get_value_scalar           => cell_integrator_get_value_scalar
procedure, non_overridable, private :: get_value_vector           => cell_integrator_get_value_vector
procedure, non_overridable, private :: get_value_tensor           => cell_integrator_get_value_tensor
procedure, non_overridable, private :: get_value_symmetric_tensor => cell_integrator_get_value_symmetric_tensor
generic            :: get_value => get_value_scalar, &
                                   get_value_vector, &
                                   get_value_tensor, &
                                   get_value_symmetric_tensor
                                   
procedure, non_overridable, private :: get_values_scalar           => cell_integrator_get_values_scalar
procedure, non_overridable, private :: get_values_vector           => cell_integrator_get_values_vector
!procedure, non_overridable, private :: get_value_tensor           => cell_integrator_get_value_tensor
!procedure, non_overridable, private :: get_value_symmetric_tensor => cell_integrator_get_value_symmetric_tensor
generic            :: get_values => get_values_scalar, &
                                    get_values_vector !, &
                                   !get_value_tensor, &
                                   !get_value_symmetric_tensor
procedure, non_overridable, private :: get_gradient_scalar => cell_integrator_get_gradient_scalar
procedure, non_overridable, private :: get_gradient_vector => cell_integrator_get_gradient_vector
generic                             :: get_gradient => get_gradient_scalar, &
                                                       get_gradient_vector 

procedure, non_overridable, private :: get_gradients_scalar => cell_integrator_get_gradients_scalar
procedure, non_overridable, private :: get_gradients_vector => cell_integrator_get_gradients_vector
generic                             :: get_gradients => get_gradients_scalar, &
                                                        get_gradients_vector 

procedure, non_overridable, private :: get_symmetric_gradient_vector => cell_integrator_get_symmetric_gradient_vector
generic                             :: get_symmetric_gradient => get_symmetric_gradient_vector

procedure, non_overridable, private :: get_divergence_vector => cell_integrator_get_divergence_vector
procedure, non_overridable, private :: get_divergence_tensor => cell_integrator_get_divergence_tensor
generic                             :: get_divergence => get_divergence_vector, &
                                                         get_divergence_tensor
procedure, non_overridable, private :: get_divergences_vector => cell_integrator_get_divergences_vector
!procedure, non_overridable, private :: get_divergences_tensor => cell_integrator_get_divergences_tensor
generic                             :: get_divergences => get_divergences_vector!, &
                                                         !get_divergence_tensor

procedure, non_overridable, private :: get_curl_vector => cell_integrator_get_curl_vector
generic                             :: get_curl => get_curl_vector

procedure, non_overridable, private :: get_curls_vector => cell_integrator_get_curls_vector
generic                             :: get_curls => get_curls_vector

procedure, non_overridable, private :: get_laplacian_scalar => cell_integrator_get_laplacian_scalar
procedure, non_overridable, private :: get_laplacian_vector => cell_integrator_get_laplacian_vector
generic                             :: get_laplacian => get_laplacian_scalar, get_laplacian_vector

procedure, non_overridable, private :: get_laplacians_scalar => cell_integrator_get_laplacians_scalar
procedure, non_overridable, private :: get_laplacians_vector => cell_integrator_get_laplacians_vector
generic                             :: get_laplacians => get_laplacians_scalar, get_laplacians_vector

! We might want to have the following in the future:
!  (x) get_hessian (scalar,vector)
!  (x) get_third_derivative (scalar,vector)
! But note that in such a case we would require higher-to-2 rank tensors
! (i.e., type(tensor_field_t) is a rank-2 tensor)

procedure, non_overridable, private :: cell_integrator_evaluate_fe_function_scalar
procedure, non_overridable, private :: cell_integrator_evaluate_fe_function_vector
procedure, non_overridable, private :: cell_integrator_evaluate_fe_function_tensor
generic :: evaluate_fe_function => cell_integrator_evaluate_fe_function_scalar, &
& cell_integrator_evaluate_fe_function_vector, &
& cell_integrator_evaluate_fe_function_tensor

procedure, non_overridable, private :: cell_integrator_evaluate_gradient_fe_function_scalar
procedure, non_overridable, private :: cell_integrator_evaluate_gradient_fe_function_vector
generic :: evaluate_gradient_fe_function => cell_integrator_evaluate_gradient_fe_function_scalar, &
& cell_integrator_evaluate_gradient_fe_function_vector

procedure, non_overridable, private :: cell_integrator_evaluate_laplacian_fe_function_scalar
procedure, non_overridable, private :: cell_integrator_evaluate_laplacian_fe_function_vector
generic :: evaluate_laplacian_fe_function => cell_integrator_evaluate_laplacian_fe_function_scalar, &
& cell_integrator_evaluate_laplacian_fe_function_vector

end type cell_integrator_t

interface assignment(=)
   module procedure assign_cell_integrator, assign_cell_integrator_array
end interface assignment(=)

type p_cell_integrator_t
type(cell_integrator_t), pointer :: p => NULL() 
end type p_cell_integrator_t

public :: cell_integrator_t, p_cell_integrator_t

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type cell_integrator_facet_restriction_t
     private
     integer(ip)                          :: num_facets
     integer(ip)                          :: num_subfacets
     integer(ip)                          :: current_facet_lid
     integer(ip)                          :: current_subfacet_lid
     type(cell_integrator_t), allocatable :: cell_integrator(:) 
   contains
     procedure, non_overridable :: create                      => cell_integrator_facet_restriction_create
     procedure, non_overridable :: update                      => cell_integrator_facet_restriction_update
     procedure, non_overridable :: update_interpolation        => cell_integrator_facet_restriction_update_interpolation
     procedure, non_overridable :: free                        => cell_integrator_facet_restriction_free
     procedure, non_overridable :: copy                        => cell_integrator_facet_restriction_copy
     procedure, non_overridable :: get_current_cell_integrator => cell_integrator_facet_restriction_get_current_cell_integrator
  end type cell_integrator_facet_restriction_t

  public :: cell_integrator_facet_restriction_t

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type facet_maps_t
  private
  logical                         :: is_at_boundary
  type(facet_map_t)                :: facet_map
  type(cell_map_facet_restriction_t) :: cell_maps(2)
  integer(ip)                     :: num_dims
contains
  procedure, non_overridable :: create               => facet_maps_create
  procedure, non_overridable :: free                 => facet_maps_free
  procedure, non_overridable :: update               => facet_maps_update
  procedure, non_overridable :: compute_characteristic_length                                      &
  &                                             => facet_maps_compute_characteristic_length
  procedure, non_overridable :: get_quadrature_points_coordinates                                         &
  &                                             => facet_maps_get_quadrature_points_coordinates
  procedure, non_overridable :: get_facet_coordinates => facet_maps_get_facet_coordinates
  procedure, non_overridable :: get_coordinates_neighbour                                          &
  &                                             => facet_maps_get_coordinates_neighbour
  procedure, non_overridable :: get_neighbour_cell_map => facet_maps_get_neighbour_cell_map
  procedure, non_overridable :: get_normals          => facet_maps_get_normals
  procedure, non_overridable :: get_det_jacobian     => facet_maps_get_det_jacobian
  procedure, non_overridable :: get_facet_map        => facet_maps_get_facet_map
  procedure, non_overridable :: get_cell_maps        => facet_maps_get_cell_maps
end type facet_maps_t

public :: facet_maps_t

interface assignment(=)
   module procedure assign_facet_maps, assign_facet_maps_array
end interface assignment(=)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type facet_integrator_t
  private
  logical                                   :: is_at_boundary
  logical                                   :: is_at_field_boundary
  logical                                   :: is_at_field_interior
  integer(ip)                               :: active_cell_id(2)
  type(cell_integrator_facet_restriction_t) :: cell_integrator_facet_restriction(2)
  type(p_reference_fe_t)                    :: reference_fe(2)
  integer(ip)                               :: current_permutation_index
  type(allocatable_array_ip2_t)             :: qpoints_perm
contains
  procedure, non_overridable :: create             => facet_integrator_create
  procedure, non_overridable :: free               => facet_integrator_free
  procedure, non_overridable :: update             => facet_integrator_update
  procedure, non_overridable :: update_interpolation => facet_integrator_update_interpolation
  procedure, non_overridable :: set_is_at_boundary_and_active_cell_id &
    => facet_integrator_set_is_at_boundary_and_active_cell_id
  procedure, non_overridable :: get_is_at_boundary => facet_integrator_get_is_at_boundary
  procedure, non_overridable :: get_is_at_field_boundary => facet_integrator_get_is_at_field_boundary
  procedure, non_overridable :: get_is_at_field_interior => facet_integrator_get_is_at_field_interior
  procedure, non_overridable :: get_active_cell_id => facet_integrator_get_active_cell_id
  procedure, non_overridable :: get_value_scalar   => facet_integrator_get_value_scalar
  procedure, non_overridable :: get_value_vector   => facet_integrator_get_value_vector
  generic                    :: get_value          => get_value_scalar, get_value_vector
  procedure, non_overridable :: get_values_scalar  => facet_integrator_get_values_scalar
  procedure, non_overridable :: get_values_vector  => facet_integrator_get_values_vector
  generic                    :: get_values         => get_values_scalar, get_values_vector
  procedure, non_overridable :: get_gradient_scalar  => facet_integrator_get_gradient_scalar
  generic                    :: get_gradient => get_gradient_scalar
  procedure, non_overridable :: get_gradients_scalar  => facet_integrator_get_gradients_scalar
  generic                    :: get_gradients => get_gradients_scalar
  procedure, non_overridable :: get_curl           => facet_integrator_get_curl_vector 
  procedure, non_overridable :: get_curls          => facet_integrator_get_curls_vector 
  procedure, non_overridable :: get_current_qpoints_perm => facet_integrator_get_current_qpoints_perm

  procedure, non_overridable, private :: facet_integrator_evaluate_fe_function_scalar
  procedure, non_overridable, private :: facet_integrator_evaluate_fe_function_vector
  procedure, non_overridable, private :: facet_integrator_evaluate_fe_function_tensor
  generic :: evaluate_fe_function => facet_integrator_evaluate_fe_function_scalar, &
  & facet_integrator_evaluate_fe_function_vector, &
  & facet_integrator_evaluate_fe_function_tensor

  procedure, non_overridable, private :: facet_integrator_evaluate_gradient_fe_function_scalar
  procedure, non_overridable, private :: facet_integrator_evaluate_gradient_fe_function_vector
  generic :: evaluate_gradient_fe_function => facet_integrator_evaluate_gradient_fe_function_scalar, &
  & facet_integrator_evaluate_gradient_fe_function_vector
end type facet_integrator_t

interface assignment(=)
   module procedure assign_facet_integrator, assign_facet_integrator_array
end interface assignment(=)

type p_facet_integrator_t
type(facet_integrator_t)          , pointer :: p => NULL()
end type p_facet_integrator_t

public :: facet_integrator_t, p_facet_integrator_t

public :: make_reference_fe
public :: assignment(=)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
contains

  ! Includes with all the TBP and supporting subroutines for the types above.
  ! In a future, we would like to use the submodule features of FORTRAN 2008.

#undef duties
#include "sbm_quadrature.i90"

#include "sbm_interpolation.i90"

#include "sbm_reference_fe.i90"

#include "sbm_void_reference_fe.i90"

#include "sbm_lagrangian_reference_fe.i90"

#include "sbm_raviart_thomas_reference_fe.i90"

#include "sbm_nedelec_reference_fe.i90"

#include "sbm_hex_lagrangian_reference_fe.i90"

#include "sbm_tet_lagrangian_reference_fe.i90"

#include "sbm_hex_raviart_thomas_reference_fe.i90"

#include "sbm_tet_raviart_thomas_reference_fe.i90"

#include "sbm_hex_nedelec_reference_fe.i90"

#include "sbm_tet_nedelec_reference_fe.i90"

#include "sbm_polytope.i90"

#include "sbm_base_map.i90"

#include "sbm_cell_map.i90"

#include "sbm_facet_map.i90"

#include "sbm_edge_map.i90"

#include "sbm_cell_integrator.i90"

#include "sbm_facet_integrator.i90"

#include "sbm_reference_fe_factory.i90"

#define duties interpolation_duties
#define task_01 compute_first_derivatives
#define task_02 compute_second_derivatives
#include "duties_body.i90"

#define duties cell_map_duties
#define task_01 compute_jacobian_inverse
#define task_02 compute_jacobian_derivative
#include "duties_body.i90"

end module reference_fe_names
