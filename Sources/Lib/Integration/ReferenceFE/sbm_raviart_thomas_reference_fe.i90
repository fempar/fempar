! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!==================================================================================================
function raviart_thomas_get_num_subcells(this, num_refinements) result(num_subcells)
  class(raviart_thomas_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: num_refinements
  integer(ip)                                         :: num_subcells
  check(.false.)
end function raviart_thomas_get_num_subcells

!==================================================================================================
subroutine raviart_thomas_get_subcells_connectivity(this, num_refinements, connectivity)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: num_refinements
  integer(ip)                         , intent(inout) :: connectivity(:,:)
  check(.false.)
end subroutine raviart_thomas_get_subcells_connectivity

!**************************************************************************************************
! Deferred TBP implementors from reference_fe_t
!**************************************************************************************************
!==================================================================================================
subroutine raviart_thomas_create_interpolation ( this, quadrature, interpolation, & 
     &                                           interpolation_duties)
  implicit none 
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(quadrature_t)              , intent(in)    :: quadrature
  type(interpolation_t)           , intent(inout) :: interpolation
  type(interpolation_duties_t), optional, intent(in)    :: interpolation_duties

  call interpolation%create( this%num_dims, this%num_shape_functions, &
       &                     quadrature%num_quadrature_points, interpolation_duties )

  call this%fill_interpolation( quadrature, interpolation )

end subroutine raviart_thomas_create_interpolation

!==================================================================================================
! This routine creates the interpolation corresponding to the evaluation of the shape functions on
! integration points given by local_quadrature either on the face 'facet_lid' of the element or
! in all the faces of the element.
subroutine rt_create_interpolation_restricted_to_facet( this, facet_lid, &
     & subfacet_lid, local_quadrature, facet_interpolation)
  implicit none 
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  integer(ip)                     , intent(in)    :: facet_lid
  integer(ip)                     , intent(in)    :: subfacet_lid
  type(quadrature_t)              , intent(in)    :: local_quadrature
  type(interpolation_t)           , intent(inout) :: facet_interpolation
  
  ! Allocate the arrays of the interpolation
  call facet_interpolation%create(this%num_dims, &
                                 this%num_shape_functions, &
                                 local_quadrature%num_quadrature_points)

  ! Fill the values of the shape functions
  call this%fill_interp_restricted_to_facet(local_quadrature, &
                                    facet_lid, &
                                    subfacet_lid, &
                                    facet_interpolation)

end subroutine rt_create_interpolation_restricted_to_facet

!==================================================================================================
subroutine raviart_thomas_fill_nodal_quadrature ( this, quadrature ) 
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(quadrature_t)                  , intent(inout) :: quadrature
  type(node_iterator_t) :: node_iterator
  integer(ip) :: i,j,init,finish
  write(0,*) 'The concept of nodal_quadrature does not apply to RT Ref FEs'
  check(.false.)
end subroutine raviart_thomas_fill_nodal_quadrature

!==================================================================================================
subroutine raviart_thomas_create ( this, topology, num_dims, order, field_type, & 
     &  conformity, continuity )
  implicit none 
  class(raviart_thomas_reference_fe_t), intent(inout) :: this
  character(*)                    , intent(in)    :: topology
  integer(ip)                     , intent(in)    :: num_dims
  integer(ip)                     , intent(in)    :: order
  character(*)                    , intent(in)    :: field_type
  logical                         , intent(in)    :: conformity
  logical              , optional , intent(in)    :: continuity

  assert ( order >= 0 )

  call this%free()
  call this%set_common_data(num_dims,order,field_type,conformity,continuity)
  call this%set_topology ( topology )
  call this%set_fe_type( fe_type_raviart_thomas )
  call this%fill()
  if ( this%conformity .and. this%continuity ) then
    call this%change_basis()
  end if  

end subroutine raviart_thomas_create

!==================================================================================================
subroutine raviart_thomas_free ( this )
  implicit none 
  class(raviart_thomas_reference_fe_t), intent(inout) :: this
  integer(ip) :: i
  
  ! Free member variables of raviart_thomas_reference_fe_t
  if ( allocated(this%change_basis_matrix) ) &
     call memfree ( this%change_basis_matrix, __FILE__, __LINE__ )     
     
  this%basis_changed = .false. 
  do i=1, size(this%node_array_vector)
    call this%node_array_vector(i)%free()
  end do
  
  ! Free member variables of lagrangian_reference_fe_t
  ! (and those of its ancestors)
  call lagrangian_reference_fe_free ( this )  
end subroutine raviart_thomas_free

!==================================================================================================
subroutine raviart_thomas_fill (this)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(inout) :: this
  integer(ip) :: c, i, j, dimension
  integer(ip) :: column, inode, idime, inode_scalar, num_columns
  ! Here we put a k+1,k,k order_vector, which is the one for the x-component.
  ! In fill_vector, we use order_vector (and other arrays) using a permutation 
  this%order_vector = this%order
  this%order_vector(1) = this%order+1
  call this%fill_vector()
  
  call memalloc( this%num_shape_functions, 2, this%node_component_array, __FILE__, __LINE__ )
  
  call memalloc( this%node_array_vector(1)%num_nodes,     & 
       &         this%num_field_components, & 
       &         this%node_array_component,    & 
       &         __FILE__, __LINE__ )

  c = 1
  do i = 1, this%num_field_components
    assert(this%node_array_vector(i)%num_nodes == this%node_array_vector(1)%num_nodes)
    do j = 1, this%node_array_vector(i)%num_nodes
        this%node_component_array(c,1) = j
        this%node_component_array(c,2) = i   
        this%node_array_component(j,i) = c
        c = c+1
     end do
  end do
  
end subroutine raviart_thomas_fill


subroutine raviart_thomas_fill_vector (this)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(inout)    :: this 
  type(node_iterator_t) :: node_iterator
  type(facet_iterator_t) :: facet_iterator
  type(list_iterator_t) :: list_iterator
  integer(ip) :: topology, i, n_face_dim, node, children,num_n_faces, ones_dim(SPACE_DIM), idime, perm(SPACE_DIM), offset(SPACE_DIM+1)

  ! Change topology definition to these numbers from the very beginning (not parameter, dim independent)
  if ( this%topology == topology_hex) then
     topology = 2**this%num_dims-1
  elseif ( this%topology == topology_tet ) then
     topology = 0
  end if

  call this%polytope%create( this%num_dims, topology )  

  this%num_shape_functions = 0
  offset(1) = 0
  do idime = 1,this%num_dims
     perm = [ (i, i=1,SPACE_DIM) ]
     perm(idime) = 1
     perm(1) = idime
     call this%node_array_vector(idime)%create( this%polytope, this%order_vector(perm) ) 
     ! Number nodes
     this%num_shape_functions = this%num_shape_functions + this%node_array_vector(idime)%get_num_nodes()
     offset(idime+1) = offset(idime) + this%node_array_vector(idime)%get_num_nodes()
  end do

  num_n_faces = this%polytope%get_num_n_faces()
  ! Number n-faces ( I don't like it, not volume included...)
  this%num_n_faces = num_n_faces-1
  ! num_n-faces_dim
  this%ptr_n_faces_x_dim = 0
  this%ptr_n_faces_x_dim(1) = 1
  do i = 1,num_n_faces
     n_face_dim = this%polytope%get_n_face_dim(i)
     this%ptr_n_faces_x_dim( n_face_dim+2 ) = this%ptr_n_faces_x_dim( n_face_dim+2 ) + 1
  end do
  do i = 1,this%num_dims+1
     this%ptr_n_faces_x_dim(i+1) = this%ptr_n_faces_x_dim(i+1) + this%ptr_n_faces_x_dim(i)
  end do

  ! interior_dofs_n-face  
  call this%own_dofs_n_face%create( num_n_faces )
  do i = 1,num_n_faces
     do idime = 1, this%num_dims
        node_iterator = this%node_array_vector(idime)%create_node_iterator( this%polytope%get_n_face(i), own_boundary = .false. )
        do while (.not. node_iterator%has_finished() )
           call this%own_dofs_n_face%sum_to_pointer_index(i,1)
           call node_iterator%next()
        end do
     end do
  end do
  call this%own_dofs_n_face%calculate_header()
  call this%own_dofs_n_face%allocate_list_from_pointer()
  list_iterator = this%own_dofs_n_face%create_iterator()
  do i = 1,num_n_faces
     do idime = 1, this%num_dims
        node_iterator = this%node_array_vector(idime)%create_node_iterator( this%polytope%get_n_face(i), own_boundary = .false. )
        do while (.not. node_iterator%has_finished() )
           node = node_iterator%current() + offset(idime)
           call list_iterator%set_current(node)
           call node_iterator%next()
           call list_iterator%next()
        end do
     end do
  end do
  ! nodes_n-face
  call this%dofs_n_face%create(num_n_faces)
  do i = 1,num_n_faces
     do idime = 1,this%num_dims
        node_iterator = this%node_array_vector(idime)%create_node_iterator( this%polytope%get_n_face(i), own_boundary = .true. )
        do while (.not. node_iterator%has_finished() )
           call this%dofs_n_face%sum_to_pointer_index(i,1)
           call node_iterator%next()
        end do
     end do
  end do
  call this%dofs_n_face%calculate_header()
  call this%dofs_n_face%allocate_list_from_pointer()  
  list_iterator = this%dofs_n_face%create_iterator()
  do i = 1,num_n_faces
     do idime = 1,this%num_dims
        node_iterator = this%node_array_vector(idime)%create_node_iterator( this%polytope%get_n_face(i), own_boundary = .true. )
        do while (.not. node_iterator%has_finished() )
           node = node_iterator%current() + offset(idime)
           call list_iterator%set_current(node)
           call node_iterator%next()
           call list_iterator%next()
        end do
     end do
  end do
  ! vertices_n-face
  call this%vertices_n_face%create(num_n_faces)
  ones_dim = 1
  call this%vertex_array%create( this%polytope, order = ones_dim )
  do i = 1,num_n_faces
     node_iterator = this%vertex_array%create_node_iterator( this%polytope%get_n_face(i), own_boundary = .true. )
     do while (.not. node_iterator%has_finished() )
        call this%vertices_n_face%sum_to_pointer_index(i,1)
        call node_iterator%next()
     end do
  end do
  call this%vertices_n_face%calculate_header()
  call this%vertices_n_face%allocate_list_from_pointer()
  list_iterator = this%vertices_n_face%create_iterator()
  do i = 1,num_n_faces
     node_iterator = this%vertex_array%create_node_iterator( this%polytope%get_n_face(i), own_boundary = .true. )
     do while (.not. node_iterator%has_finished() )
        node = node_iterator%current()
        call list_iterator%set_current(node)
        call node_iterator%next()
        call list_iterator%next()
     end do
  end do
  call this%facets_n_face%create(num_n_faces)
  do i = 1,num_n_faces
     facet_iterator = this%polytope%create_facet_iterator( this%polytope%get_n_face(i) )
     do while (.not. facet_iterator%has_finished() )
        call this%facets_n_face%sum_to_pointer_index(i,1)
        call facet_iterator%next()
     end do
  end do
  call this%facets_n_face%calculate_header()
  call this%facets_n_face%allocate_list_from_pointer()
  list_iterator = this%facets_n_face%create_iterator()
  do i = 1,num_n_faces
     facet_iterator = this%polytope%create_facet_iterator( this%polytope%get_n_face(i) )
     do while (.not. facet_iterator%has_finished() )
        children = facet_iterator%current()
        call list_iterator%set_current(children)
        call facet_iterator%next()
        call list_iterator%next()
     end do
  end do
  ! orientation
  call this%orientation%create(num_n_faces)
  do i = 1,num_n_faces
     if ( compute_n_face_dim( this%polytope%get_n_face(i), this%num_dims ) == this%num_dims-1 ) then
        this%orientation%a(i) = facet_orientation( this%polytope%get_n_face(i), this%num_dims )
     end if
  end do
  ! own_nodes_n-face and facet_integration_coupling_nodes_n-face
  if ( this%conformity .and. this%continuity ) then
  else
     call this%own_dofs_n_face%create(n=num_n_faces )
     call this%own_dofs_n_face%sum_to_pointer_index( this%own_dofs_n_face%get_num_pointers(), this%num_shape_functions)
     call this%own_dofs_n_face%calculate_header()
     call this%own_dofs_n_face%allocate_list_from_pointer()
     list_iterator = this%own_dofs_n_face%create_iterator()
     i=1
     do while(.not. list_iterator%is_upper_bound())
        call list_iterator%set_current(i)
        call list_iterator%next()
        i = i + 1 
     enddo
  end if
end subroutine raviart_thomas_fill_vector

!==================================================================================================
! This subroutine constructs a interpolation of order 1 of an element of one dimension less.
! This is used to construct the geometrical interpolation of the face
subroutine raviart_thomas_create_facet_interpolation ( this, quadrature, &
     & facet_interpolation)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this
  type(quadrature_t)              , intent(in)    :: quadrature
  type(interpolation_t)           , intent(inout) :: facet_interpolation

  write(*,*) 'Raviart-Thomas FEs cannot be used for geometry mapping'
  check(.false.)
end subroutine raviart_thomas_create_facet_interpolation

function raviart_thomas_has_nodal_quadrature(this)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in) :: this
  logical :: raviart_thomas_has_nodal_quadrature
  raviart_thomas_has_nodal_quadrature = .false.
end function raviart_thomas_has_nodal_quadrature

function raviart_thomas_get_nodal_quadrature(this)
  implicit none
  class(raviart_thomas_reference_fe_t), target, intent(in) :: this
  type(quadrature_t), pointer :: raviart_thomas_get_nodal_quadrature
  assert (.false.)
end function raviart_thomas_get_nodal_quadrature

!==================================================================================================
subroutine raviart_thomas_get_value_scalar( this, actual_cell_interpolation, & 
     & ishape, qpoint, scalar_field )
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  real(rp)                        , intent(inout) :: scalar_field
  write(*,*) ' ERROR in: ',__FILE__,__LINE__
  write(*,*) ' Subroutine not implemented for vector-based FE spaces'
  check( .false. )
end subroutine raviart_thomas_get_value_scalar

!==================================================================================================
subroutine raviart_thomas_get_values_scalar( this, actual_cell_interpolation, values, qpoints_perm )
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)               , intent(in)    :: actual_cell_interpolation 
  real(rp), allocatable               , intent(inout) :: values(:,:)
  integer(ip)            , optional   , intent(in)    :: qpoints_perm(:)
  write(*,*) ' ERROR in: ',__FILE__,__LINE__
  write(*,*) ' Subroutine not implemented for vector-based FE spaces'
  check( .false. )
end subroutine raviart_thomas_get_values_scalar

!==================================================================================================
subroutine raviart_thomas_get_value_vector( this, actual_cell_interpolation, & 
     & ishape, qpoint, vector_field )
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  type(vector_field_t)            , intent(inout) :: vector_field
  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%num_shape_functions )
  assert( qpoint >= 1 )
  call vector_field%init(actual_cell_interpolation%shape_functions(:,ishape,qpoint))
end subroutine raviart_thomas_get_value_vector

!==================================================================================================
subroutine raviart_thomas_get_values_vector( this, actual_cell_interpolation, values, qpoints_perm)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)               , intent(in)    :: actual_cell_interpolation 
  type(vector_field_t), allocatable   , intent(inout) :: values(:,:)
  integer(ip)            , optional   , intent(in)    :: qpoints_perm(:)
  integer(ip) :: idime, ishape, qpoint, istat, actual_qpoint
  logical     :: reallocate
  assert( this%field_type == field_type_vector )
  
  reallocate = .false.
  if (allocated(values)) reallocate = (size(values,1) < this%num_shape_functions) .or. &
                                      (size(values,2) < actual_cell_interpolation%num_quadrature_points)                                  
  if ((.not. allocated(values)) .or. reallocate) then
     if (allocated(values)) then 
        deallocate(values, stat=istat); 
        check(istat==0);
     end if
     ! This allocate inherently invokes default initialization of member variables of type(vector_field_t)
     ! (i.e., no need to explicitly initialize)
     allocate(values(this%num_shape_functions, &
              actual_cell_interpolation%num_quadrature_points), stat=istat); check(istat==0);
  end if
  do qpoint=1, actual_cell_interpolation%num_quadrature_points
     if (present(qpoints_perm)) then
       actual_qpoint = qpoints_perm(qpoint)
     else
       actual_qpoint = qpoint
     end if
     do ishape=1, this%num_shape_functions
        call values(ishape,qpoint)%init(actual_cell_interpolation%shape_functions(:,ishape,actual_qpoint))
     end do
  end do  
end subroutine raviart_thomas_get_values_vector

!==================================================================================================
subroutine raviart_thomas_get_gradient_scalar( this, actual_cell_interpolation, & 
     & ishape, qpoint, vector_field )
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  type(vector_field_t)            , intent(inout) :: vector_field
  integer(ip) :: idime
  write(*,*) ' ERROR in: ',__FILE__,__LINE__
  write(*,*) ' Subroutine not implemented for vector-based FE spaces'
  check( .false. )
end subroutine raviart_thomas_get_gradient_scalar

!==================================================================================================
subroutine raviart_thomas_get_gradients_scalar( this, actual_cell_interpolation, gradients, qpoints_perm )
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this
  type(interpolation_t)               , intent(in)    :: actual_cell_interpolation
  type(vector_field_t), allocatable   , intent(inout) :: gradients(:,:)
  integer(ip)            , optional   , intent(in)    :: qpoints_perm(:)
  write(*,*) ' ERROR in: ',__FILE__,__LINE__
  write(*,*) ' Subroutine not implemented for vector-based FE spaces'
  check( .false. )
end subroutine raviart_thomas_get_gradients_scalar

!==================================================================================================
subroutine raviart_thomas_get_gradient_vector( this, actual_cell_interpolation, & 
     & ishape, qpoint, tensor_field )
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  type(tensor_field_t)            , intent(inout) :: tensor_field
  integer(ip) :: i,j 
  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%num_shape_functions )
  assert( qpoint >= 1 )
  mcheck(actual_cell_interpolation%my_duties%compute_first_derivatives_is_assigned(),'RT reference FE get gradient vector requires cell interpolation to compute derivaties ')
  do i=1, this%num_dims
    do j=1, this%num_dims
     call tensor_field%set(i,j,actual_cell_interpolation%shape_derivatives(j,i,ishape,qpoint))
    end do
  end do
end subroutine raviart_thomas_get_gradient_vector

subroutine raviart_thomas_get_gradients_vector( this, actual_cell_interpolation, gradients, qpoints_perm )
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)               , intent(in)    :: actual_cell_interpolation 
  type(tensor_field_t), allocatable   , intent(inout) :: gradients(:,:)
  integer(ip)            , optional   , intent(in)    :: qpoints_perm(:)

  integer(ip) :: i,j,ishape,qpoint,istat,actual_qpoint
  logical     :: reallocate
  
  assert( this%field_type == field_type_vector )
  mcheck(actual_cell_interpolation%my_duties%compute_first_derivatives_is_assigned(),'RT reference FE get gradients vector requires cell interpolation to compute derivaties ')
 
  reallocate = .false.
  if (allocated(gradients)) reallocate = (size(gradients,1) < this%num_shape_functions) .or. &
                                          (size(gradients,2) < actual_cell_interpolation%num_quadrature_points)                                  
  if ((.not. allocated(gradients)) .or. reallocate) then
     if (allocated(gradients)) then 
        deallocate(gradients, stat=istat); 
        check(istat==0);
     end if
     ! This allocate inherently invokes default initialization of member variables of type(vector_field_t)
     ! (i.e., no need to explicitly initialize)
     allocate(gradients(this%num_shape_functions, &
                        actual_cell_interpolation%num_quadrature_points), stat=istat); check(istat==0);      
  end if
  do qpoint=1, actual_cell_interpolation%num_quadrature_points
     if (present(qpoints_perm)) then
       actual_qpoint = qpoints_perm(qpoint)
     else
       actual_qpoint = qpoint
     end if
     do ishape=1, this%num_shape_functions
        do i=1, this%num_dims
          do j=1, this%num_dims
            call gradients(ishape,qpoint)%set(i,j,actual_cell_interpolation%shape_derivatives(j,i,ishape,actual_qpoint))
          end do
        end do
     end do
  end do
end subroutine raviart_thomas_get_gradients_vector

!==================================================================================================
subroutine raviart_thomas_get_divergence_vector( this, actual_cell_interpolation, & 
     & ishape, qpoint, scalar_field )
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  real(rp)                        , intent(inout) :: scalar_field
  ! Locals 
  integer(ip) :: idime
  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%num_shape_functions )
  assert( qpoint >= 1 )
  mcheck(actual_cell_interpolation%my_duties%compute_first_derivatives_is_assigned(),'RT reference FE get divergence vector requires cell interpolation to compute derivaties ')
  scalar_field = 0.0_rp
  do idime = 1, this%num_dims
     scalar_field = scalar_field + actual_cell_interpolation%shape_derivatives(idime,idime,ishape,qpoint)
  end do
end subroutine raviart_thomas_get_divergence_vector

subroutine raviart_thomas_get_divergences_vector( this, actual_cell_interpolation, divergences, qpoints_perm )
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)               , intent(in)    :: actual_cell_interpolation 
  real(rp), allocatable               , intent(inout) :: divergences(:,:)
  integer(ip)            , optional   , intent(in)    :: qpoints_perm(:)
  ! Locals 
  integer(ip) :: idime, ishape, qpoint,actual_qpoint
  logical     :: reallocate
  assert( this%field_type == field_type_vector )
  mcheck(actual_cell_interpolation%my_duties%compute_first_derivatives_is_assigned(),'RT reference FE get divergences vector requires cell interpolation to compute derivaties ')
  
  reallocate = .false.
  if (allocated(divergences)) reallocate = (size(divergences,1) < this%num_shape_functions) .or. &
                                           (size(divergences,2) < actual_cell_interpolation%num_quadrature_points)
                                          
  if ((.not. allocated(divergences)) .or. reallocate) then
     if (allocated(divergences)) then 
        call memfree(divergences, __FILE__,__LINE__); 
     end if
     call memalloc(this%num_shape_functions, &
                   actual_cell_interpolation%num_quadrature_points, &
                   divergences, __FILE__,__LINE__);
  end if
  do qpoint=1, actual_cell_interpolation%num_quadrature_points
     if (present(qpoints_perm)) then
       actual_qpoint = qpoints_perm(qpoint)
     else
       actual_qpoint = qpoint
     end if
     do ishape=1, this%num_shape_functions
        divergences(ishape,qpoint) = 0.0_rp
        do idime = 1, this%num_dims
           divergences(ishape,qpoint) = divergences(ishape,qpoint) + actual_cell_interpolation%shape_derivatives(idime,idime,ishape,actual_qpoint)
        end do
     end do
  end do
end subroutine raviart_thomas_get_divergences_vector

!==================================================================================================
subroutine raviart_thomas_get_curl_vector( this, actual_cell_interpolation, &
     & ishape, qpoint, vector_field )
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)               , intent(in)    :: actual_cell_interpolation 
  integer(ip)                         , intent(in)    :: ishape
  integer(ip)                         , intent(in)    :: qpoint
  type(vector_field_t)                , intent(inout) :: vector_field

  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%num_shape_functions )
  assert( qpoint >= 1 )  
  assert( SPACE_DIM == 3 )
  mcheck(actual_cell_interpolation%my_duties%compute_first_derivatives_is_assigned(),'RT reference FE get curl vector requires cell interpolation to compute derivaties ')

  call vector_field%init(0.0_rp)
  if (this%num_dims == 2) then 
                             ! d_x u_y - d_y u_x
    call vector_field%set(3, actual_cell_interpolation%shape_derivatives(2,1,ishape,qpoint)- &
                             actual_cell_interpolation%shape_derivatives(1,2,ishape,qpoint) )
  else if ( this%num_dims == 3) then
                             ! d_y u_z - d_z u_y
    call vector_field%set(1, actual_cell_interpolation%shape_derivatives(3,2,ishape,qpoint)- &
                             actual_cell_interpolation%shape_derivatives(2,3,ishape,qpoint) )
                             ! d_z u_x - d_x u_z
    call vector_field%set(2, actual_cell_interpolation%shape_derivatives(1,3,ishape,qpoint)- &
                             actual_cell_interpolation%shape_derivatives(3,1,ishape,qpoint) )
                             ! d_x u_y - d_y u_x
    call vector_field%set(3, actual_cell_interpolation%shape_derivatives(2,1,ishape,qpoint)- &
                             actual_cell_interpolation%shape_derivatives(1,2,ishape,qpoint) )
  end if
end subroutine raviart_thomas_get_curl_vector

!==================================================================================================
subroutine raviart_thomas_get_curls_vector( this, actual_cell_interpolation, curls, qpoints_perm )
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)               , intent(in)    :: actual_cell_interpolation
  type(vector_field_t), allocatable   , intent(inout) :: curls(:,:)
  integer(ip)          , optional   , intent(in)    :: qpoints_perm(:)
  integer(ip) :: idime, ishape, qpoint, istat, actual_qpoint
  logical     :: reallocate
  integer(ip)   :: icomp, ishape_scalar 
  assert( this%field_type == field_type_vector )
  mcheck(actual_cell_interpolation%my_duties%compute_first_derivatives_is_assigned(),'RT reference FE get curls vector requires cell interpolation to compute derivaties ')

  reallocate = .false.
  if (allocated(curls)) reallocate = (size(curls,1) < this%num_shape_functions) .or. &
                                      (size(curls,2) < actual_cell_interpolation%num_quadrature_points)                                  
  if ((.not. allocated(curls)) .or. reallocate) then
     if (allocated(curls)) then 
        deallocate(curls, stat=istat); 
        check(istat==0);
     end if
     ! This allocate inherently invokes default initialization of member variables of type(vector_field_t)
     ! (i.e., no need to explicitly initialize)
     allocate(curls(this%num_shape_functions, &
                    actual_cell_interpolation%num_quadrature_points), stat=istat); check(istat==0);
  end if
  do qpoint=1, actual_cell_interpolation%num_quadrature_points
     if (present(qpoints_perm)) then
       actual_qpoint = qpoints_perm(qpoint)
     else
       actual_qpoint = qpoint
     end if
     do ishape=1, this%num_shape_functions   
        call curls(ishape,qpoint)%init(0.0_rp)
        if (this%num_dims == 2) then 
           ! d_x u_y - d_y u_x
           call curls(ishape,qpoint)%set(3, actual_cell_interpolation%shape_derivatives(2,1,ishape,actual_qpoint)- &
                actual_cell_interpolation%shape_derivatives(1,2,ishape,actual_qpoint) )
        else if ( this%num_dims == 3) then
           ! d_y u_z - d_z u_y
           call curls(ishape,qpoint)%set(1, actual_cell_interpolation%shape_derivatives(3,2,ishape,actual_qpoint)- &
                actual_cell_interpolation%shape_derivatives(2,3,ishape,actual_qpoint) )
           ! d_z u_x - d_x u_z
           call curls(ishape,qpoint)%set(2, actual_cell_interpolation%shape_derivatives(1,3,ishape,actual_qpoint)- &
                actual_cell_interpolation%shape_derivatives(3,1,ishape,actual_qpoint) )
           ! d_x u_y - d_y u_x
           call curls(ishape,qpoint)%set(3, actual_cell_interpolation%shape_derivatives(2,1,ishape,actual_qpoint)- &
                actual_cell_interpolation%shape_derivatives(1,2,ishape,actual_qpoint) )
        end if
     end do
  end do
end subroutine raviart_thomas_get_curls_vector

!==================================================================================================
subroutine raviart_thomas_evaluate_fe_function_scalar( this,                      &
     &  actual_cell_interpolation, &
     &  nodal_values,              &
     &  quadrature_points_values)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)               , intent(in)    :: actual_cell_interpolation 
  real(rp)                            , intent(in)    :: nodal_values(:)
  real(rp), allocatable               , intent(inout) :: quadrature_points_values(:)
  integer(ip) :: qpoint, ishape

  write(*,*) ' ERROR in: ',__FILE__,__LINE__
  write(*,*) ' Subroutine not implemented for vector field unknowns '
  check( .false. )

end subroutine raviart_thomas_evaluate_fe_function_scalar

!==================================================================================================
subroutine raviart_thomas_evaluate_fe_function_vector( this,                      &
     &  actual_cell_interpolation, &
     &  nodal_values,              &
     &  quadrature_points_values)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)               , intent(in)    :: actual_cell_interpolation 
  real(rp)                            , intent(in)    :: nodal_values(:)
  type(vector_field_t), allocatable   , intent(inout) :: quadrature_points_values(:)
  integer(ip) :: qpoint, inode, icomp, inode_scalar, istat

  if ( allocated(quadrature_points_values) ) then
    if ( size(quadrature_points_values) < actual_cell_interpolation%num_quadrature_points ) then
      deallocate(quadrature_points_values, stat=istat); check(istat==0);
      allocate(quadrature_points_values(actual_cell_interpolation%num_quadrature_points), stat=istat); check(istat==0);
    end if
  else
    allocate(quadrature_points_values(actual_cell_interpolation%num_quadrature_points), stat=istat); check(istat==0);
  end if
  
  
  do qpoint = 1, actual_cell_interpolation%num_quadrature_points
     call quadrature_points_values(qpoint)%init(0.0_rp)
     do inode = 1, this%num_shape_functions
        call quadrature_points_values(qpoint)%add( & 
             actual_cell_interpolation%shape_functions(:,inode,qpoint)*nodal_values(inode) )
     end do
  end do

end subroutine raviart_thomas_evaluate_fe_function_vector

!==================================================================================================
subroutine raviart_thomas_evaluate_fe_function_tensor( this,                      &
     &  actual_cell_interpolation, &
     &  nodal_values,              &
     &  quadrature_points_values)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)               , intent(in)    :: actual_cell_interpolation 
  real(rp)                            , intent(in)    :: nodal_values(:)
  type(tensor_field_t), allocatable   , intent(inout) :: quadrature_points_values(:)

  write(*,*) ' ERROR in: ',__FILE__,__LINE__
  write(*,*) ' Subroutine not implemented for tensor field unknowns '
  check( .false. )
end subroutine raviart_thomas_evaluate_fe_function_tensor

! =============================================================================================
subroutine raviart_thomas_blending(this,values)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this
  type(point_t)                       , intent(inout) :: values(:)
  write(0,*) 'Raviart_Thomas reference FE cannot be used for geometry blending'
  check(.false.)
end subroutine raviart_thomas_blending

subroutine raviart_thomas_get_subelements_connectivity(this, connectivity)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(inout) :: connectivity(:,:)
  write(*,*) 'Raviart_thomas reference FE cannot be used for data_out visualization purposes'
end subroutine raviart_thomas_get_subelements_connectivity

subroutine raviart_thomas_create_data_out_quadrature ( this, num_refinements, quadrature )
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: num_refinements
  type(quadrature_t)                  , intent(inout) :: quadrature
  write(0,*) 'Raviart_thomas reference FE cannot create a quadrature for data_out visualization purposes'
  check(.false.)
end subroutine raviart_thomas_create_data_out_quadrature 

!**************************************************************************************************
! Concrete TBPs of this derived data type
!**************************************************************************************************
!==================================================================================================
subroutine raviart_thomas_apply_cell_map_to_interpolation(this,cell_ressemblance,map,ref,phy,scaling_factor)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  integer(ip)                         , intent(in)    :: cell_ressemblance
  type(cell_map_t)                    , intent(in)    :: map
  type(interpolation_t)               , intent(in)    :: ref
  type(interpolation_t)               , intent(inout) :: phy
  real(rp), optional                  , intent(in)    :: scaling_factor
  real(rp), allocatable :: wmat1(:,:,:)
  real(rp), allocatable :: wmat2(:,:,:), wvec1(:)
  integer(ip) :: ndime,nnode,nlocs,ntens
  integer(ip) :: ilocs,inode,idime,jdime,kdime,ldime
  real(rp) :: inv_scaling_factor_to_the_num_dims

  ndime = ref%num_dims
  ntens = ref%num_entries_symmetric_tensor
  nlocs = ref%num_quadrature_points
  !nnode = ref%num_shape_functions
  nnode = size(ref%shape_functions,2)

  if ( cell_ressemblance == no_ressemblance ) then
     ! Piola map for shape functions
     ! \phi(x_g) = \phi(F(X_g))= 1/det(J) * J \phi(X_g)
     phy%shape_functions=0.0_rp
     do ilocs=1,phy%num_quadrature_points
        do inode=1,this%num_shape_functions
           do idime=1,SPACE_DIM
              do jdime=1,SPACE_DIM
                 phy%shape_functions(idime,inode,ilocs) = phy%shape_functions(idime,inode,ilocs) &
                      + map%jacobian(idime,jdime,ilocs)*ref%shape_functions(jdime,inode,ilocs)
              end do
              phy%shape_functions(idime,inode,ilocs) = phy%shape_functions(idime,inode,ilocs) / map%det_jacobian(ilocs)
           end do
        end do
     end do
  
     ! Piola map for shape derivatives
     ! \phi(x_g) = \phi(F(X_g))= 1/det(J) * J grad(phi(X_g)) J^{-1}
     if(phy%my_duties%compute_first_derivatives_is_assigned()) then
        phy%shape_derivatives=0.0_rp
        do ilocs=1,phy%num_quadrature_points
           do inode=1,this%num_shape_functions
              do idime=1,SPACE_DIM
                 do jdime=1,SPACE_DIM
                    do kdime=1,SPACE_DIM
                       do ldime=1,SPACE_DIM
                          phy%shape_derivatives(jdime,idime,inode,ilocs) = phy%shape_derivatives(jdime,idime,inode,ilocs) &
                               + map%jacobian(idime,kdime,ilocs)*ref%shape_derivatives(ldime,kdime,inode,ilocs)*map%inv_jacobian(jdime,ldime,ilocs)
                       end do
                    end do
                    phy%shape_derivatives(jdime,idime,inode,ilocs) = phy%shape_derivatives(jdime,idime,inode,ilocs) / map%det_jacobian(ilocs)
                 end do
              end do
           end do
        end do
     end if
  else if ( cell_ressemblance == is_scaled_and_translated ) then
     massert ( present(scaling_factor), 'Optional "scaling_factor" dummy argument MUST BE provided if cell_ressemblance == is_scaled_and_translated')
     inv_scaling_factor_to_the_num_dims = scaling_factor**(-real(this%num_dims,rp))
     phy%shape_functions(:,:,:) =  scaling_factor * inv_scaling_factor_to_the_num_dims * phy%shape_functions(:,:,:)
     if(phy%my_duties%compute_first_derivatives_is_assigned()) then
        phy%shape_derivatives(:,:,:,:) = inv_scaling_factor_to_the_num_dims*phy%shape_derivatives(:,:,:,:)
     end if
  end if
 
  massert(.not.phy%my_duties%compute_second_derivatives_is_assigned(),'Hessian not implemented for RT')
  
  !! @sbadia: put Piola here
  !phy%shape_derivatives=0.0_rp
  !do ilocs=1,phy%num_quadrature_points
  !   do inode=1,this%num_shape_functions
  !      do idime=1,this%num_dims
  !         do jdime=1,this%num_dims
  !           do kdime=1,this%num_dims
  !             phy%shape_derivatives(idime,jdime,inode,ilocs) = phy%shape_derivatives(idime,jdime,inode,ilocs) &
  !                  + map%inv_jacobian(kdime,jdime,ilocs)*ref%shape_derivatives(idime,kdime,inode,ilocs)
  !           end do
  !         end do
  !      end do
  !   end do
  !end do
end subroutine raviart_thomas_apply_cell_map_to_interpolation

subroutine raviart_thomas_invert_change_basis_matrix(this)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(inout) :: this 
  integer(ip) :: error
  integer(ip), allocatable :: ipiv(:)
  real(rp), allocatable :: inverse_change_basis_matrix(:,:)  
  integer(ip) :: i
  
  assert ( allocated(this%change_basis_matrix) )
  assert ( size(this%change_basis_matrix,1) == this%num_shape_functions )
  assert ( size(this%change_basis_matrix,2) == this%num_shape_functions )
  
  ! Solve linear system with several RHS
  ! Compute LU factorization of this%change_basis_matrix
#ifdef ENABLE_LAPACK
  call memalloc ( this%num_shape_functions, ipiv, __FILE__,__LINE__ )
   
  call memalloc ( this%num_shape_functions, & 
                  this%num_shape_functions, &
                  inverse_change_basis_matrix, &
                   __FILE__,__LINE__ )

  call DGETRF( this%num_shape_functions, & 
               this%num_shape_functions, &
               this%change_basis_matrix, &
               this%num_shape_functions, &
               ipiv, &
               error )
  check ( error == 0 )
  
  inverse_change_basis_matrix = 0.0_rp
  do i=1, this%num_shape_functions
    inverse_change_basis_matrix(i,i) = 1.0_rp
  end do  
 
  call DGETRS( 'N', & 
               this%num_shape_functions, &
               this%num_shape_functions, &
               this%change_basis_matrix, &
               this%num_shape_functions, &
               ipiv, &
               inverse_change_basis_matrix, &
               this%num_shape_functions, &
               error )
  check ( error == 0 )
  
 if ( allocated(this%change_basis_matrix) ) call memfree (  this%change_basis_matrix, __FILE__, __LINE__  )
  
 call memmovealloc(inverse_change_basis_matrix, &
                   this%change_basis_matrix, __FILE__, __LINE__ )

  
  call memfree ( ipiv, __FILE__,__LINE__ )
#else
  write (0,*) 'Error: reference_fe.f90 was not compiled with -DENABLE_LAPACK.'
  write (0,*) 'Error: You must activate this cpp macro in order to use the LAPACK'
  check(.false.)
#endif 
   
end subroutine raviart_thomas_invert_change_basis_matrix


subroutine rt_apply_change_basis_matrix_to_nodal_values ( this, nodal_values_rt, nodal_values_pre_basis )
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  real(rp)                            , intent(in)    :: nodal_values_rt(:)
  real(rp)                            , intent(out)   :: nodal_values_pre_basis(:)

  assert ( size(nodal_values_rt) == size(nodal_values_pre_basis) )
  assert ( size(nodal_values_rt) == this%num_shape_functions )
  
  nodal_values_pre_basis = 0.0_rp
  
#ifdef ENABLE_BLAS
  call DGEMV( 'N', & 
              this%num_shape_functions, &
              this%num_shape_functions, &
              1.0_rp, &
              this%change_basis_matrix, &
              this%num_shape_functions, &
              nodal_values_rt, &
              1, &
              0.0_rp, & 
              nodal_values_pre_basis, & 
              1)
#else
  write (0,*) 'Error: reference_fe.f90 was not compiled with -DENABLE_BLAS.'
  write (0,*) 'Error: You must activate this cpp macro in order to use the BLAS'
  check(.false.)
#endif 
  
end subroutine  rt_apply_change_basis_matrix_to_nodal_values 
  

subroutine rt_apply_change_basis_matrix_to_interpolation(this, interpolation_pre_basis, interpolation)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)               , intent(in)    :: interpolation_pre_basis
  type(interpolation_t)               , intent(inout) :: interpolation
  
  integer(ip)           :: i, j, idime, jdime, qpoint

  ! Compute shape functions
  interpolation%shape_functions   = 0.0_rp
  do qpoint = 1, interpolation%num_quadrature_points
     do i=1, this%num_shape_functions
        do j=1, this%num_shape_functions
           do idime=1, SPACE_DIM
              interpolation%shape_functions(idime, i, qpoint) = interpolation%shape_functions(idime, i, qpoint) + &
                   this%change_basis_matrix(j,i) * interpolation_pre_basis%shape_functions(idime, j, qpoint)
           end do
        end do
     end do
  end do
  
  if(interpolation%my_duties%compute_first_derivatives_is_assigned()) then
     ! Compute shape derivatives
     interpolation%shape_derivatives = 0.0_rp
     do qpoint = 1, interpolation%num_quadrature_points
        do i=1, this%num_shape_functions
           do j=1, this%num_shape_functions
              do idime=1, SPACE_DIM
                 do jdime=1, SPACE_DIM
                    interpolation%shape_derivatives(idime, jdime, i, qpoint) = interpolation%shape_derivatives(idime, jdime, i, qpoint) + &
                         this%change_basis_matrix(j,i) * interpolation_pre_basis%shape_derivatives(idime, jdime, j, qpoint)
                 end do
              end do
           end do
        end do
     end do
  end if
end subroutine rt_apply_change_basis_matrix_to_interpolation
