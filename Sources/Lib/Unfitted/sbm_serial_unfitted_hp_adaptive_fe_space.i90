! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!========================================================================================
subroutine suhpafs_create_same_reference_fes_on_all_cells(&
  this, &
  triangulation, &
  reference_fes, &
  conditions,    &
  field_blocks,  &
  field_coupling, & 
  generate_global_dof_numbering )
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t)                    , intent(inout) :: this
  class(triangulation_t), target  , intent(in)    :: triangulation
  type(p_reference_fe_t)                      , intent(in)    :: reference_fes(:)
  class(conditions_t), target       , optional, intent(in)    :: conditions
  integer(ip)                       , optional, intent(in)    :: field_blocks(:)
  logical                           , optional, intent(in)    :: field_coupling(:,:)
  logical                           , optional, intent(in)    :: generate_global_dof_numbering
  mcheck(.false.,'You cannot create an unfitted fe space with the same reference fe on all cells (you need void and non void ref elems)')
end subroutine suhpafs_create_same_reference_fes_on_all_cells

!========================================================================================
subroutine suhpafs_space_create_different_ref_fes_between_cells(&
    this, &
    triangulation,            &
    reference_fes,            &
    set_ids_to_reference_fes, &
    conditions,    &
    field_blocks,  &
    field_coupling, & 
    generate_global_dof_numbering )
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t)                    , intent(inout) :: this
  class(triangulation_t), target  , intent(in)    :: triangulation
  type(p_reference_fe_t)                      , intent(in)    :: reference_fes(:)
  integer(ip)                                 , intent(in)    :: set_ids_to_reference_fes(:,:)
  class(conditions_t), target       , optional, intent(in)    :: conditions
  integer(ip)                       , optional, intent(in)    :: field_blocks(:)
  logical                           , optional, intent(in)    :: field_coupling(:,:)
  logical                           , optional, intent(in)    :: generate_global_dof_numbering
  call this%free()
  call this%serial_fe_space_t%create(triangulation, &
                                     reference_fes, &
                                     set_ids_to_reference_fes, &
                                     conditions, &
                                     field_blocks, &
                                     field_coupling, &
                                     .false. )
  select type(triangulation)
  class is (unfitted_p4est_serial_triangulation_t)
    this%unfitted_triangulation => triangulation
    call this%unfitted_integration%create(this)
  class default
    check(.false.)
  end select
  call this%debug_info%init()

  if (this%use_constraints) then
    call this%allocate_and_fill_aggregate_ids(triangulation)
    call this%compute_aggregate_sizes(triangulation)
  else
    call memalloc(triangulation%get_num_local_cells(),this%aggregate_ids,__FILE__,__LINE__)
    call memalloc(size(this%aggregate_ids),this%aggregate_size,__FILE__,__LINE__)
    call memalloc(size(this%aggregate_ids),this%is_in_aggregate_x_cell,__FILE__,__LINE__)
    this%aggregate_ids(:) = 0
    this%aggregate_size(:) = 0.0
    this%is_in_aggregate_x_cell(:) = .false.
  end if

  call this%check_for_full_neighbors()

  if ( present(generate_global_dof_numbering) ) then
    if ( generate_global_dof_numbering ) then
      call this%set_up_cell_integration()   
      call this%generate_global_dof_numbering()
    end if 
  else
    call this%set_up_cell_integration()
    call this%generate_global_dof_numbering()
  end if 

end subroutine suhpafs_space_create_different_ref_fes_between_cells

!========================================================================================
subroutine suhpafs_free(this)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout) :: this
  call this%serial_fe_space_t%free()
  this%unfitted_triangulation => null()
  call this%unfitted_integration%free()
  if (allocated(this%aggregate_ids)) then
    call memfree(this%aggregate_ids,__FILE__,__LINE__)
  end if
  if (allocated(this%aggregate_size)) then
    call memfree(this%aggregate_size,__FILE__,__LINE__)
  end if
  if (allocated(this%is_in_aggregate_x_cell)) then
    call memfree(this%is_in_aggregate_x_cell,__FILE__,__LINE__)
  end if
  call this%debug_info%free()
end subroutine suhpafs_free

!========================================================================================
subroutine suhpafs_set_use_constraints(this,use_constraints)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout) :: this
  logical, intent(in) :: use_constraints
  this%use_constraints = use_constraints
end subroutine suhpafs_set_use_constraints

!========================================================================================
subroutine suhpafs_set_use_serendipity_extension(this,use_serendipity_extension)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout) :: this
  logical, intent(in) :: use_serendipity_extension
  this%use_serendipity_extension = use_serendipity_extension
end subroutine suhpafs_set_use_serendipity_extension

!========================================================================================
subroutine suhpafs_create_fe_cell_iterator(this, fe)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(in)    :: this
  class(fe_cell_iterator_t), allocatable, intent(inout) :: fe
  integer(ip) :: istat
  call this%free_fe_cell_iterator(fe)
  allocate(unfitted_fe_cell_iterator_t :: fe, stat=istat); check(istat==0)
  call fe%create(this)
end subroutine suhpafs_create_fe_cell_iterator

!========================================================================================
subroutine suhpafs_create_fe_facet_iterator(this, fe_face)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), target, intent(in)    :: this
  class(fe_facet_iterator_t), allocatable, intent(inout) :: fe_face
  class(vef_iterator_t), allocatable :: vef
  class(triangulation_t), pointer :: triangulation
  integer(ip)          :: istat
  call this%free_fe_facet_iterator(fe_face)
  triangulation => this%get_triangulation()
  call triangulation%create_vef_iterator(vef)
  allocate(unfitted_fe_facet_iterator_t :: fe_face, stat=istat); check(istat==0)
  call fe_face%create(this,vef)
  call triangulation%free_vef_iterator(vef)
end subroutine suhpafs_create_fe_facet_iterator

!========================================================================================
subroutine suhpafs_count_dofs ( this ) 
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout) :: this   

  logical, allocatable :: per_field_proper_vefs_visited(:,:)
  logical, allocatable :: per_field_improper_vefs_visited(:,:)
  integer(ip) :: field_id, vef_lid, ivef, num_own_dofs_on_vef, iblock
  class(fe_cell_iterator_t), allocatable :: fe, coarser_fe
  type(fe_vef_iterator_t) :: vef
  integer(ip) :: ielem
  logical :: local_found

  integer(ip) :: num_fields
  integer(ip), allocatable :: num_dofs_x_field(:)
  integer(ip), pointer :: fe_space_type_x_field(:)
  class(triangulation_t), pointer :: triangulation
  type(block_layout_t), pointer :: block_layout

  logical, allocatable :: proper_vef_constrains_full_cell(:,:)

  ! We want to call this subroutine only for aggregation-based FE spaces
  if (.not. this%use_constraints) then
    call this%serial_fe_space_t%count_dofs()
    return
  end if

  ! This is needed since we cannot access to private variables of the father
  triangulation => this%get_triangulation()
  block_layout => this%get_block_layout()
  num_fields = this%get_num_fields()
  call memalloc(num_fields,num_dofs_x_field,__FILE__,__LINE__)
  fe_space_type_x_field => this%get_fe_space_type()

  ! Create iterators
  call this%create_fe_cell_iterator(fe)
  call this%create_fe_cell_iterator(coarser_fe)
  call this%create_fe_vef_iterator(vef)

  ! Mark the vefs owning DOFs that constraint hanging DOFs in full cells
  call memalloc ( num_fields, triangulation%get_num_proper_vefs(), proper_vef_constrains_full_cell,  __FILE__, __LINE__ )
  call this%fill_proper_vef_constrains_full_cell(proper_vef_constrains_full_cell)
  
  ! Count #DoFs per field
  num_dofs_x_field = 0
  
  call memalloc ( num_fields, triangulation%get_num_proper_vefs(), per_field_proper_vefs_visited,  __FILE__, __LINE__ )
  call memalloc ( num_fields, triangulation%get_num_improper_vefs(), per_field_improper_vefs_visited,  __FILE__, __LINE__ )
  per_field_proper_vefs_visited(:,:) = .false.
  per_field_improper_vefs_visited(:,:) = .false.

  ! Loop in full cells
  call fe%first()
  do while ( .not. fe%has_finished())
    if ( fe%is_local() .and. (.not. fe%is_cut()) ) then
      do field_id=1, num_fields
        if ( .not. fe%is_void(field_id)) then
          num_dofs_x_field(field_id) = num_dofs_x_field(field_id) + fe%count_own_dofs_cell(field_id)
          if ( fe_space_type_x_field(field_id) == fe_space_type_cg ) then
            do ivef = 1, fe%get_num_vefs()
              call fe%get_vef(ivef,vef)
              if ( .not. vef%has_free_dofs(field_id,coarser_fe) ) cycle
              vef_lid = abs(fe%get_vef_gid(ivef))
              if ( vef%is_proper() ) then
                if ( .not. per_field_proper_vefs_visited (field_id,vef_lid) ) then
                  num_own_dofs_on_vef = fe%count_own_dofs_vef(ivef,field_id)
                  if (num_own_dofs_on_vef>0) then
                    per_field_proper_vefs_visited (field_id,vef_lid) = .true.
                    num_dofs_x_field(field_id) = num_dofs_x_field(field_id) + num_own_dofs_on_vef 
                  end if
                end if
              else if ( .not. per_field_improper_vefs_visited (field_id,vef_lid) ) then
                num_own_dofs_on_vef = fe%count_own_dofs_vef(ivef,field_id)
                if (num_own_dofs_on_vef>0) then
                  per_field_improper_vefs_visited (field_id,vef_lid) = .true.
                  num_dofs_x_field(field_id) = num_dofs_x_field(field_id) +  num_own_dofs_on_vef 
                end if
              end if
            end do
          end if
        end if
      end do
    end if
    call fe%next()
  end do

  ! Loop in cut cells
  call fe%first()
  do while ( .not. fe%has_finished())
    if ( fe%is_local() .and.  fe%is_cut() ) then
      do field_id=1, num_fields
        if ( .not. fe%is_void(field_id)) then
          if ( fe_space_type_x_field(field_id) == fe_space_type_cg ) then
             do ivef = 1, fe%get_num_vefs()
               call fe%get_vef(ivef,vef)
               vef_lid = abs(fe%get_vef_gid(ivef))
               if ( vef%is_proper() ) then
                 if ( .not. per_field_proper_vefs_visited (field_id,vef_lid) ) then
                   if (proper_vef_constrains_full_cell(field_id,vef_lid)) then
                     num_own_dofs_on_vef = fe%count_own_dofs_vef(ivef,field_id)
                     if (num_own_dofs_on_vef>0) then
                       per_field_proper_vefs_visited (field_id,vef_lid) = .true.
                       num_dofs_x_field(field_id) = num_dofs_x_field(field_id) + num_own_dofs_on_vef 
                     end if
                   end if
                 end if
               end if
             end do
          end if
        end if
      end do
    end if
    call fe%next()
  end do
  
#ifdef DEBUG
  call fe%first()
  do while(.not. fe%has_finished())
     mcheck(.not. fe%is_ghost(),'For the moment, this subroutine only works for serial runs')
     call fe%next()    
  end do
#endif
  
  ! Count #DoFs per block
  call block_layout%clear_num_dofs_x_block()
  do field_id=1, this%get_num_fields()
    iblock = block_layout%get_block_id(field_id) 
    call block_layout%add_to_block_num_dofs(iblock,num_dofs_x_field(field_id))     
  end do

  ! This is needed since we cannot access to private variables of the father
  do field_id=1, this%get_num_fields()
    call this%set_field_num_dofs(field_id,num_dofs_x_field(field_id))
  end do
  
  call this%free_fe_vef_iterator(vef)
  call this%free_fe_cell_iterator(fe)
  call this%free_fe_cell_iterator(coarser_fe)
  call memfree ( per_field_proper_vefs_visited,  __FILE__, __LINE__ )
  call memfree ( per_field_improper_vefs_visited,  __FILE__, __LINE__ )
  call memfree(num_dofs_x_field,__FILE__,__LINE__)
  call memfree ( proper_vef_constrains_full_cell,  __FILE__, __LINE__ )
end subroutine suhpafs_count_dofs 

!========================================================================================
subroutine suhpafs_list_dofs ( this ) 
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout) :: this   
  
  ! TODO: This code is almost replicated from the father. Surely, there are better ways to do that.

  integer(ip), allocatable :: owner_cell_gid_x_field_and_proper_vef(:,:)
  integer(ip), allocatable :: owner_cell_gid_x_field_and_improper_vef(:,:)
  integer(ip), allocatable :: per_field_proper_vef_lid_in_owner_cell (:,:)
  integer(ip), allocatable :: per_field_improper_vef_lid_in_owner_cell (:,:)
  integer(ip), allocatable :: blocks_current_num_dofs(:)
  integer(ip), allocatable :: fields_current_dof(:)
  class(fe_cell_iterator_t), allocatable :: fe, source_fe, coarser_fe
  type(fe_vef_iterator_t)  :: vef, coarser_vef
  integer(ip) :: block_id, field_id
  integer(ip) :: ivef, jvef, vef_lid
  integer(ip) :: previous_dof_block
  integer(ip) :: current_fixed_dof, previous_fixed_dof
  integer(ip) :: source_cell_id, source_vef_lid
  logical     :: is_owner, local_found, add_dofs
  integer(ip) :: ielem
  integer(ip) :: ivef_in_source_fe
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t) :: own_dofs_on_vef_iterator

  integer(ip) :: num_fields
  integer(ip), allocatable :: num_dofs_x_field(:)
  class(triangulation_t), pointer :: triangulation
  type(block_layout_t), pointer :: block_layout

  logical, allocatable :: proper_vef_constrains_full_cell(:,:)

  ! We want to call this subroutine only for aggregation-based FE spaces
  if (.not. this%use_constraints) then
    call this%serial_fe_space_t%list_dofs()
    return
  end if
 
  ! This is needed since we cannot access to private variables of the father
  triangulation => this%get_triangulation()
  block_layout => this%get_block_layout()
  num_fields = this%get_num_fields()
  call memalloc(num_fields,num_dofs_x_field,__FILE__,__LINE__)
  do field_id=1, num_fields
    num_dofs_x_field(field_id) = this%get_field_num_dofs(field_id)
  end do

  call this%create_fe_cell_iterator(coarser_fe)
  call this%create_fe_cell_iterator(source_fe)
  call this%create_fe_cell_iterator(fe)
  call this%create_fe_vef_iterator(vef)
  call this%create_fe_vef_iterator(coarser_vef)

  ! Mark the vefs owning DOFs that constraint hanging DOFs in full cells
  call memalloc ( num_fields, triangulation%get_num_proper_vefs(), proper_vef_constrains_full_cell,  __FILE__, __LINE__ )
  call this%fill_proper_vef_constrains_full_cell(proper_vef_constrains_full_cell)
  
  current_fixed_dof = this%get_num_fixed_dofs()
  
  call memalloc ( this%get_num_fields(), triangulation%get_num_vefs(), owner_cell_gid_x_field_and_proper_vef,  __FILE__, __LINE__ )
  owner_cell_gid_x_field_and_proper_vef = -1
  
  call memalloc ( this%get_num_fields(), triangulation%get_num_vefs(), owner_cell_gid_x_field_and_improper_vef,  __FILE__, __LINE__ )
  owner_cell_gid_x_field_and_improper_vef = -1
  
  call memalloc ( this%get_num_fields(), triangulation%get_num_vefs(), per_field_proper_vef_lid_in_owner_cell,  __FILE__, __LINE__ )
  per_field_proper_vef_lid_in_owner_cell = -1
  
  call memalloc ( this%get_num_fields(), triangulation%get_num_vefs(), per_field_improper_vef_lid_in_owner_cell,  __FILE__, __LINE__ )
  per_field_improper_vef_lid_in_owner_cell = -1
  
  call memalloc( block_layout%get_num_blocks(), blocks_current_num_dofs, __FILE__, __LINE__ )
  blocks_current_num_dofs = 0
  
  call memalloc( num_fields, fields_current_dof, __FILE__, __LINE__ )
  fields_current_dof = 0

  if (num_fields > 1) then
    do field_id=1, num_fields
       block_id = block_layout%get_block_id(field_id)
       fields_current_dof(field_id) = fields_current_dof(field_id) + blocks_current_num_dofs(block_id)
       blocks_current_num_dofs(block_id) = blocks_current_num_dofs(block_id) + num_dofs_x_field(field_id)
    end do
  end if

  ! First process full cells as always
  call fe%first()
  do while ( .not. fe%has_finished())
    if ( fe%is_local() .and. (.not. fe%is_cut()) ) then
      do field_id=1, this%get_num_fields()
       if ( .not. fe%is_void(field_id)) then
         call fe%generate_own_dofs_cell ( field_id, fields_current_dof(field_id) )
         do ivef= 1, fe%get_num_vefs()
           call fe%get_vef(ivef,vef)
           if ( vef%has_free_dofs(field_id,coarser_fe) ) then
             vef_lid = abs(fe%get_vef_gid(ivef))
             is_owner = .false.
             if ( vef%is_proper() ) then
               is_owner = ( owner_cell_gid_x_field_and_proper_vef( field_id, vef_lid ) == -1 )
             else 
               is_owner = ( owner_cell_gid_x_field_and_improper_vef( field_id, vef_lid ) == -1 )
             end if
             if ( is_owner ) then
               previous_dof_block = fields_current_dof(field_id)
               call fe%generate_own_dofs_vef ( ivef, field_id, fields_current_dof(field_id), free_dofs_loop=.true. )
               if ( previous_dof_block < fields_current_dof(field_id) ) then
                 if ( vef%is_proper() ) then
                   owner_cell_gid_x_field_and_proper_vef ( field_id, vef_lid ) = fe%get_gid() 
                   per_field_proper_vef_lid_in_owner_cell ( field_id, vef_lid ) = ivef 
                 else
                   owner_cell_gid_x_field_and_improper_vef ( field_id, vef_lid ) = fe%get_gid() 
                   per_field_improper_vef_lid_in_owner_cell ( field_id, vef_lid ) = ivef 
                 end if
               end if
             else
               if ( vef%is_proper() ) then
                 source_cell_id = owner_cell_gid_x_field_and_proper_vef(field_id, vef_lid)
                 source_vef_lid = per_field_proper_vef_lid_in_owner_cell(field_id,vef_lid)
               else
                 source_cell_id = owner_cell_gid_x_field_and_improper_vef(field_id, vef_lid)
                 source_vef_lid = per_field_improper_vef_lid_in_owner_cell(field_id,vef_lid)
               end if
               call source_fe%set_gid( source_cell_id )
               call fe%fetch_own_dofs_vef_from_source_fe ( ivef, source_fe, source_vef_lid, field_id ) 
             end if
           else 
             assert ( fe%get_vef_gid(ivef) < 0 )
             vef_lid = abs(fe%get_vef_gid(ivef))
             if ( owner_cell_gid_x_field_and_improper_vef( field_id, vef_lid ) == -1 ) then
               previous_fixed_dof = current_fixed_dof
               call fe%generate_own_dofs_vef ( ivef, field_id, current_fixed_dof, free_dofs_loop=.false.)
               if (previous_fixed_dof < current_fixed_dof) then
                 owner_cell_gid_x_field_and_improper_vef( field_id, vef_lid ) = fe%get_gid()
                 per_field_improper_vef_lid_in_owner_cell ( field_id, vef_lid ) = ivef 
               end if
             else 
               call source_fe%set_gid(owner_cell_gid_x_field_and_improper_vef(field_id, vef_lid))
               call fe%fetch_own_dofs_vef_from_source_fe ( ivef, source_fe, per_field_improper_vef_lid_in_owner_cell(field_id,vef_lid),field_id ) 
             end if
           end if
         end do
       end if
       call fe%determine_has_fixed_dofs(field_id)
       call fe%determine_has_hanging_dofs(field_id)
      end do
    end if
    call fe%next()
  end do  

  this%num_hanging_dofs_full_cells =  current_fixed_dof - this%get_num_fixed_dofs()

  ! Process cut cells to assign free dofs in the proper vefs that constrain imporper vefs of full cells
  call fe%first()
  do while ( .not. fe%has_finished())
    if ( fe%is_local() .and. fe%is_cut() ) then
      do field_id=1, this%get_num_fields()
        if ( .not. fe%is_void(field_id)) then
          do ivef= 1, fe%get_num_vefs()
            call fe%get_vef(ivef,vef)
            if ( vef%is_proper() ) then
              vef_lid = abs(fe%get_vef_gid(ivef))
              if ( proper_vef_constrains_full_cell(field_id,vef_lid) ) then
                is_owner = ( owner_cell_gid_x_field_and_proper_vef( field_id, vef_lid ) == -1 )
                if ( is_owner ) then
                  previous_dof_block = fields_current_dof(field_id)
                  call fe%generate_own_dofs_vef ( ivef, field_id, fields_current_dof(field_id), free_dofs_loop=.true. )
                  if ( previous_dof_block < fields_current_dof(field_id) ) then
                    owner_cell_gid_x_field_and_proper_vef ( field_id, vef_lid ) = fe%get_gid() 
                    per_field_proper_vef_lid_in_owner_cell ( field_id, vef_lid ) = ivef 
                  end if
                end if
              end if
            end if
          end do
        end if
        call fe%determine_has_fixed_dofs(field_id)
        call fe%determine_has_hanging_dofs(field_id)
      end do
    end if
    call fe%next()
  end do  

  ! Process all cut cells to assign fixed dofs due to cell aggregation
  call fe%first()
  do while ( .not. fe%has_finished())
    if ( fe%is_local() .and. ( fe%is_cut()) ) then
      do field_id=1, this%get_num_fields()
        if ( .not. fe%is_void(field_id)) then
          call fe%generate_own_dofs_cell ( field_id, current_fixed_dof, are_free_dofs=.false. )
          do ivef= 1, fe%get_num_vefs()
            call fe%get_vef(ivef,vef)
            if ( vef%has_free_dofs(field_id,coarser_fe) ) then
              vef_lid = abs(fe%get_vef_gid(ivef))
              is_owner = .false.
              if ( vef%is_proper() ) then
                is_owner = ( owner_cell_gid_x_field_and_proper_vef( field_id, vef_lid ) == -1 )
              else 
                is_owner = ( owner_cell_gid_x_field_and_improper_vef( field_id, vef_lid ) == -1 )
              end if
              if ( is_owner ) then
                previous_fixed_dof = current_fixed_dof
                call fe%generate_own_dofs_vef ( ivef, field_id, current_fixed_dof, free_dofs_loop=.false. )
                 if (previous_fixed_dof < current_fixed_dof) then
                  if ( vef%is_proper() ) then
                    owner_cell_gid_x_field_and_proper_vef ( field_id, vef_lid ) = fe%get_gid() 
                    per_field_proper_vef_lid_in_owner_cell ( field_id, vef_lid ) = ivef 
                  else
                    owner_cell_gid_x_field_and_improper_vef ( field_id, vef_lid ) = fe%get_gid() 
                    per_field_improper_vef_lid_in_owner_cell ( field_id, vef_lid ) = ivef 
                  end if
                end if
              end if
            end if
          end do
        end if
        call fe%determine_has_fixed_dofs(field_id)
        call fe%determine_has_hanging_dofs(field_id)
      end do
    end if
    call fe%next()
  end do  

  this%num_aggregated_dofs = current_fixed_dof - (this%num_hanging_dofs_full_cells + this%get_num_fixed_dofs())

  ! Process all cut cells to assign fixed dofs due to hanging nodes, and pick up from owners to non-owners
  call fe%first()
  do while ( .not. fe%has_finished())
    if ( fe%is_local() .and. ( fe%is_cut()) ) then
      do field_id=1, this%get_num_fields()
        if ( .not. fe%is_void(field_id)) then
          do ivef= 1, fe%get_num_vefs()
            call fe%get_vef(ivef,vef)
            if ( vef%has_free_dofs(field_id,coarser_fe) ) then
              vef_lid = abs(fe%get_vef_gid(ivef))
              is_owner = .false.
              if ( vef%is_proper() ) then
                is_owner = ( owner_cell_gid_x_field_and_proper_vef( field_id, vef_lid ) == -1 )
              else 
                is_owner = ( owner_cell_gid_x_field_and_improper_vef( field_id, vef_lid ) == -1 )
              end if
              if ( .not. is_owner ) then
                if ( vef%is_proper() ) then
                  source_cell_id = owner_cell_gid_x_field_and_proper_vef(field_id, vef_lid)
                  source_vef_lid = per_field_proper_vef_lid_in_owner_cell(field_id,vef_lid)
                else
                  source_cell_id = owner_cell_gid_x_field_and_improper_vef(field_id, vef_lid)
                  source_vef_lid = per_field_improper_vef_lid_in_owner_cell(field_id,vef_lid)
                end if
                call source_fe%set_gid( source_cell_id )
                call fe%fetch_own_dofs_vef_from_source_fe ( ivef, source_fe, source_vef_lid, field_id ) 
              end if
            else 
              assert ( fe%get_vef_gid(ivef) < 0 )
              vef_lid = abs(fe%get_vef_gid(ivef))
              if ( owner_cell_gid_x_field_and_improper_vef( field_id, vef_lid ) == -1 ) then
                previous_fixed_dof = current_fixed_dof
                call fe%generate_own_dofs_vef ( ivef, field_id, current_fixed_dof, free_dofs_loop=.false.)
                if (previous_fixed_dof < current_fixed_dof) then
                  owner_cell_gid_x_field_and_improper_vef( field_id, vef_lid ) = fe%get_gid()
                  per_field_improper_vef_lid_in_owner_cell ( field_id, vef_lid ) = ivef 
                end if
              else 
                call source_fe%set_gid(owner_cell_gid_x_field_and_improper_vef(field_id, vef_lid))
                call fe%fetch_own_dofs_vef_from_source_fe ( ivef, source_fe, per_field_improper_vef_lid_in_owner_cell(field_id,vef_lid), field_id ) 
              end if
            end if
          end do
        end if
        call fe%determine_has_fixed_dofs(field_id)
        call fe%determine_has_hanging_dofs(field_id)
      end do
    end if
    call fe%next()
  end do  

  this%num_hanging_dofs_other = current_fixed_dof - ( this%num_aggregated_dofs + this%num_hanging_dofs_full_cells + this%get_num_fixed_dofs())
  
#ifdef DEBUG
  call fe%first()
  do while(.not. fe%has_finished())
     mcheck(.not. fe%is_ghost(),'For the moment, this subroutine only works for serial runs')
     call fe%next()    
  end do
#endif
  
  ! Set #DoFs per field and block in case of single-field, single-block problem
  ! (as we did not call fe_space%count_dofs() in this case)
  if ( num_fields == 1 ) then
    field_id = 1
    block_id = 1
    num_dofs_x_field(field_id) = fields_current_dof(field_id)
    call block_layout%set_block_num_dofs(block_id,num_dofs_x_field(field_id))
  end if

  ! This is needed since we cannot access to private variables of the father
  do field_id=1, this%get_num_fields()
    call this%set_field_num_dofs(field_id,num_dofs_x_field(field_id))
  end do
  
  call this%set_num_hanging_dofs( current_fixed_dof - this%get_num_fixed_dofs() )
  call this%set_num_fixed_dofs(current_fixed_dof)

  assert(this%get_num_hanging_dofs() == this%num_hanging_dofs_full_cells + this%num_aggregated_dofs + this%num_hanging_dofs_other )
  assert(this%get_num_fixed_dofs() == this%get_num_dirichlet_dofs() + this%num_hanging_dofs_full_cells + this%num_aggregated_dofs + this%num_hanging_dofs_other )
  
  call this%free_fe_cell_iterator(coarser_fe)
  call this%free_fe_cell_iterator(source_fe)
  call this%free_fe_cell_iterator(fe)
  call this%free_fe_vef_iterator(vef)
  call this%free_fe_vef_iterator(coarser_vef)
  call memfree( blocks_current_num_dofs, __FILE__, __LINE__ )
  call memfree( fields_current_dof     , __FILE__, __LINE__ )
  call memfree ( owner_cell_gid_x_field_and_proper_vef,  __FILE__, __LINE__ )
  call memfree ( owner_cell_gid_x_field_and_improper_vef,  __FILE__, __LINE__ )
  call memfree ( per_field_proper_vef_lid_in_owner_cell,  __FILE__, __LINE__ )
  call memfree ( per_field_improper_vef_lid_in_owner_cell,  __FILE__, __LINE__ )
  call memfree (num_dofs_x_field,__FILE__,__LINE__)
  call memfree ( proper_vef_constrains_full_cell,  __FILE__, __LINE__ )
end subroutine suhpafs_list_dofs 

!========================================================================================
subroutine suhpafs_setup_hanging_node_constraints ( this )
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout) :: this   

  type(std_vector_integer_ip_t) , pointer :: ptr_constraining_free_dofs
  type(std_vector_integer_ip_t) , pointer :: ptr_constraining_dirichlet_dofs
  type(std_vector_integer_ip_t) , pointer :: constraining_free_dofs
  type(std_vector_real_rp_t)    , pointer :: constraining_free_dofs_coefficients
  type(std_vector_integer_ip_t) , pointer :: constraining_dirichlet_dofs
  type(std_vector_real_rp_t)    , pointer :: constraining_dirichlet_dofs_coefficients
  type(std_vector_real_rp_t)    , pointer :: constraints_independent_term

  ! We want to use this subroutine only for aggregation-based FE spaces
  if (.not. this%use_constraints) then
  call this%serial_fe_space_t%setup_hanging_node_constraints()
    return
  end if

  ptr_constraining_free_dofs                 => this%get_ptr_constraining_free_dofs()
  ptr_constraining_dirichlet_dofs            => this%get_ptr_constraining_dirichlet_dofs()
  constraining_free_dofs                     => this%get_constraining_free_dofs()
  constraining_free_dofs_coefficients        => this%get_constraining_free_dofs_coefficients()
  constraining_dirichlet_dofs                => this%get_constraining_dirichlet_dofs()
  constraining_dirichlet_dofs_coefficients   => this%get_constraining_dirichlet_dofs_coefficients()
  constraints_independent_term               => this%get_constraints_independent_term()

  call ptr_constraining_free_dofs%resize(1,1)
  call ptr_constraining_dirichlet_dofs%resize(1,1)
  call constraining_free_dofs%resize(0)
  call constraining_free_dofs_coefficients%resize(0)
  call constraining_dirichlet_dofs%resize(0)
  call constraining_dirichlet_dofs_coefficients%resize(0)
  call constraints_independent_term%resize(0)

  call this%setup_only_hanging_node_constraints(full_cells_loop=.true.)
  call this%setup_only_cell_aggregation_constraints()
  call this%setup_only_hanging_node_constraints(full_cells_loop=.false.)

end subroutine suhpafs_setup_hanging_node_constraints

!========================================================================================
subroutine suhpafs_set_up_cell_integration ( this, interpolation_duties, cell_map_duties )
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), target, intent(inout) :: this
  type(interpolation_duties_t), optional, intent(in) :: interpolation_duties(:)
  type(cell_map_duties_t)     , optional, intent(in)    :: cell_map_duties
  call this%serial_fe_space_t%set_up_cell_integration(interpolation_duties, cell_map_duties)
  call this%unfitted_integration%init_cut_integration()
  call this%unfitted_integration%init_cut_boundary_integration()
end subroutine suhpafs_set_up_cell_integration

!========================================================================================
subroutine suhpafs_set_up_facet_integration ( this )
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), target, intent(inout) :: this
  call this%serial_fe_space_t%set_up_facet_integration()
  call this%unfitted_integration%init_cut_fitted_facets_integration()
end subroutine suhpafs_set_up_facet_integration

!========================================================================================
subroutine suhpafs_setup_only_hanging_node_constraints ( this, full_cells_loop )
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout) :: this
  logical, intent(in) :: full_cells_loop

  class(fe_cell_iterator_t), allocatable :: fe
  class(fe_cell_iterator_t), allocatable :: coarser_fe
  type(fe_vef_iterator_t) :: fe_vef, fe_vef_bis, coarser_vef
  type(list_iterator_t) :: fe_own_dofs_on_vef_iterator
  type(list_iterator_t) :: fe_dofs_on_vef_iterator 
  type(list_iterator_t) :: coarser_fe_dofs_on_vef_iterator
  integer(ip) :: improper_vef_lid
  integer(ip) :: block_id, field_id
  class(reference_fe_t), pointer :: reference_fe, coarser_reference_fe
  integer(ip), pointer :: fe_dofs(:), coarser_fe_fe_dofs(:)
  integer(ip) :: istat, i, icell, min_cell_gid
  integer(ip) :: improper_dof_lid, hanging_dof_lid
  integer(ip) :: improper_vef_ivef, coarser_fe_ivef, coarse_fe_subvef
  integer(ip), pointer :: field_blocks(:)
  integer(ip) :: qpoint, ishape_fe, ishape_coarser_fe
  type(interpolation_t), pointer :: h_refinement_interpolation
  integer(ip), pointer :: h_refinement_subedge_permutation(:,:,:)
  integer(ip), pointer :: h_refinement_subfacet_permutation(:,:,:)
  real(rp) :: coefficient
  integer(ip) :: num_cell_vertices, num_cell_edges, num_cell_faces
  integer(ip) :: num_subedges_x_edge, num_subfaces_x_face
  integer(ip) :: vef_lid, facet_lid
  type(list_t), pointer :: facets_n_face
  type(list_iterator_t) :: facets_n_face_iterator
  type(list_iterator_t) :: dofs_n_facet_iterator
  integer(ip) :: facet_dof

  class(triangulation_t), pointer :: triangulation
  integer(ip) :: num_hanging_dofs
  integer(ip) :: num_fixed_dofs_on_entry
  integer(ip) :: num_free_master_dofs
  integer(ip) :: num_dirichlet_master_dofs
  integer(ip) :: ifree
  integer(ip) :: idirichlet
  integer(ip) :: coarser_hanging_dof_lid

  type(std_vector_integer_ip_t) , pointer :: this_ptr_constraining_free_dofs
  type(std_vector_integer_ip_t) , pointer :: this_ptr_constraining_dirichlet_dofs
  type(std_vector_integer_ip_t) , pointer :: this_constraining_free_dofs
  type(std_vector_real_rp_t)    , pointer :: this_constraining_free_dofs_coefficients
  type(std_vector_integer_ip_t) , pointer :: this_constraining_dirichlet_dofs
  type(std_vector_real_rp_t)    , pointer :: this_constraining_dirichlet_dofs_coefficients
  type(std_vector_real_rp_t)    , pointer :: this_constraints_independent_term

  type(std_vector_integer_ip_t) :: ptr_constraining_free_dofs
  type(std_vector_integer_ip_t) :: ptr_constraining_dirichlet_dofs
  type(std_vector_integer_ip_t) :: constraining_free_dofs
  type(std_vector_real_rp_t)    :: constraining_free_dofs_coefficients
  type(std_vector_integer_ip_t) :: constraining_dirichlet_dofs
  type(std_vector_real_rp_t)    :: constraining_dirichlet_dofs_coefficients
  type(std_vector_real_rp_t)    :: constraints_independent_term

  ! Re-size to 0 to force re-initialization during second resize (to the actual/correct size)
  call ptr_constraining_free_dofs%resize(0)
  call ptr_constraining_dirichlet_dofs%resize(0)
  call constraining_free_dofs%resize(0)
  call constraining_free_dofs_coefficients%resize(0)
  call constraining_dirichlet_dofs%resize(0)
  call constraining_dirichlet_dofs_coefficients%resize(0)
  call constraints_independent_term%resize(0)

  if (full_cells_loop) then
    num_hanging_dofs = this%num_hanging_dofs_full_cells
    num_fixed_dofs_on_entry = this%get_num_dirichlet_dofs()
  else
    num_hanging_dofs = this%num_hanging_dofs_other
    num_fixed_dofs_on_entry = this%get_num_dirichlet_dofs() + this%num_hanging_dofs_full_cells + this%num_aggregated_dofs
  end if
  
  if ( num_hanging_dofs == 0 ) return

  this_ptr_constraining_free_dofs                 => this%get_ptr_constraining_free_dofs()
  this_ptr_constraining_dirichlet_dofs            => this%get_ptr_constraining_dirichlet_dofs()
  this_constraining_free_dofs                     => this%get_constraining_free_dofs()
  this_constraining_free_dofs_coefficients        => this%get_constraining_free_dofs_coefficients()
  this_constraining_dirichlet_dofs                => this%get_constraining_dirichlet_dofs()
  this_constraining_dirichlet_dofs_coefficients   => this%get_constraining_dirichlet_dofs_coefficients()
  this_constraints_independent_term               => this%get_constraints_independent_term()
  
  field_blocks => this%get_field_blocks()

  triangulation => this%get_triangulation()
  
  call ptr_constraining_free_dofs%resize(num_hanging_dofs+1,0)
  call ptr_constraining_dirichlet_dofs%resize(num_hanging_dofs+1,0)
  call constraining_free_dofs%resize(num_hanging_dofs)
  call constraining_free_dofs_coefficients%resize(num_hanging_dofs)
  call constraining_dirichlet_dofs%resize(num_hanging_dofs)
  call constraining_dirichlet_dofs_coefficients%resize(num_hanging_dofs)
  call constraints_independent_term%resize(num_hanging_dofs,0.0)

  call this%create_fe_cell_iterator(fe)
  call this%create_fe_cell_iterator(coarser_fe)
  call this%create_fe_vef_iterator(fe_vef)
  call this%create_fe_vef_iterator(fe_vef_bis)
  call this%create_fe_vef_iterator(coarser_vef)
  
  reference_fe => fe%get_reference_fe(1)
  num_cell_vertices = reference_fe%get_num_vertices()
  if  (triangulation%get_num_dims() == 3) then
    num_cell_edges       = reference_fe%get_num_n_faces_of_dim(1)
    num_subfaces_x_face  = 4
    num_subedges_x_edge  = 2 
  else
    num_cell_edges       = 0
    num_subfaces_x_face  = 2
  end if  
  num_cell_faces = reference_fe%get_num_facets()
  
  allocate(fe_dofs(this%get_num_fields()), stat=istat); check(istat==0);
  allocate(coarser_fe_fe_dofs(this%get_num_fields()), stat=istat); check(istat==0);

  ! Computation of constraints     
  do improper_vef_lid = 1, triangulation%get_num_improper_vefs()
     call fe_vef%set_gid(-improper_vef_lid)

     ! Improper VEFs which are solely on ghost cells might have zero
     ! improper cells around in 3D
     if ( fe_vef%get_num_improper_cells_around() == 0 ) then
       cycle
     end if 
     
     do field_id=1, this%get_num_fields()
        
        ! Retrieve all data related to the current improper vef 
        ! and one of the cells that owns it
        do icell = 1,fe_vef%get_num_cells_around()
           call fe_vef%get_cell_around(icell,fe)
           if ( .not. fe%is_void(field_id) ) exit
        end do
        if ( fe%is_void(field_id) ) cycle
        improper_vef_ivef = fe%get_vef_lid_from_gid(fe_vef%get_gid())
        call fe%get_field_fe_dofs(field_id,fe_dofs)
        
        ! Retrieve all data related to the first improper cell around current improper vef
        do icell = 1,fe_vef%get_num_improper_cells_around()
           call fe_vef%get_improper_cell_around(icell,coarser_fe)
           if ( .not. coarser_fe%is_void(field_id) ) exit
        end do
        if ( coarser_fe%is_void(field_id) ) cycle
        coarser_fe_ivef = fe_vef%get_improper_cell_around_ivef(icell)
        call coarser_fe%get_field_fe_dofs(field_id,coarser_fe_fe_dofs)
        
        reference_fe => fe%get_reference_fe(field_id)
        coarser_reference_fe  => coarser_fe%get_reference_fe(field_id)
        block_id = field_blocks(field_id)
        fe_own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(improper_vef_ivef)
        do while (.not. fe_own_dofs_on_vef_iterator%is_upper_bound() )
           improper_dof_lid = fe_dofs(fe_own_dofs_on_vef_iterator%get_current())
           ishape_fe = fe_own_dofs_on_vef_iterator%get_current()

           if ( fe%is_free_dof(improper_dof_lid) ) exit

           improper_dof_lid = abs(improper_dof_lid)
           hanging_dof_lid  = improper_dof_lid - num_fixed_dofs_on_entry
           if (full_cells_loop) then
             if ( hanging_dof_lid > num_hanging_dofs ) then
               exit
             end if
           else
             if ( hanging_dof_lid <= 0 ) then
               exit
             end if
           end if

           coarser_fe_dofs_on_vef_iterator = coarser_reference_fe%create_dofs_on_n_face_iterator(coarser_fe_ivef)
           do while (.not. coarser_fe_dofs_on_vef_iterator%is_upper_bound() )
              ishape_coarser_fe = coarser_fe_dofs_on_vef_iterator%get_current()
              if ( coarser_reference_fe%get_component_node(ishape_coarser_fe) == reference_fe%get_component_node(ishape_fe) ) then
                if ( fe%is_strong_dirichlet_dof( coarser_fe_fe_dofs(coarser_fe_dofs_on_vef_iterator%get_current()) ) ) then
                  call ptr_constraining_dirichlet_dofs%set(hanging_dof_lid+1, &
                                                                ptr_constraining_dirichlet_dofs%get(hanging_dof_lid+1)+1)
                else if ( fe%is_free_dof( coarser_fe_fe_dofs(coarser_fe_dofs_on_vef_iterator%get_current()) ) ) then
                  call ptr_constraining_free_dofs%set(hanging_dof_lid+1, &
                                                           ptr_constraining_free_dofs%get(hanging_dof_lid+1)+1)
                else if ( fe%is_hanging_dof( coarser_fe_fe_dofs(coarser_fe_dofs_on_vef_iterator%get_current()) ) ) then
                  if (full_cells_loop) then
                    mcheck(.false.,'We cannot end-up here due to 2:1 condition')
                  else 
                    coarser_hanging_dof_lid = abs(coarser_fe_fe_dofs(coarser_fe_dofs_on_vef_iterator%get_current())) - this%get_num_dirichlet_dofs()
                    massert( ((this%num_hanging_dofs_full_cells+1)<=coarser_hanging_dof_lid) .and.  (coarser_hanging_dof_lid<=this%num_hanging_dofs_full_cells+this%num_aggregated_dofs), 'Assert hast to be true due to 2:1 condition' )
                    num_free_master_dofs = this_ptr_constraining_free_dofs%get(coarser_hanging_dof_lid+1)&
                                         - this_ptr_constraining_free_dofs%get(coarser_hanging_dof_lid)
                    num_dirichlet_master_dofs = this_ptr_constraining_dirichlet_dofs%get(coarser_hanging_dof_lid+1)&
                                              - this_ptr_constraining_dirichlet_dofs%get(coarser_hanging_dof_lid)
                    call ptr_constraining_free_dofs%set(hanging_dof_lid+1, ptr_constraining_free_dofs%get(hanging_dof_lid+1)+num_free_master_dofs)
                    call ptr_constraining_dirichlet_dofs%set(hanging_dof_lid+1, ptr_constraining_dirichlet_dofs%get(hanging_dof_lid+1)+num_dirichlet_master_dofs)
                  end if 
                else
                  mcheck(.false.,'Dof is either free dirichlet or hanging')
                end if
              end if
              call coarser_fe_dofs_on_vef_iterator%next()
           end do
           call fe_own_dofs_on_vef_iterator%next() 
        end do
     end do
  end do
   
  
  call ptr_constraining_free_dofs%transform_length_to_header()
  call constraining_free_dofs%resize(ptr_constraining_free_dofs%get(ptr_constraining_free_dofs%size())-1)
  call constraining_free_dofs_coefficients%resize(ptr_constraining_free_dofs%get(ptr_constraining_free_dofs%size())-1)
  call ptr_constraining_dirichlet_dofs%transform_length_to_header()
  
  call constraining_dirichlet_dofs%resize(ptr_constraining_dirichlet_dofs%get(ptr_constraining_dirichlet_dofs%size())-1)
  call constraining_dirichlet_dofs_coefficients%resize(ptr_constraining_dirichlet_dofs%get(ptr_constraining_dirichlet_dofs%size())-1)
  
  ! Computation of constraints     
  do improper_vef_lid = 1, triangulation%get_num_improper_vefs()
     call fe_vef%set_gid(-improper_vef_lid)

     ! Improper VEFs which are solely on ghost cells might have zero
     ! improper cells around in 3D
     if ( fe_vef%get_num_improper_cells_around() == 0 ) then
       cycle
     end if 
     
     do field_id=1, this%get_num_fields()
        ! Retrieve all data related to the current improper vef 
        ! and one of the cells that owns it
        do icell = 1,fe_vef%get_num_cells_around()
           call fe_vef%get_cell_around(icell,fe)
           if ( .not. fe%is_void(field_id) ) exit
        end do
        if ( fe%is_void(field_id) ) cycle
        improper_vef_ivef = fe%get_vef_lid_from_gid(fe_vef%get_gid())
        call fe%get_field_fe_dofs(field_id,fe_dofs)
        
        ! Retrieve all data related to the first improper cell around current improper vef
        do icell = 1,fe_vef%get_num_improper_cells_around()
           call fe_vef%get_improper_cell_around(icell,coarser_fe)
           if ( .not. coarser_fe%is_void(field_id) ) exit
        end do
        if ( coarser_fe%is_void(field_id) ) cycle
        coarser_fe_ivef  = fe_vef%get_improper_cell_around_ivef(icell)
        coarse_fe_subvef = fe_vef%get_improper_cell_around_subvef(icell)
        call coarser_fe%get_field_fe_dofs(field_id,coarser_fe_fe_dofs)
        call coarser_fe%get_vef(coarser_fe_ivef,coarser_vef)

        reference_fe => fe%get_reference_fe(field_id)
        coarser_reference_fe => coarser_fe%get_reference_fe(field_id)
        
        h_refinement_subedge_permutation => coarser_reference_fe%get_h_refinement_subedge_permutation()
        h_refinement_subfacet_permutation => coarser_reference_fe%get_h_refinement_subfacet_permutation()
        
        block_id = field_blocks(field_id)
        fe_own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(improper_vef_ivef)
        fe_dofs_on_vef_iterator = reference_fe%create_dofs_on_n_face_iterator(improper_vef_ivef)
        do while (.not. fe_own_dofs_on_vef_iterator%is_upper_bound() )
           ishape_fe = fe_own_dofs_on_vef_iterator%get_current()
           improper_dof_lid = fe_dofs(ishape_fe)
           assert ( fe%is_fixed_dof(improper_dof_lid) )
           improper_dof_lid = abs(improper_dof_lid)
           hanging_dof_lid  = improper_dof_lid - num_fixed_dofs_on_entry
           if (full_cells_loop) then
             if ( hanging_dof_lid > num_hanging_dofs ) then
               exit
             end if
           else
             if ( hanging_dof_lid <= 0 ) then
               exit
             end if
           end if
           
           call fe_dofs_on_vef_iterator%begin() 
           do while (.not. fe_dofs_on_vef_iterator%is_upper_bound() )
             if ( fe_dofs_on_vef_iterator%get_current() == ishape_fe ) exit
             call fe_dofs_on_vef_iterator%next() 
           end do
           assert (.not. fe_dofs_on_vef_iterator%is_upper_bound() )
           
           if ( fe_vef%get_dim() == 0 ) then ! vef is a corner (2D/3D)
              if ( coarser_vef%get_dim()  == 1 .and. triangulation%get_num_dims() == 3) then
                 qpoint = h_refinement_subedge_permutation(coarser_fe_ivef-num_cell_vertices,num_subedges_x_edge,1)
              else
                 qpoint = h_refinement_subfacet_permutation(coarser_fe_ivef-num_cell_vertices-num_cell_edges,num_subfaces_x_face,1)
              end if
           else if ( fe_vef%get_dim()  == 1 .and. triangulation%get_num_dims() == 3 .and. coarse_fe_subvef > 0 ) then 
              qpoint = h_refinement_subedge_permutation(coarser_fe_ivef-num_cell_vertices, &
                                                        coarse_fe_subvef, &
                                                        fe_dofs_on_vef_iterator%get_distance_to_lower_bound())
           else if ( fe_vef%get_dim()  == 1 .and. triangulation%get_num_dims() == 3 .and. coarse_fe_subvef < 0 ) then
              assert ( fe_vef%get_num_cells_around() == 2 )
              ! Go over cells around fe_vef(), and find the one with the minimum global identifier
              call fe_vef%get_cell_around(1,fe)
              min_cell_gid=fe%get_gid()
              call fe_vef%get_cell_around(2,fe)
              min_cell_gid=min(fe%get_gid(),min_cell_gid)
              call fe%set_gid(min_cell_gid)
              
              call fe%get_field_fe_dofs(field_id,fe_dofs)
              
              reference_fe  => fe%get_reference_fe(field_id)    
              facets_n_face => reference_fe%get_facets_n_face()      
                            
              ! Go over faces around fe_vef in cell with minimum global identifier
              facet_loop: do facet_lid = reference_fe%get_first_facet_id(), &
                                         reference_fe%get_first_facet_id() + reference_fe%get_num_facets()-1
                  call fe_vef_bis%set_gid(fe%get_vef_gid(facet_lid))
                  if (.not. fe_vef_bis%is_proper()) then
                    facets_n_face_iterator = facets_n_face%create_iterator(facet_lid)
                    do while (.not. facets_n_face_iterator%is_upper_bound())
                      if (fe%get_vef_gid(facets_n_face_iterator%get_current()) == fe_vef%get_gid() ) then
                        exit facet_loop
                      end if
                      call facets_n_face_iterator%next()
                    end do 
                  end if
              end do facet_loop
              
              assert(facet_lid<=reference_fe%get_first_facet_id() + reference_fe%get_num_facets()-1)
              
              ! Go over DoFs on facet, and locate the facet dof LID corresponding to the edge DoF 
              facet_dof=1
              dofs_n_facet_iterator = reference_fe%create_dofs_n_face_iterator(facet_lid)
              do while (.not. dofs_n_facet_iterator%is_upper_bound())
                if (fe_dofs(dofs_n_facet_iterator%get_current()) == -improper_dof_lid) then
                  exit
                end if  
                call dofs_n_facet_iterator%next()
                facet_dof = facet_dof+1
              end do 
              assert (.not. dofs_n_facet_iterator%is_upper_bound())
                            
              qpoint = h_refinement_subfacet_permutation(coarser_fe_ivef-num_cell_vertices-num_cell_edges,&
                                                         abs(coarse_fe_subvef),&
                                                         facet_dof)              
           else if (fe_vef%get_dim() == triangulation%get_num_dims()-1) then ! vef is a face (2D/3D)
              qpoint = h_refinement_subfacet_permutation(coarser_fe_ivef-num_cell_vertices-num_cell_edges, &
                                                        coarse_fe_subvef, &
                                                        fe_dofs_on_vef_iterator%get_distance_to_lower_bound())
           end if
           
           coarser_fe_dofs_on_vef_iterator = coarser_reference_fe%create_dofs_on_n_face_iterator(coarser_fe_ivef)
           do while (.not. coarser_fe_dofs_on_vef_iterator%is_upper_bound() )
              ishape_coarser_fe = coarser_fe_dofs_on_vef_iterator%get_current() 
              if ( coarser_reference_fe%get_component_node(ishape_coarser_fe) == reference_fe%get_component_node(ishape_fe) ) then
              
                ! Evaluate coefficient
                select type(coarser_reference_fe)
                  type is (hex_lagrangian_reference_fe_t)
                  call coarser_reference_fe%get_h_refinement_coefficient(ishape_fe,ishape_coarser_fe,qpoint,coefficient) 
                class default
                  assert(.false.)
                end select
                
                ! Set dependency and coefficient into the corresponding std_vector data structure
                if ( fe%is_strong_dirichlet_dof( coarser_fe_fe_dofs(ishape_coarser_fe) ) ) then
                  call constraining_dirichlet_dofs%set(ptr_constraining_dirichlet_dofs%get(hanging_dof_lid),&
                                                            coarser_fe_fe_dofs(ishape_coarser_fe))
                  call constraining_dirichlet_dofs_coefficients%set(ptr_constraining_dirichlet_dofs%get(hanging_dof_lid),&
                                                                         coefficient)
                  call ptr_constraining_dirichlet_dofs%set(hanging_dof_lid, &
                                                                ptr_constraining_dirichlet_dofs%get(hanging_dof_lid)+1)
                else if ( fe%is_free_dof( coarser_fe_fe_dofs(ishape_coarser_fe) ) ) then
                  call constraining_free_dofs%set(ptr_constraining_free_dofs%get(hanging_dof_lid),&
                                                       coarser_fe_fe_dofs(ishape_coarser_fe))
                  call constraining_free_dofs_coefficients%set(ptr_constraining_free_dofs%get(hanging_dof_lid),&
                                                                    coefficient)
                  call ptr_constraining_free_dofs%set(hanging_dof_lid, &
                                                           ptr_constraining_free_dofs%get(hanging_dof_lid)+1)
                else if ( fe%is_hanging_dof( coarser_fe_fe_dofs(ishape_coarser_fe) ) ) then
                  if (full_cells_loop) then
                    mcheck(.false.,'We cannot end-up here due to 2:1 condition')
                  else 
                    coarser_hanging_dof_lid = abs(coarser_fe_fe_dofs(ishape_coarser_fe)) - this%get_num_dirichlet_dofs()
                    massert( ((this%num_hanging_dofs_full_cells+1)<=coarser_hanging_dof_lid) .and.  (coarser_hanging_dof_lid<=this%num_hanging_dofs_full_cells+this%num_aggregated_dofs), 'Assert hast to be true due to 2:1 condition' )
                    num_free_master_dofs = this_ptr_constraining_free_dofs%get(coarser_hanging_dof_lid+1)&
                                         - this_ptr_constraining_free_dofs%get(coarser_hanging_dof_lid)
                    num_dirichlet_master_dofs = this_ptr_constraining_dirichlet_dofs%get(coarser_hanging_dof_lid+1)&
                                              - this_ptr_constraining_dirichlet_dofs%get(coarser_hanging_dof_lid)
                    do ifree = 1,num_free_master_dofs
                      call constraining_free_dofs%set(ptr_constraining_free_dofs%get(hanging_dof_lid),&
                        this_constraining_free_dofs%get(this_ptr_constraining_free_dofs%get(coarser_hanging_dof_lid)+ifree-1))
                      call constraining_free_dofs_coefficients%set(ptr_constraining_free_dofs%get(hanging_dof_lid),&
                        coefficient*this_constraining_free_dofs_coefficients%get(this_ptr_constraining_free_dofs%get(coarser_hanging_dof_lid)+ifree-1))
                      call ptr_constraining_free_dofs%set(hanging_dof_lid, ptr_constraining_free_dofs%get(hanging_dof_lid)+1)
                    end do
                    do idirichlet = 1,num_dirichlet_master_dofs
                      call constraining_dirichlet_dofs%set(ptr_constraining_dirichlet_dofs%get(hanging_dof_lid),&
                        this_constraining_dirichlet_dofs%get(this_ptr_constraining_dirichlet_dofs%get(coarser_hanging_dof_lid)+idirichlet-1))
                      call constraining_dirichlet_dofs_coefficients%set(ptr_constraining_dirichlet_dofs%get(hanging_dof_lid),&
                        coefficient*this_constraining_dirichlet_dofs_coefficients%get(this_ptr_constraining_dirichlet_dofs%get(coarser_hanging_dof_lid)+idirichlet-1))
                      call ptr_constraining_dirichlet_dofs%set(hanging_dof_lid, ptr_constraining_dirichlet_dofs%get(hanging_dof_lid)+1)
                    end do
                  end if 
                else
                  mcheck(.false.,'Dof is either free dirichlet or hanging')
                end if

              end if
              call coarser_fe_dofs_on_vef_iterator%next()
           end do
           call fe_own_dofs_on_vef_iterator%next() 
        end do
     end do
  end do
  
  do i=ptr_constraining_free_dofs%size(),2,-1
    call ptr_constraining_free_dofs%set(i, ptr_constraining_free_dofs%get(i-1))
  end do
  call ptr_constraining_free_dofs%set(1,1)
  
  do i=ptr_constraining_dirichlet_dofs%size(),2,-1
    call ptr_constraining_dirichlet_dofs%set(i, ptr_constraining_dirichlet_dofs%get(i-1))
  end do
  call ptr_constraining_dirichlet_dofs%set(1,1)
  
  call this%free_fe_cell_iterator(coarser_fe)
  call this%free_fe_cell_iterator(fe)
  call this%free_fe_vef_iterator(fe_vef)
  call this%free_fe_vef_iterator(fe_vef_bis)
  call this%free_fe_vef_iterator(coarser_vef)

  call this_ptr_constraining_free_dofs                 %cat_ptr( ptr_constraining_free_dofs                 )
  call this_ptr_constraining_dirichlet_dofs            %cat_ptr( ptr_constraining_dirichlet_dofs            )
  call this_constraining_free_dofs                     %cat( constraining_free_dofs                     )
  call this_constraining_free_dofs_coefficients        %cat( constraining_free_dofs_coefficients        )
  call this_constraining_dirichlet_dofs                %cat( constraining_dirichlet_dofs                )
  call this_constraining_dirichlet_dofs_coefficients   %cat( constraining_dirichlet_dofs_coefficients   )
  call this_constraints_independent_term               %cat( constraints_independent_term               )

  call ptr_constraining_free_dofs%free()
  call ptr_constraining_dirichlet_dofs%free()
  call constraining_free_dofs%free()
  call constraining_free_dofs_coefficients%free()
  call constraining_dirichlet_dofs%free()
  call constraining_dirichlet_dofs_coefficients%free()
  call constraints_independent_term%free()

end subroutine suhpafs_setup_only_hanging_node_constraints

!========================================================================================
subroutine suhpafs_setup_only_cell_aggregation_constraints ( this )
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout) :: this   

  integer(ip) :: improper_dof_lid
  integer(ip) :: hanging_dof_lid
  class(fe_cell_iterator_t), allocatable :: fe
  class(fe_cell_iterator_t), allocatable :: root_fe
  integer(ip) :: field_id
  integer(ip), pointer :: fe_dofs(:)
  integer(ip), pointer :: root_fe_dofs(:)
  integer(ip) :: idof, root_idof
  integer(ip) :: num_free_dofs_in_root
  integer(ip) :: num_diri_dofs_in_root
  integer(ip) :: current_pos_free
  integer(ip) :: current_pos_diri
  class(reference_fe_t), pointer :: reference_fe
  class(reference_fe_t), pointer :: root_reference_fe
  class(reference_fe_t), pointer :: reference_fe_geo
  type(quadrature_t), pointer :: nodal_quad_ref_fe
  type(cell_map_t), allocatable :: cell_map(:)
  type(cell_map_t), pointer :: root_cell_map
  type(quadrature_t), pointer :: root_fe_quad
  integer(ip) :: iaux
  type(point_t), pointer :: coordinates_nodes_cut_cell(:)
  type(cell_integrator_t), allocatable :: cell_integrator(:)
  type(cell_integrator_t), allocatable :: cell_integrator_NS_XC(:)
  type(cell_integrator_t), allocatable :: cell_integrator_NR_XS(:)
  type(quadrature_t), allocatable :: nodal_quad_in_root_fe(:)
  type(quadrature_t), pointer :: nodal_quad_serendipity
  class(triangulation_t), pointer :: triangulation
  real(rp), allocatable  :: shape_values_scalar(:,:)
  real(rp), allocatable  :: shape_values_scalar_NS_XC(:,:)
  real(rp), allocatable  :: shape_values_scalar_NR_XS(:,:)
  type(vector_field_t), allocatable  :: shape_values_vector(:,:)
  type(vector_field_t), allocatable  :: shape_values_vector_NR_XS(:,:)
  type(point_t), pointer :: coordinates(:)
  integer(ip) :: istat
  logical, allocatable :: visited_hanging_dof_lids(:)
  integer(ip) :: min_fixed_dof_gid, max_fixed_dof_gid
  integer(ip) :: root_hanging_dof_lid
  integer(ip) :: num_free_master_dofs
  integer(ip) :: num_dirichlet_master_dofs
  integer(ip) :: ifree
  integer(ip) :: idirichlet
  logical(ip), allocatable :: first_ref_fe_visited_x_field(:)
  real(rp) :: coefficient
  type(hex_serendipity_reference_fe_t), allocatable :: serendipity_ref_fes(:)
  integer(ip) :: inode_serendipity

  type(std_vector_integer_ip_t) , pointer :: this_ptr_constraining_free_dofs
  type(std_vector_integer_ip_t) , pointer :: this_ptr_constraining_dirichlet_dofs
  type(std_vector_integer_ip_t) , pointer :: this_constraining_free_dofs
  type(std_vector_real_rp_t)    , pointer :: this_constraining_free_dofs_coefficients
  type(std_vector_integer_ip_t) , pointer :: this_constraining_dirichlet_dofs
  type(std_vector_real_rp_t)    , pointer :: this_constraining_dirichlet_dofs_coefficients
  type(std_vector_real_rp_t)    , pointer :: this_constraints_independent_term

  type(std_vector_integer_ip_t) :: ptr_constraining_free_dofs
  type(std_vector_integer_ip_t) :: ptr_constraining_dirichlet_dofs
  type(std_vector_integer_ip_t) :: constraining_free_dofs
  type(std_vector_real_rp_t)    :: constraining_free_dofs_coefficients
  type(std_vector_integer_ip_t) :: constraining_dirichlet_dofs
  type(std_vector_real_rp_t)    :: constraining_dirichlet_dofs_coefficients
  type(std_vector_real_rp_t)    :: constraints_independent_term

  min_fixed_dof_gid = this%get_num_dirichlet_dofs() + this%num_hanging_dofs_full_cells + 1
  max_fixed_dof_gid = this%get_num_dirichlet_dofs() + this%num_hanging_dofs_full_cells + this%num_aggregated_dofs

  this_ptr_constraining_free_dofs                 => this%get_ptr_constraining_free_dofs()
  this_ptr_constraining_dirichlet_dofs            => this%get_ptr_constraining_dirichlet_dofs()
  this_constraining_free_dofs                     => this%get_constraining_free_dofs()
  this_constraining_free_dofs_coefficients        => this%get_constraining_free_dofs_coefficients()
  this_constraining_dirichlet_dofs                => this%get_constraining_dirichlet_dofs()
  this_constraining_dirichlet_dofs_coefficients   => this%get_constraining_dirichlet_dofs_coefficients()
  this_constraints_independent_term               => this%get_constraints_independent_term()

  ! Auxiliary
  triangulation => this%get_triangulation()

  call memalloc(this%num_aggregated_dofs,visited_hanging_dof_lids,__FILE__,__LINE__)

  !Fill the sizes of each sub-list

  ! Init to 0
  ! Re-size to 0 to force re-initialization during second resize (to the actual/correct size)
  call ptr_constraining_free_dofs%resize(0)
  call ptr_constraining_dirichlet_dofs%resize(0)
  call ptr_constraining_free_dofs%resize(this%num_aggregated_dofs+1,0)
  call ptr_constraining_dirichlet_dofs%resize(this%num_aggregated_dofs+1,0)

  ! In our case, this is 0
  call constraints_independent_term%resize(this%num_aggregated_dofs)
  do iaux = 1,this%num_aggregated_dofs
    call constraints_independent_term%set(iaux,0.0_rp)
  end do

  ! Nodes in cut cells might depend on several nodes of their root cell. Count them! and set cut FEs as having hanging nodes.
  ! (We skip Dirichlet Dofs since they are already taken into account in previous loop)
  call this%create_fe_cell_iterator(fe)
  call this%create_fe_cell_iterator(root_fe)
  visited_hanging_dof_lids(:) = .false.
  do while (.not. fe%has_finished())
    if ( fe%is_local() .and. fe%is_cut() ) then

      call root_fe%set_gid(this%aggregate_ids(fe%get_gid()))
       
      do field_id=1, this%get_num_fields()

        call fe%get_field_fe_dofs(field_id, fe_dofs)
        call root_fe%get_field_fe_dofs(field_id, root_fe_dofs)
        reference_fe => fe%get_reference_fe(field_id)
        root_reference_fe => root_fe%get_reference_fe(field_id)

        do idof = 1, size(fe_dofs)
          if ( fe%is_fixed_dof(fe_dofs(idof)) .and. (min_fixed_dof_gid<=abs(fe_dofs(idof))) .and. (abs(fe_dofs(idof))<=max_fixed_dof_gid) ) then
            improper_dof_lid = abs(fe_dofs(idof))
            hanging_dof_lid  = improper_dof_lid - ( this%num_hanging_dofs_full_cells + this%get_num_dirichlet_dofs() )
            if ( .not. visited_hanging_dof_lids(hanging_dof_lid) ) then

              num_free_dofs_in_root = 0
              num_diri_dofs_in_root = 0
              do root_idof = 1,size(root_fe_dofs)
                if ( root_reference_fe%get_component_node(root_idof) == reference_fe%get_component_node(idof) ) then
                  if ( root_fe%is_free_dof(root_fe_dofs(root_idof)) ) then
                    num_free_dofs_in_root = num_free_dofs_in_root + 1
                  else if ( root_fe%is_strong_dirichlet_dof(root_fe_dofs(root_idof)) ) then
                    num_diri_dofs_in_root = num_diri_dofs_in_root + 1
                  else if ( root_fe%is_hanging_dof(root_fe_dofs(root_idof)) ) then
                    root_hanging_dof_lid = abs(root_fe_dofs(root_idof)) - this%get_num_dirichlet_dofs()
                    massert( (1<=root_hanging_dof_lid) .and.  (root_hanging_dof_lid<=this%num_hanging_dofs_full_cells), 'Hanging nodes of full cells are prescribed as always' )
                    num_free_master_dofs = this_ptr_constraining_free_dofs%get(root_hanging_dof_lid+1)&
                                         - this_ptr_constraining_free_dofs%get(root_hanging_dof_lid)
                    num_dirichlet_master_dofs = this_ptr_constraining_dirichlet_dofs%get(root_hanging_dof_lid+1)&
                                              - this_ptr_constraining_dirichlet_dofs%get(root_hanging_dof_lid)
                    num_free_dofs_in_root = num_free_dofs_in_root + num_free_master_dofs
                    num_diri_dofs_in_root = num_diri_dofs_in_root + num_dirichlet_master_dofs
                  else
                    mcheck(.false.,'Dof is either free dirichlet or hanging')
                  end if
                end if
              end do

              call ptr_constraining_free_dofs%set(hanging_dof_lid+1, num_free_dofs_in_root )
              call ptr_constraining_dirichlet_dofs%set(hanging_dof_lid+1, num_diri_dofs_in_root )
              visited_hanging_dof_lids(hanging_dof_lid) = .true.

            end if
          end if
        end do

        call fe%determine_has_hanging_dofs(field_id)

      end do

    end if
    call fe%next()
  end do

  ! Create the header from the sizes
  call ptr_constraining_free_dofs%transform_length_to_header()
  call ptr_constraining_dirichlet_dofs%transform_length_to_header()

  ! Allocate the vectors containing the raw data

  call constraining_free_dofs%resize&
    (ptr_constraining_free_dofs%get(ptr_constraining_free_dofs%size())-1)
  call constraining_free_dofs_coefficients%resize&
    (ptr_constraining_free_dofs%get(ptr_constraining_free_dofs%size())-1)

  call constraining_dirichlet_dofs%resize&
    (ptr_constraining_dirichlet_dofs%get(ptr_constraining_dirichlet_dofs%size())-1)
  call constraining_dirichlet_dofs_coefficients%resize&
    (ptr_constraining_dirichlet_dofs%get(ptr_constraining_dirichlet_dofs%size())-1)

  call memalloc(this%get_num_fields(),first_ref_fe_visited_x_field,__FILE__,__LINE__)
  first_ref_fe_visited_x_field(:) = .true.

  ! Setup Serendipity extension
  if (this%use_serendipity_extension) then

    allocate(serendipity_ref_fes(this%get_num_fields()),stat=istat); check(istat==0)
    allocate(cell_integrator_NS_XC(this%get_num_fields()),stat=istat); check(istat==0)
    allocate(cell_integrator_NR_XS(this%get_num_fields()),stat=istat); check(istat==0)

    do field_id = 1, this%get_num_fields()
      call fe%first_local_non_void(field_id)
      call serendipity_ref_fes(field_id)%create(&
        topology = topology_hex,&
        num_dims = triangulation%get_num_dims(), &
        order = fe%get_order(field_id),&
        field_type = field_type_scalar,&
        conformity = .true.,&
        continuity = .true. )
    end do

  end if

  ! Compute dependencies and coefficients for the rest of constraints
  call fe%first()
  allocate(nodal_quad_in_root_fe(this%get_num_fields()),stat=istat); check(istat==0)
  allocate(cell_integrator(this%get_num_fields()),stat=istat); check(istat==0)
  allocate(cell_map(this%get_num_fields()),stat=istat); check(istat==0)
  iaux = 1
  visited_hanging_dof_lids(:) = .false.
  do while (.not. fe%has_finished())
    if ( fe%is_local() .and. fe%is_cut() ) then

      call root_fe%set_gid(this%aggregate_ids(fe%get_gid()))
      do field_id = 1, this%get_num_fields()

        call fe%get_field_fe_dofs(field_id, fe_dofs)
        call root_fe%get_field_fe_dofs(field_id, root_fe_dofs)

        ! Get the coordinates in the reference space of the nodes associated to the cut cell shape functions
        reference_fe => fe%get_reference_fe(field_id)
        massert(reference_fe%has_nodal_quadrature(),'This routine only work for interpolatory FEs.')
        nodal_quad_ref_fe => reference_fe%get_nodal_quadrature()

        ! Transform them to the physical space
        reference_fe_geo => fe%get_reference_fe_geo()
        if (first_ref_fe_visited_x_field(field_id)) then
          call cell_map(field_id)%create(nodal_quad_ref_fe,reference_fe_geo)
        else
          call cell_map(field_id)%update_interpolation(nodal_quad_ref_fe,reference_fe_geo)
        end if
        coordinates => cell_map(field_id)%get_coordinates()
        call fe%get_nodes_coordinates(coordinates)
        call cell_map(field_id)%compute_quadrature_points_coordinates()
        coordinates_nodes_cut_cell => cell_map(field_id)%get_quadrature_points_coordinates()

        ! Transform back to the reference space of the root_fe
        call root_fe%update_integration()
        root_fe_quad => root_fe%get_quadrature()
        root_cell_map  => root_fe%get_cell_map()
        if (first_ref_fe_visited_x_field(field_id)) then
          call nodal_quad_in_root_fe(field_id)%create(triangulation%get_num_dims(),size(coordinates_nodes_cut_cell))
        end if
        call send_to_reference_space(coordinates_nodes_cut_cell,root_fe_quad,root_cell_map,nodal_quad_in_root_fe(field_id))

        root_reference_fe => root_fe%get_reference_fe(field_id)

        if (this%use_serendipity_extension .and. field_id == 1) then
          ! Get nodal quadrature of serendipity element
          ! We assume that this nodal quadrature is already in the reference space of the root element.
          ! This is true if the root element has hex topology.
          nodal_quad_serendipity => serendipity_ref_fes(field_id)%get_nodal_quadrature()
          massert(root_reference_fe%get_topology() == topology_hex,'We only admid root fes with hex-like topology')
        end if

        if (first_ref_fe_visited_x_field(field_id)) then

          ! Evaluate the root_fe shape functions at the nodes of the cut cell
          call cell_integrator(field_id)%create(nodal_quad_in_root_fe(field_id),root_reference_fe)

          if (this%use_serendipity_extension .and. field_id == 1) then

            ! Evaluate the root_fe shape functions at the serendipity points
            call cell_integrator_NR_XS(field_id)%create(nodal_quad_serendipity,root_reference_fe)

            ! Evaluate the serendipity shape functions at the nodes of the cut cell
            call cell_integrator_NS_XC(field_id)%create(nodal_quad_in_root_fe(field_id),serendipity_ref_fes(field_id))

          end if

          first_ref_fe_visited_x_field(field_id) = .false.
        else

          ! Evaluate the root_fe shape functions at the nodes of the cut cell
          call cell_integrator(field_id)%update_interpolation(nodal_quad_in_root_fe(field_id))

          if (this%use_serendipity_extension .and. field_id == 1) then

            ! Evaluate the root_fe shape functions at the serendipity points
            call cell_integrator_NR_XS(field_id)%update_interpolation(nodal_quad_serendipity)

            ! Evaluate the serendipity shape functions at the nodes of the cut cell
            call cell_integrator_NS_XC(field_id)%update_interpolation(nodal_quad_in_root_fe(field_id))

          end if

        end if

        ! Get root_fe shape functions at the nodes of the cut cell
        call cell_integrator(field_id)%update(root_cell_map)
        if (root_reference_fe%get_field_type() == field_type_scalar) then
          call cell_integrator(field_id)%get_values(shape_values_scalar)
        else if (root_reference_fe%get_field_type() == field_type_vector) then
          call cell_integrator(field_id)%get_values(shape_values_vector)
        else
          check(.false.)
        end if

        if (this%use_serendipity_extension .and. field_id == 1) then

          ! Get the root_fe shape functions at the serendipity points
          call cell_integrator_NR_XS(field_id)%update(root_cell_map)
          if (root_reference_fe%get_field_type() == field_type_scalar) then
            call cell_integrator_NR_XS(field_id)%get_values(shape_values_scalar_NR_XS)
          else if (root_reference_fe%get_field_type() == field_type_vector) then
            call cell_integrator_NR_XS(field_id)%get_values(shape_values_vector_NR_XS)
          else
            check(.false.)
          end if

          ! Get the serendipity shape functions at the nodes of the cut cell
          call cell_integrator_NS_XC(field_id)%update(root_cell_map)
          call cell_integrator_NS_XC(field_id)%get_values(shape_values_scalar_NS_XC)

        end if


        do idof = 1, size(fe_dofs)
          if ( fe%is_fixed_dof(fe_dofs(idof)) .and. (min_fixed_dof_gid<=abs(fe_dofs(idof))) .and. (abs(fe_dofs(idof))<=max_fixed_dof_gid) ) then
            improper_dof_lid = abs(fe_dofs(idof))
            hanging_dof_lid  = improper_dof_lid - ( this%num_hanging_dofs_full_cells + this%get_num_dirichlet_dofs() )
            if ( .not. visited_hanging_dof_lids(hanging_dof_lid) ) then
              current_pos_free = ptr_constraining_free_dofs%get(hanging_dof_lid)
              current_pos_diri = ptr_constraining_dirichlet_dofs%get(hanging_dof_lid)
              do root_idof = 1,size(root_fe_dofs)
                if ( root_reference_fe%get_component_node(root_idof) == reference_fe%get_component_node(idof) ) then

                  if (root_reference_fe%get_field_type() == field_type_scalar) then
                    if (this%use_serendipity_extension .and. field_id == 1) then
                      coefficient = 0
                      do inode_serendipity = 1, nodal_quad_serendipity%get_num_quadrature_points()
                        coefficient = coefficient + &
                        shape_values_scalar_NR_XS(root_idof,inode_serendipity)*shape_values_scalar_NS_XC(inode_serendipity,idof)
                      end do
                    else
                      coefficient = shape_values_scalar(root_idof,idof)
                    end if
                  else if (root_reference_fe%get_field_type() == field_type_vector) then
                    if (this%use_serendipity_extension .and. field_id == 1) then
                      coefficient = 0
                      do inode_serendipity = 1, nodal_quad_serendipity%get_num_quadrature_points()
                        coefficient = coefficient + &
                        shape_values_vector_NR_XS(root_idof,inode_serendipity)%get(root_reference_fe%get_component_node(root_idof))&
                        * shape_values_scalar_NS_XC(inode_serendipity,reference_fe%get_scalar_from_vector_node(idof))
                      end do
                    else
                      coefficient = shape_values_vector(root_idof,reference_fe%get_scalar_from_vector_node(idof))%get(reference_fe%get_component_node(idof))
                    end if
                  else
                    check(.false.)
                  end if

                  if ( root_fe%is_free_dof(root_fe_dofs(root_idof)) ) then
                    call constraining_free_dofs%set(current_pos_free,root_fe_dofs(root_idof))
                    call constraining_free_dofs_coefficients%set(current_pos_free,coefficient)
                    current_pos_free = current_pos_free + 1
                  else if ( root_fe%is_strong_dirichlet_dof(root_fe_dofs(root_idof)) ) then
                    call constraining_dirichlet_dofs%set(current_pos_diri,root_fe_dofs(root_idof))
                    call constraining_dirichlet_dofs_coefficients%set(current_pos_diri,coefficient)
                    current_pos_diri = current_pos_diri + 1
                  else if ( root_fe%is_hanging_dof(root_fe_dofs(root_idof)) ) then
                    root_hanging_dof_lid = abs(root_fe_dofs(root_idof)) - this%get_num_dirichlet_dofs()
                    massert( (1<=root_hanging_dof_lid) .and.  (root_hanging_dof_lid<=this%num_hanging_dofs_full_cells), 'Hanging nodes of full cells are prescribed as always' )
                    num_free_master_dofs = this_ptr_constraining_free_dofs%get(root_hanging_dof_lid+1)&
                                         - this_ptr_constraining_free_dofs%get(root_hanging_dof_lid)
                    num_dirichlet_master_dofs = this_ptr_constraining_dirichlet_dofs%get(root_hanging_dof_lid+1)&
                                              - this_ptr_constraining_dirichlet_dofs%get(root_hanging_dof_lid)
                    do ifree = 1,num_free_master_dofs
                      call constraining_free_dofs%set(current_pos_free,&
                        this_constraining_free_dofs%get(this_ptr_constraining_free_dofs%get(root_hanging_dof_lid)+ifree-1))
                      call constraining_free_dofs_coefficients%set(current_pos_free,&
                        coefficient*this_constraining_free_dofs_coefficients%get(this_ptr_constraining_free_dofs%get(root_hanging_dof_lid)+ifree-1))
                      current_pos_free = current_pos_free + 1
                    end do
                    do idirichlet = 1,num_dirichlet_master_dofs
                      call constraining_dirichlet_dofs%set(current_pos_diri,&
                        this_constraining_dirichlet_dofs%get(this_ptr_constraining_dirichlet_dofs%get(root_hanging_dof_lid)+idirichlet-1))
                      call constraining_dirichlet_dofs_coefficients%set(current_pos_diri,&
                        coefficient*this_constraining_dirichlet_dofs_coefficients%get(this_ptr_constraining_dirichlet_dofs%get(root_hanging_dof_lid)+idirichlet-1))
                      current_pos_diri = current_pos_diri + 1
                    end do
                  else
                    mcheck(.false.,'Dof is either free dirichlet or hanging')
                  end if
                end if
              end do
              visited_hanging_dof_lids(hanging_dof_lid) = .true.
            end if
          end if
        end do

      end do
      iaux = iaux + 1
    end if
    call fe%next()
  end do

  call this_ptr_constraining_free_dofs                 %cat_ptr( ptr_constraining_free_dofs                 )
  call this_ptr_constraining_dirichlet_dofs            %cat_ptr( ptr_constraining_dirichlet_dofs            )
  call this_constraining_free_dofs                     %cat( constraining_free_dofs                     )
  call this_constraining_free_dofs_coefficients        %cat( constraining_free_dofs_coefficients        )
  call this_constraining_dirichlet_dofs                %cat( constraining_dirichlet_dofs                )
  call this_constraining_dirichlet_dofs_coefficients   %cat( constraining_dirichlet_dofs_coefficients   )
  call this_constraints_independent_term               %cat( constraints_independent_term               )

  call ptr_constraining_free_dofs%free()
  call ptr_constraining_dirichlet_dofs%free()
  call constraining_free_dofs%free()
  call constraining_free_dofs_coefficients%free()
  call constraining_dirichlet_dofs%free()
  call constraining_dirichlet_dofs_coefficients%free()
  call constraints_independent_term%free()

  call this%free_fe_cell_iterator(fe)
  call this%free_fe_cell_iterator(root_fe)
  do field_id = 1, this%get_num_fields()
    call nodal_quad_in_root_fe(field_id)%free()
  end do
  deallocate(nodal_quad_in_root_fe,stat=istat); check(istat==0)
  do field_id = 1, this%get_num_fields()
    call cell_map(field_id)%free()
  end do
  deallocate(cell_map,stat=istat); check(istat==0)
  do field_id = 1, this%get_num_fields()
    call cell_integrator(field_id)%free()
  end do
  deallocate(cell_integrator,stat=istat); check(istat==0)

  if (allocated(cell_integrator_NS_XC)) then
    do field_id = 1, this%get_num_fields()
      call cell_integrator_NS_XC(field_id)%free()
    end do
    deallocate(cell_integrator_NS_XC,stat=istat); check(istat==0)
  end if

  if (allocated(cell_integrator_NR_XS)) then
    do field_id = 1, this%get_num_fields()
      call cell_integrator_NR_XS(field_id)%free()
    end do
    deallocate(cell_integrator_NR_XS,stat=istat); check(istat==0)
  end if

  if (allocated(shape_values_scalar)) then
    call memfree(shape_values_scalar,__FILE__,__LINE__)
  end if
  if (allocated(shape_values_scalar_NS_XC)) then
    call memfree(shape_values_scalar_NS_XC,__FILE__,__LINE__)
  end if
  if (allocated(shape_values_scalar_NR_XS)) then
    call memfree(shape_values_scalar_NR_XS,__FILE__,__LINE__)
  end if
  if (allocated(shape_values_vector)) then
    deallocate(shape_values_vector,stat=istat); check(istat==0)
  end if
  if (allocated(shape_values_vector_NR_XS)) then
    deallocate(shape_values_vector_NR_XS,stat=istat); check(istat==0)
  end if
  call memfree(visited_hanging_dof_lids,__FILE__,__LINE__)
  call memfree(first_ref_fe_visited_x_field,__FILE__,__LINE__)

  if (allocated(serendipity_ref_fes)) then
    do field_id = 1, this%get_num_fields()
      call serendipity_ref_fes(field_id)%free()
    end do
    deallocate(serendipity_ref_fes,stat=istat); check(istat==0)
  end if

  contains

    subroutine send_to_reference_space(phys_coords_as_point,fe_quad,cell_map,ref_coords_as_quadrature)
      implicit none
      type(point_t),      intent(in)    :: phys_coords_as_point(:)
      type(quadrature_t), intent(in)    :: fe_quad
      type(cell_map_t),     intent(in)    :: cell_map
      type(quadrature_t), intent(inout) :: ref_coords_as_quadrature
    
      real(rp), pointer :: det_jacobians(:)
      integer(ip) :: qpoint
      type(vector_field_t) :: b
      type(vector_field_t) :: eta
      type(vector_field_t) :: Aeta
      type(vector_field_t) :: x
      integer(ip)   :: idime
      real(rp), pointer :: ref_quad_coords(:,:)
      type(point_t), pointer :: phys_quad_coords(:)
    
      assert(size(phys_coords_as_point)==ref_coords_as_quadrature%get_num_quadrature_points())
      assert(fe_quad%get_num_dims() == ref_coords_as_quadrature%get_num_dims())
    
      ! Check that we have an affine fe map
#ifdef DEBUG
      det_jacobians => cell_map%get_det_jacobians()
      do qpoint = 1, size(det_jacobians)
        massert( abs(det_jacobians(1) - det_jacobians(qpoint)) < 1.0e-13, 'We assume that the FE map is afine')
      end do
#endif
    
      ! Compute the rhs of the affine cell_map
      qpoint = 1
      ref_quad_coords  => fe_quad%get_coordinates()
      phys_quad_coords => cell_map%get_quadrature_points_coordinates()
      call eta%init(0.0)
      call x%init(0.0)
      do idime = 1, fe_quad%get_num_dims()
        call eta%set(idime,ref_quad_coords(idime,qpoint))
        call x%set(idime,phys_quad_coords(qpoint)%get(idime))
      end do
      Aeta = cell_map%apply_jacobian(qpoint,eta)
      b = x - Aeta
    
      ! Compute the inverse affine fe map
      ref_quad_coords  => ref_coords_as_quadrature%get_coordinates()
      do qpoint = 1,size(phys_coords_as_point) 
        call x%init(0.0)
        do idime = 1, fe_quad%get_num_dims()
          call x%set(idime,phys_coords_as_point(qpoint)%get(idime))
        end do
        x = x - b
        eta = cell_map%apply_inv_jacobian(1,x)
        do idime = 1, fe_quad%get_num_dims()
          ref_quad_coords(idime,qpoint) = eta%get(idime)
        end do
      end do
    
    end subroutine send_to_reference_space
end subroutine suhpafs_setup_only_cell_aggregation_constraints

!========================================================================================
subroutine suhpafs_refine_mesh_for_small_aggregates(this,triangulation,target_size,level_set_function)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout) :: this
  class(unfitted_p4est_serial_triangulation_t) , intent(inout) :: triangulation
  real(rp)                                     , intent(in)    :: target_size
  class(level_set_function_t)                  , intent(in)    :: level_set_function

  integer(ip), parameter :: max_num_sweeps = 20
  integer(ip) :: isweep
  class(cell_iterator_t), allocatable :: cell
  logical :: do_something
  integer(ip) :: num_do_nothing

  call this%free()
  call this%debug_info%init()
  call this%allocate_and_fill_aggregate_ids(triangulation)
  call this%compute_aggregate_sizes(triangulation)

  num_do_nothing = 0
  do isweep = 1, max_num_sweeps

    call triangulation%create_cell_iterator(cell)
    do_something = .false.

    do while (.not. cell%has_finished())
      if (this%is_in_aggregate_x_cell(cell%get_gid())) then
        if ( this%aggregate_size(cell%get_gid()) > target_size  ) then
          call cell%set_for_refinement()
          do_something = .true.
        else
          call cell%set_for_do_nothing()
        end if
      else
        if (cell%is_interior() .and. this%aggregate_size(cell%get_gid()) < 0.999*target_size) then
          call cell%set_for_coarsening()
        else
          call cell%set_for_do_nothing()
        end if
      end if
      call cell%next()
    end do
    call triangulation%free_cell_iterator(cell)

    if (.not. do_something) then
      num_do_nothing = num_do_nothing + 1
    end if

    if (num_do_nothing == 2) then
      exit
    end if

    call triangulation%refine_and_coarsen()
    call triangulation%clear_refinement_and_coarsening_flags()
    call triangulation%update_cut_cells(level_set_function)

    call this%free()
    call this%debug_info%init()
    call this%allocate_and_fill_aggregate_ids(triangulation)
    call this%compute_aggregate_sizes(triangulation)

  end do
  check(isweep < max_num_sweeps)

end subroutine suhpafs_refine_mesh_for_small_aggregates


!========================================================================================
function suhpafs_get_aggregate_ids(this)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), target, intent(in)    :: this
  integer(ip), pointer :: suhpafs_get_aggregate_ids(:)
  assert(allocated(this%aggregate_ids))
  suhpafs_get_aggregate_ids => this%aggregate_ids
end function suhpafs_get_aggregate_ids

!========================================================================================
function suhpafs_get_aggregate_size(this)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), target, intent(in)    :: this
  real(rp), pointer :: suhpafs_get_aggregate_size(:)
  assert(allocated(this%aggregate_size))
  suhpafs_get_aggregate_size => this%aggregate_size
end function suhpafs_get_aggregate_size

!========================================================================================
function suhpafs_get_is_in_aggregate_x_cell(this)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), target, intent(in)    :: this
  logical, pointer :: suhpafs_get_is_in_aggregate_x_cell(:)
  assert(allocated(this%is_in_aggregate_x_cell))
  suhpafs_get_is_in_aggregate_x_cell => this%is_in_aggregate_x_cell
end function suhpafs_get_is_in_aggregate_x_cell

!========================================================================================
subroutine suhpafs_print_debug_info(this,iounit)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), target, intent(inout)    :: this
  integer(ip) :: iounit
  integer(ip) :: istat
  real(rp)    :: max_aggregate_size
  integer(ip) :: max_aggregate_size_id
  logical     :: has_full_neig_along_dim(3)
  integer(ip) :: max_separation_from_root_id
  real(ip)    :: max_separation_from_root
  integer(ip) :: has_full_neig_along_dim_int(3)
  integer(ip) :: i

  if (.not. this%use_constraints) then
    max_separation_from_root_id = -1
    max_separation_from_root    = -1.0_rp
    max_aggregate_size    = -1.0_rp
    max_aggregate_size_id = -1
    istat = this%debug_info%set(key='max_separation_from_root_id',value=max_separation_from_root_id); check(istat==0)
    istat = this%debug_info%set(key='max_separation_from_root',   value=max_separation_from_root   ); check(istat==0)
    istat = this%debug_info%set(key='max_aggregate_size',   value=max_aggregate_size   ); check(istat==0)
    istat = this%debug_info%set(key='max_aggregate_size_id',value=max_aggregate_size_id); check(istat==0)
  end if

  istat = this%debug_info%get(key='max_separation_from_root_id',  value=max_separation_from_root_id ); check(istat==0)
  istat = this%debug_info%get(key='max_separation_from_root',     value=max_separation_from_root    ); check(istat==0)
  istat = this%debug_info%get(key='max_aggregate_size',           value=max_aggregate_size          ); check(istat==0)
  istat = this%debug_info%get(key='max_aggregate_size_id',        value=max_aggregate_size_id       ); check(istat==0)
  istat = this%debug_info%get(key='has_full_neig_c',              value=has_full_neig_along_dim(1)  ); check(istat==0)
  istat = this%debug_info%get(key='has_full_neig_e',              value=has_full_neig_along_dim(2)  ); check(istat==0)
  istat = this%debug_info%get(key='has_full_neig_f',              value=has_full_neig_along_dim(3)  ); check(istat==0)

  has_full_neig_along_dim_int(:) = 0
  do i = 1,3
    if (has_full_neig_along_dim(i)) then
      has_full_neig_along_dim_int(i) = 1
    end if
  end do

  write(iounit,'(a,e32.25)') 'max_separation_from_root    ;',  max_separation_from_root      
  write(iounit,'(a,i32)'   ) 'max_separation_from_root_id ;',  max_separation_from_root_id
  write(iounit,'(a,e32.25)') 'max_aggregate_size          ;',  max_aggregate_size                  
  write(iounit,'(a,i32)'   ) 'max_aggregate_size_id       ;',  max_aggregate_size_id            
  write(iounit,'(a,i32)'   ) 'has_full_neig_c             ;',  has_full_neig_along_dim_int(1)             
  write(iounit,'(a,i32)'   ) 'has_full_neig_e             ;',  has_full_neig_along_dim_int(2)             
  write(iounit,'(a,i32)'   ) 'has_full_neig_f             ;',  has_full_neig_along_dim_int(3)             
  write(iounit,'(a,i32)'   ) 'num_free_dofs               ;',  this%get_total_num_dofs()             
  write(iounit,'(a,i32)'   ) 'num_fixed_dofs              ;',  this%get_num_fixed_dofs()             
  write(iounit,'(a,i32)'   ) 'num_hanging_dofs            ;',  this%get_num_hanging_dofs()             
end subroutine suhpafs_print_debug_info

!========================================================================================
subroutine suhpafs_allocate_and_fill_aggregate_ids(this,triangulation)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout) :: this
  class(triangulation_t)                       , intent(in)    :: triangulation

  class(cell_iterator_t), allocatable :: cell
  integer(ip) :: icell
  class(cell_iterator_t), allocatable :: cell_arround
  integer(ip), parameter :: max_num_sweeps = 5
  integer(ip) :: isweep
  logical ::  is_needed 
  logical :: has_been_aggregated
  integer(ip) :: icell_arround
  class(vef_iterator_t), allocatable :: vef
  integer(ip) :: ivef
  integer(ip) :: ifacet
  integer(ip), allocatable :: tent_distance(:)
  integer(ip), allocatable :: min_distance(:)
  integer(ip) :: min_distance_aggr_id
  logical(ip),allocatable :: touched(:)

  integer(ip), allocatable :: distance(:,:)
  integer(ip), target :: face2dir_2d(4,2) = reshape([0,0,1,-1,1,-1,0,0],[4,2])
  integer(ip), target :: face2dir_3d(6,3) = reshape([ 0, 0, 0, 0, 1,-1,&
                                                      0, 0, 1,-1, 0, 0,&
                                                      1,-1, 0, 0, 0, 0],[6,3])
  integer(ip), pointer :: face2dir(:,:)

  integer(ip) :: max_separation_from_root_id
  real(ip)    :: max_separation_from_root
  integer(ip) :: istat

  call memalloc(triangulation%get_num_local_cells(),this%aggregate_ids,__FILE__,__LINE__)

  if (triangulation%get_num_dims() == 2) then
    face2dir => face2dir_2d
  else if (triangulation%get_num_dims() == 3) then
    face2dir => face2dir_3d
  else
    mcheck(.false.,'Only for 3D and 2D')
  end if

  max_separation_from_root = 0.0_rp

  call memalloc(triangulation%get_num_local_cells(),triangulation%get_num_dims(),distance,__FILE__,__LINE__)
  call memalloc(triangulation%get_num_local_cells(),touched,__FILE__,__LINE__)
  call memalloc(triangulation%get_num_dims(),tent_distance,__FILE__,__LINE__)
  call memalloc(triangulation%get_num_dims(),min_distance,__FILE__,__LINE__)

  call triangulation%create_cell_iterator(cell)
  call triangulation%create_cell_iterator(cell_arround)
  call triangulation%create_vef_iterator(vef)

  ! Initialize by setting the roots of the aggregates
  touched(:) = .false.
  do while (.not. cell%has_finished())
    if (cell%is_local()) then
      if (cell%is_interior()) then
        this%aggregate_ids(cell%get_gid()) = cell%get_gid()
        distance(cell%get_gid(),:) = 0
        touched(cell%get_gid()) = .true.
      else
        this%aggregate_ids(cell%get_gid()) = 0
      end if
    end if
    call cell%next()
  end do

  is_needed = .true.
  isweep = 1
  do while (is_needed)

    ! Check that we not reach the max num of sweeps allowed
    wassert(isweep <= max_num_sweeps, 'Max number of sweeps reached in the cut cell agglometarion algorithm. Refine your mesh!')
    if (isweep > max_num_sweeps) exit

    ! Glue to the neighbors
    call cell%first()
    is_needed = .false.
    do while (.not. cell%has_finished())
      if (cell%is_local()) then
        if ( cell%is_cut() .and. (.not. touched(cell%get_gid())) )  then

          ! Glue to the face-neighbor with the smallest distance to a full element
          min_distance(:) = 99999999
          min_distance_aggr_id = 0
          ifacet = 0
          do ivef = 1, cell%get_num_vefs()
            call cell%get_vef(ivef,vef)
            if ( .not. vef%is_facet() ) cycle
            if ( vef%is_exterior() ) cycle
            ifacet = ifacet + 1

            ! Find among true neighbors
            do icell_arround = 1,vef%get_num_cells_around()
              call vef%get_cell_around(icell_arround,cell_arround)
              if ( touched(cell_arround%get_gid()) ) then

                ! Compute the movement to reach the root element
                tent_distance = distance(cell_arround%get_gid(),:) + face2dir(ifacet,:)

                ! Find which is the best neighbor to glue into
                if ( norm2(real(tent_distance,kind=rp)) < norm2(real(min_distance,kind=rp)) ) then
                  min_distance =  tent_distance
                  min_distance_aggr_id = this%aggregate_ids(cell_arround%get_gid())
                end if

              end if
            end do

            ! Find among half neighbors
            do icell_arround = 1,vef%get_num_half_cells_around()
              call vef%get_half_cell_around(icell_arround,cell_arround)
              if ( touched(cell_arround%get_gid()) ) then

                ! Compute the movement to reach the root element
                tent_distance = distance(cell_arround%get_gid(),:) + face2dir(ifacet,:)

                ! Find which is the best neighbor to glue into
                if ( norm2(real(tent_distance,kind=rp)) < norm2(real(min_distance,kind=rp)) ) then
                  min_distance =  tent_distance
                  min_distance_aggr_id = this%aggregate_ids(cell_arround%get_gid())
                end if

              end if
            end do

            ! Find among improper neighbors
            do icell_arround = 1,vef%get_num_improper_cells_around()
              call vef%get_improper_cell_around(icell_arround,cell_arround)
              if ( touched(cell_arround%get_gid()) ) then

                ! Compute the movement to reach the root element
                tent_distance = distance(cell_arround%get_gid(),:) + face2dir(ifacet,:)

                ! Find which is the best neighbor to glue into
                if ( norm2(real(tent_distance,kind=rp)) < norm2(real(min_distance,kind=rp)) ) then
                  min_distance =  tent_distance
                  min_distance_aggr_id = this%aggregate_ids(cell_arround%get_gid())
                end if

              end if
            end do

          end do

          if (min_distance_aggr_id == 0) then
            is_needed = .true.
          else
            this%aggregate_ids(cell%get_gid()) = min_distance_aggr_id
            distance(cell%get_gid(),:) = min_distance
            if (max_separation_from_root < norm2(real(min_distance,kind=rp))) then
              max_separation_from_root = norm2(real(min_distance,kind=rp))
              max_separation_from_root_id = min_distance_aggr_id
            end if
          end if

        end if
      end if
      call cell%next()
    end do

    ! Mark as touched all the aggregated cells
    touched(:) = this%aggregate_ids(:) > 0

    isweep = isweep + 1
  end do

  call triangulation%free_cell_iterator(cell)
  call triangulation%free_cell_iterator(cell_arround)
  call triangulation%free_vef_iterator(vef)

  ! Store info
  istat = this%debug_info%set(key='max_separation_from_root_id',value=max_separation_from_root_id); check(istat==0)
  istat = this%debug_info%set(key='max_separation_from_root',value=max_separation_from_root); check(istat==0)

  call memfree(tent_distance,__FILE__,__LINE__)
  call memfree(min_distance,__FILE__,__LINE__)
  call memfree(distance,__FILE__,__LINE__)
  call memfree(touched,__FILE__,__LINE__)

end subroutine suhpafs_allocate_and_fill_aggregate_ids

!========================================================================================
subroutine suhpafs_check_for_full_neighbors(this)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout)    :: this

  logical :: has_full_neig_along_dim(3)
  logical :: cell_has_full_neig_along_dim(3)
  class(cell_iterator_t), allocatable :: cell
  class(cell_iterator_t), allocatable :: cell_arround
  class(vef_iterator_t), allocatable :: vef
  integer(ip) :: ivef
  integer(ip) :: icell_arround
  integer(ip) :: i
  class(triangulation_t), pointer :: triangulation
  integer(ip) :: istat

 triangulation => this%get_triangulation()

  call triangulation%create_cell_iterator(cell)
  call triangulation%create_cell_iterator(cell_arround)
  call triangulation%create_vef_iterator(vef)

  has_full_neig_along_dim(:) = .true.
  if (triangulation%get_num_dims() == 2) then
    has_full_neig_along_dim(3) = .false.
  end if
  do while (.not. cell%has_finished())
    if (cell%is_local() .and. cell%is_cut()) then
        cell_has_full_neig_along_dim(:) = .false.
        do ivef = 1, cell%get_num_vefs()
          call cell%get_vef(ivef,vef)
          do icell_arround = 1,vef%get_num_cells_around()
            call vef%get_cell_around(icell_arround,cell_arround)
            if (cell_arround%is_interior()) then
              cell_has_full_neig_along_dim(vef%get_dim()+1) = .true.
            end if
          end do
        end do
        do i=1,triangulation%get_num_dims()
         if (.not. cell_has_full_neig_along_dim(i)) has_full_neig_along_dim(i) = .false.
        end do
    end if
    call cell%next()
  end do

  call triangulation%free_cell_iterator(cell)
  call triangulation%free_cell_iterator(cell_arround)
  call triangulation%free_vef_iterator(vef)

  istat = this%debug_info%set(key='has_full_neig_c',value=has_full_neig_along_dim(1)); check(istat==0)
  istat = this%debug_info%set(key='has_full_neig_e',value=has_full_neig_along_dim(2)); check(istat==0)
  istat = this%debug_info%set(key='has_full_neig_f',value=has_full_neig_along_dim(3)); check(istat==0)

end subroutine suhpafs_check_for_full_neighbors


!========================================================================================
subroutine suhpafs_fill_proper_vef_constrains_full_cell(this,proper_vef_constrains_full_cell)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(in) :: this   
  logical, intent(inout) :: proper_vef_constrains_full_cell(:,:)

  integer(ip) :: field_id, ivef
  class(fe_cell_iterator_t), allocatable :: fe, coarser_fe
  type(fe_vef_iterator_t) :: vef

  integer(ip) :: num_fields
  integer(ip), pointer :: fe_space_type_x_field(:)
  class(triangulation_t), pointer :: triangulation

  logical, allocatable :: touched_cell_dofs(:)
  integer(ip) :: icell
  class(reference_fe_t), pointer :: coarser_reference_fe
  type(list_iterator_t) :: coarser_fe_dofs_on_vef_iterator
  integer(ip) :: coarser_fe_ivef
  type(fe_vef_iterator_t) :: coarser_vef

  ! This is needed since we cannot access to private variables of the father
  triangulation => this%get_triangulation()
  num_fields = this%get_num_fields()
  fe_space_type_x_field => this%get_fe_space_type()

  ! Create iterators
  call this%create_fe_cell_iterator(fe)
  call this%create_fe_vef_iterator(vef)
  call this%create_fe_vef_iterator(coarser_vef)
  call this%create_fe_cell_iterator(coarser_fe)

  assert( num_fields == size(proper_vef_constrains_full_cell,1) )
  assert( triangulation%get_num_proper_vefs() == size(proper_vef_constrains_full_cell,2) )

  ! Mark the vefs owning DOFs that constraint hanging DOFs in full cells
  ! TODO: This is only needed for adaptive runs
  ! TODO: We only need to do the loop for full cells that are root
  call memalloc ( this%get_max_num_shape_functions(), touched_cell_dofs,__FILE__,__LINE__ )
  proper_vef_constrains_full_cell(:,:) = .false.
  call fe%first()
  do while ( .not. fe%has_finished())
    if ( fe%is_local() .and. (.not. fe%is_cut()) ) then
      do field_id=1, num_fields
        if ( fe_space_type_x_field(field_id) == fe_space_type_cg ) then
          if ( .not. fe%is_void(field_id)) then
            do ivef = 1, fe%get_num_vefs()
              call fe%get_vef(ivef,vef)
              if ( vef%has_free_dofs(field_id,coarser_fe) ) cycle
              if ( .not. vef%is_proper() ) then
                do icell = 1,vef%get_num_improper_cells_around()
                  call vef%get_improper_cell_around(icell,coarser_fe)
                  coarser_fe_ivef = vef%get_improper_cell_around_ivef(icell)
                  coarser_reference_fe => coarser_fe%get_reference_fe(field_id)
                  if (coarser_fe%is_cut()) then
                    touched_cell_dofs(:) = .false.
                    coarser_fe_dofs_on_vef_iterator = coarser_reference_fe%create_dofs_on_n_face_iterator(coarser_fe_ivef)
                    do while ( .not. coarser_fe_dofs_on_vef_iterator%is_upper_bound() )
                      touched_cell_dofs(coarser_fe_dofs_on_vef_iterator%get_current()) = .true.
                      call coarser_fe_dofs_on_vef_iterator%next()
                    end do
                    do coarser_fe_ivef = 1, coarser_fe%get_num_vefs()
                      call coarser_fe%get_vef(coarser_fe_ivef,coarser_vef)
                      coarser_fe_dofs_on_vef_iterator = coarser_reference_fe%create_own_dofs_on_n_face_iterator(coarser_fe_ivef)
                      do while ( .not. coarser_fe_dofs_on_vef_iterator%is_upper_bound() )
                        if ( touched_cell_dofs(coarser_fe_dofs_on_vef_iterator%get_current()) ) then
                          massert(coarser_vef%is_proper(),'This vef has to be proper by the 2:1 balance condition.')
                          proper_vef_constrains_full_cell(field_id,coarser_vef%get_gid()) = .true.
                          exit
                        end if
                        call coarser_fe_dofs_on_vef_iterator%next()
                      end do
                    end do
                  end if
                end do
              end if
            end do
          end if
        end if
      end do
    end if
    call fe%next()
  end do

  call this%free_fe_cell_iterator(coarser_fe)
  call this%free_fe_vef_iterator(vef)
  call this%free_fe_vef_iterator(coarser_vef)
  call this%free_fe_cell_iterator(fe)
  call memfree ( touched_cell_dofs,__FILE__,__LINE__ )
end subroutine suhpafs_fill_proper_vef_constrains_full_cell

!========================================================================================
subroutine suhpafs_compute_aggregate_sizes(this,triangulation)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout) :: this
  class(triangulation_t)                       , intent(in)    :: triangulation

  class(cell_iterator_t), allocatable :: cell
  real(rp), allocatable :: coords_min(:,:)
  real(rp), allocatable :: coords_max(:,:)
  type(point_t), allocatable :: cell_coords(:)
  integer(ip) :: istat
  integer(ip) :: inode
  integer(ip) :: idime
  integer(ip) :: aggr_id
  integer(ip), parameter :: SPACE_DIMS = 3

  real(rp) :: max_aggregate_size
  integer(ip) :: max_aggregate_size_id

  assert(allocated(this%aggregate_ids))

  massert(triangulation%get_num_ghost_cells()==0,'subroutine only for serial runs for the moment')
  massert(triangulation%get_num_reference_fes()==1,'Be carefull in the allocation of cell_coords')

  call memalloc(size(this%aggregate_ids),this%aggregate_size,__FILE__,__LINE__)
  call memalloc(size(this%aggregate_ids),this%is_in_aggregate_x_cell,__FILE__,__LINE__)
  this%is_in_aggregate_x_cell(:) = .false.

  call memalloc(SPACE_DIMS,size(this%aggregate_ids),coords_min,__FILE__,__LINE__)
  call memalloc(SPACE_DIMS,size(this%aggregate_ids),coords_max,__FILE__,__LINE__)
  coords_min(:,:) =  1.0e10
  coords_max(:,:) = -1.0e10

  call triangulation%create_cell_iterator(cell)
  allocate ( cell_coords(cell%get_num_nodes()), stat = istat ); check(istat == 0)

  do while(.not. cell%has_finished())
    if (.not. cell%is_exterior()) then

      call cell%get_nodes_coordinates( cell_coords )
      aggr_id = this%aggregate_ids(cell%get_gid())

      if (cell%is_cut()) then
        this%is_in_aggregate_x_cell(cell%get_gid()) = .true.
        this%is_in_aggregate_x_cell(aggr_id) = .true.
      end if

      do inode = 1, cell%get_num_nodes()
        do idime = 1, SPACE_DIMS
          coords_min(idime,aggr_id) = min(coords_min(idime,aggr_id),cell_coords(inode)%get(idime))
          coords_max(idime,aggr_id) = max(coords_min(idime,aggr_id),cell_coords(inode)%get(idime))
        end do
      end do

    end if
    call cell%next()
  end do

  this%aggregate_size(:) = maxval(coords_max(:,:)-coords_min(:,:),1)
  call cell%first()
  do while(.not. cell%has_finished())
    if (.not. cell%is_exterior()) then
      aggr_id = this%aggregate_ids(cell%get_gid())
      this%aggregate_size(cell%get_gid()) =  this%aggregate_size(aggr_id)
    else
      this%aggregate_size(cell%get_gid()) =  0.0
    end if
    call cell%next()
  end do

  deallocate ( cell_coords, stat = istat ); check(istat == 0)
  call triangulation%free_cell_iterator(cell)

  call memfree(coords_min,__FILE__,__LINE__)
  call memfree(coords_max,__FILE__,__LINE__)

  max_aggregate_size = 0.0
  do aggr_id = 1, size(this%aggregate_size)
    if (max_aggregate_size < this%aggregate_size(aggr_id)) then
      max_aggregate_size = this%aggregate_size(aggr_id)
      max_aggregate_size_id = aggr_id
    end if
  end do

  istat = this%debug_info%set(key='max_aggregate_size'   ,value=max_aggregate_size   ); check(istat==0)
  istat = this%debug_info%set(key='max_aggregate_size_id',value=max_aggregate_size_id); check(istat==0)

end subroutine suhpafs_compute_aggregate_sizes
