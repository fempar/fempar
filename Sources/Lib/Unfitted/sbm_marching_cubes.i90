 ! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!========================================================================================
subroutine mc_dummy_coarse_fe_handler_get_num_coarse_dofs(this, field_id, par_fe_space, parameter_list, num_coarse_dofs)
  implicit none
  class(mc_dummy_coarse_fe_handler_t), intent(in)    :: this
  integer(ip)                        , intent(in)    :: field_id
  type(par_fe_space_t)               , intent(in)    :: par_fe_space
  type(parameterlist_t)              , intent(in)    :: parameter_list
  integer(ip)                        , intent(inout) :: num_coarse_dofs(:)
  mcheck(.false.,'This function should never have been called!')
end subroutine mc_dummy_coarse_fe_handler_get_num_coarse_dofs

!========================================================================================
subroutine mc_dummy_coarse_fe_handler_setup_constraint_matrix(this, field_id, par_fe_space, parameter_list, constraint_matrix) 
  implicit none
  class(mc_dummy_coarse_fe_handler_t), intent(in)    :: this
  integer(ip)                        , intent(in)    :: field_id
  type(par_fe_space_t)               , intent(in)    :: par_fe_space
  type(parameterlist_t)              , intent(in)    :: parameter_list
  type(coo_sparse_matrix_t)          , intent(inout) :: constraint_matrix
  mcheck(.false.,'This function should never have been called!')
end subroutine mc_dummy_coarse_fe_handler_setup_constraint_matrix

!========================================================================================
subroutine mc_dummy_coarse_fe_handler_setup_weighting_operator(this, field_id, par_fe_space, parameter_list, weighting_operator) 
  implicit none
  class(mc_dummy_coarse_fe_handler_t), intent(in)    :: this
  integer(ip)                        , intent(in)    :: field_id
  type(par_fe_space_t)               , intent(in)    :: par_fe_space
  type(parameterlist_t)              , intent(in)    :: parameter_list
  real(rp), allocatable              , intent(inout) :: weighting_operator(:)
  mcheck(.false.,'This function should never have been called!')
end subroutine mc_dummy_coarse_fe_handler_setup_weighting_operator

!========================================================================================
function mc_dummy_conditions_get_num_components(this)
  implicit none
  class(mc_dummy_conditions_t), intent(in) :: this
  integer(ip) :: mc_dummy_conditions_get_num_components
  mc_dummy_conditions_get_num_components = 1
end function mc_dummy_conditions_get_num_components

!========================================================================================
subroutine mc_dummy_conditions_get_components_code(this, boundary_id, components_code)
  implicit none
  class(mc_dummy_conditions_t), intent(in)  :: this
  integer(ip)                 , intent(in)  :: boundary_id
  logical                     , intent(out) :: components_code(:)
  assert ( size(components_code) == 1 )
  components_code(1) = .false.
end subroutine mc_dummy_conditions_get_components_code

!========================================================================================
subroutine mc_dummy_conditions_get_function ( this, boundary_id, component_id, function )
  implicit none
  class(mc_dummy_conditions_t), target,  intent(in)  :: this
  integer(ip),                           intent(in)  :: boundary_id
  integer(ip),                           intent(in)  :: component_id
  class(scalar_function_t),     pointer, intent(out) :: function
  mcheck(.false.,'This procedure should have never been called!')
end subroutine mc_dummy_conditions_get_function

!========================================================================================
subroutine marching_cubes_create(this, triangulation, level_set_function)
  implicit none
  class(marching_cubes_t),            target,  intent(inout)  :: this
  class(triangulation_t)            , target,  intent(in)     :: triangulation
  class(level_set_function_t),        target,  intent(in)     :: level_set_function
  type(environment_t), pointer           :: environment
  call this%free()
  this%num_dims = triangulation%get_num_dims()
  environment => triangulation%get_environment()
  call this%set_triangulation(triangulation)
  if ( environment%am_i_l1_task() ) then
    assert(this%fulfills_assumptions())
    this%level_set_function => level_set_function
    call this%mc_tables_create()
    call this%discrete_levelset_create()
    call this%mc_runtime_info_create()
    call this%subnodes_data_create()
  end if
end subroutine marching_cubes_create

!========================================================================================
subroutine marching_cubes_free(this)
  implicit none
  class(marching_cubes_t), intent(inout) :: this
  call this%subnodes_data_free()
  call this%mc_runtime_info_free()
  call this%discrete_levelset_free()
  call this%mc_tables_free()
  call this%nullify_triangulation()
  this%level_set_function => null()
  this%mc_tables_init = .false.
  this%mc_runtime_init   = .false.
  this%mc_cell_info_init = .false.
  this%current_cell_gid = -1_ip
  this%num_current_cell_nodes = -1_ip
  this%num_dims = -1_ip
  this%current_cell_sub_triangulation_updated = .false.
end subroutine marching_cubes_free

!========================================================================================
function marching_cubes_get_max_num_nodes_in_subcell( this ) result ( max_nodes_in_subcell )
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: max_nodes_in_subcell
  max_nodes_in_subcell = this%mc_table_num_nodes_in_sub_cell
end function marching_cubes_get_max_num_nodes_in_subcell

!========================================================================================
function marching_cubes_get_max_num_nodes_in_subfacet( this ) result ( max_nodes_in_subfacet)
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: max_nodes_in_subfacet
  max_nodes_in_subfacet = this%mc_table_num_nodes_in_sub_facet
end function marching_cubes_get_max_num_nodes_in_subfacet

!========================================================================================
function marching_cubes_get_max_num_subnodes_in_cell( this ) result ( max_subnodes_in_cell )
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: max_subnodes_in_cell
  class(triangulation_t), pointer :: triangulation
  triangulation => this%get_triangulation()
  max_subnodes_in_cell = triangulation%get_max_num_shape_functions() + this%mc_table_max_num_cut_edges
end function marching_cubes_get_max_num_subnodes_in_cell

!========================================================================================
function marching_cubes_get_num_mc_cases(this) result (mc_cases)
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: mc_cases
  mc_cases = this%mc_table_num_cases
end function marching_cubes_get_num_mc_cases

!========================================================================================
subroutine marching_cubes_update_sub_triangulation( this )
  implicit none
  class(marching_cubes_t)     :: this
  integer(ip)                 :: num_subnodes
  integer(ip)                 :: num_nodes
  integer(ip)                 :: num_intersections
  integer(ip)                 :: i1
  integer(ip)                 :: i2
  integer(ip)                 :: mc_case
  integer(ip)                 :: num_dim
  integer(ip)                 :: ipo
  integer(ip)                 :: idi
  integer(ip)                 :: subcell
  integer(ip)                 :: subfacet
  real(rp),           pointer :: points_in_quadrature(:,:)
  type(point_t),      pointer :: phys_cell_coords(:)
  integer(ip)                 :: subcell_nodes(4)
  integer(ip)                 :: subfacet_nodes(3)
  type(quadrature_t), pointer :: nodal_quadrature
  integer(ip)                 :: facet
  logical                     :: is_valid_submesh
  logical                     :: has_inverted_subcells
  class(cell_iterator_t), pointer :: cell_iterator
  if ( .not. this%current_cell_sub_triangulation_updated ) then
     cell_iterator => this%get_current_cell()
     assert ( associated(cell_iterator) )
     assert( this%is_cut() )

     assert( this%mc_runtime_init )
     assert( this%mc_cell_info_init )
     
     num_subnodes        = this%get_num_subnodes()
     num_dim             = this%num_dims
     num_intersections   = num_subnodes - this%num_current_cell_nodes
     
     assert( num_subnodes > this%num_current_cell_nodes )
     
     ! Recover the sub-points coordinates on the ref space
     this%reference_fe_geo => cell_iterator%get_reference_fe()
     assert ( num_subnodes <= size( this%subnodes_ref_coords ) )
     nodal_quadrature      => this%reference_fe_geo%get_nodal_quadrature()
     call nodal_quadrature%get_coordinates_as_points(this%subnodes_ref_coords(1: this%num_current_cell_nodes))
     i1                 =  this%mc_ptr_to_intersections( this%current_cell_gid )
     i2                 =  this%mc_ptr_to_intersections( this%current_cell_gid + 1 ) - 1
     this%subnodes_ref_coords(this%num_current_cell_nodes+1:num_subnodes) = this%mc_intersection_points( i1 : i2 )
     
     ! Recover connectivities of the sub-cells
     mc_case                      = this%mc_case_x_cell( this%current_cell_gid )
     this%num_subcells            = this%mc_table_num_sub_cells_x_case(mc_case)
     this%sub_cells_node_ids(:,:) = 0
     do subcell = 1, this%num_subcells
        this%sub_cells_node_ids( : , subcell ) = &
             this%mc_table_sub_cells_node_ids_x_case( :, subcell, mc_case )
     end do
     
     ! Recover connectivities of the sub-faces
     this%unfitted_sub_facets_node_ids(:,:) = 0
     this%num_subfacets                     = this%mc_table_num_unfitted_sub_facets_x_case(mc_case)
     do subfacet=1,this%num_subfacets
        this%unfitted_sub_facets_node_ids(:,subfacet) = &
             this%mc_table_unfitted_sub_facets_node_ids_x_case( :, subfacet , mc_case )
     end do
     
     ! Recover the status of the sub-cells
     this%subcells_status( : )                     = 0_ip
     this%subcells_status( 1 : this%num_subcells ) = this%mc_table_sub_cells_status_x_case( 1 : this%num_subcells, mc_case )

     ! Recover connectivities of the fitted sub facets at each facet
     this%fitted_sub_facets_node_ids_x_facet( : , : , : ) = 0
     do subfacet = 1, this%mc_table_max_num_fitted_sub_facets_in_facet
        do facet = 1, this%mc_table_num_facets
           this%fitted_sub_facets_node_ids_x_facet( : , subfacet, facet ) = &
                this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet( : , subfacet, facet, mc_case )
        end do
     end do

     ! Fix non-valid sub-cells and inverted sub-cells and sub-faces (only in 3D HEXAHEDRA)
     if ( this%num_dims == 3 ) then
        if ( this%reference_fe_geo%get_topology() == topology_hex ) then
           ! Check valid sub-triangulation 
           is_valid_submesh = this%is_valid_submesh()
           
           ! If not valid: redo Delaunay triangulation
           if ( .not. is_valid_submesh ) then
              call this%generate_subcells()
              call this%generate_subcells_status()
           end if
       
           ! Search for inverted sub-cells and reorient them
           this%sub_cell_has_been_reoriented(:) = .false.
           has_inverted_subcells                = .false.
           do subcell=1,this%num_subcells
              if ( this%is_inverted_subcell( subcell ) ) then
                 has_inverted_subcells                        = .true.
                 this%sub_cell_has_been_reoriented( subcell ) = .true.
                 subcell_nodes( : )                           = this%sub_cells_node_ids(:,subcell)
                 this%sub_cells_node_ids( : , subcell )       = subcell_nodes( [ 1, 3, 2, 4 ] )
                 assert( .not. this%is_inverted_subcell( subcell ) )
              end if
           end do
           
           ! If any inverted sub-cell found or the sub-triangulation was invalid:
           ! find again the boundary faces
           if ( has_inverted_subcells .or. ( .not. is_valid_submesh ) ) then 
              call this%generate_boundary_subfacets()
           end if
        end if
        massert( this%is_valid_submesh(), 'unfitted_cell_iterator::update_sub_triangulation: Non-valid cut cell sub-triangulation' )
     end if
     
     ! Update the quadrature
     assert( num_dim      == this%sub_nodes_nodal_quadratures(mc_case)%get_num_dims())
     assert( num_subnodes == this%sub_nodes_nodal_quadratures(mc_case)%get_num_quadrature_points())
     points_in_quadrature => this%sub_nodes_nodal_quadratures(mc_case)%get_coordinates()
     do ipo = 1, num_subnodes
        do idi = 1, num_dim
           points_in_quadrature( idi, ipo ) = this%subnodes_ref_coords( ipo )%get( idi )
        end do
     end do
     
     ! Prepare the fe map
     call this%sub_nodes_cell_maps( mc_case )%update_interpolation( & 
          this%sub_nodes_nodal_quadratures(mc_case), this%reference_fe_geo )
     phys_cell_coords => this%sub_nodes_cell_maps( mc_case )%get_coordinates()
     call cell_iterator%get_nodes_coordinates( phys_cell_coords )
     call this%sub_nodes_cell_maps( mc_case )%compute_quadrature_points_coordinates()
     
     ! At this point we can extract the physical coordinates of the sub-nodes from the cell_maps
     this%current_cell_sub_triangulation_updated = .true.
  end if
end subroutine marching_cubes_update_sub_triangulation


!========================================================================================
function marching_cubes_get_num_subcells( this ) result ( num_subcells )
  implicit none
  class(marching_cubes_t), intent(in) :: this
  integer(ip) :: num_subcells
  assert( this%mc_tables_init )
  assert( this%mc_cell_info_init )
  assert( this%is_cut() )
  ! In order to determine the number of subcells in the current (cut) cell
  ! we require to call update_sub_triangulation(). Recall that, in the
  ! case of hexahedral background meshes, it may happen that the standard marching cubes 
  ! algorithm leads to an invalid subtriangulation. In such a case, we need to call QHULL
  ! in order to create an in-situ Delaunay triangulation, which in turn may lead to a number
  ! of subcells different from the one corresponding to the matching marching cubes case
  call this%update_sub_triangulation()
  num_subcells = this%num_subcells
end function marching_cubes_get_num_subcells


!========================================================================================
function marching_cubes_get_num_subcell_nodes( this ) result ( num_nodes_subcell )
  implicit none
  class(marching_cubes_t), intent(in) :: this
  integer(ip) :: num_nodes_subcell
  assert(this%mc_tables_init)
  assert(this%mc_cell_info_init)
  assert( this%is_cut() )
  num_nodes_subcell = this%mc_table_num_nodes_in_sub_cell
end function marching_cubes_get_num_subcell_nodes

!========================================================================================
subroutine marching_cubes_get_phys_coords_of_subcell( this, subcell, points)
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip)            , intent(in)    :: subcell
  type(point_t)          , intent(inout) :: points(:)
  integer(ip) :: mc_case
  type(point_t), pointer :: subnodes_phys_coords(:)
  assert(this%mc_runtime_init)
  assert(this%mc_cell_info_init)
  assert( size(points) == this%get_num_subcell_nodes())
  assert( this%is_cut() )
  assert( (1_ip <= subcell) .and. (subcell <= this%get_num_subcells())  )
  call this%update_sub_triangulation()
  mc_case = this%mc_case_x_cell( this%current_cell_gid )
  subnodes_phys_coords => this%sub_nodes_cell_maps(mc_case)%get_quadrature_points_coordinates()
  points(:) = subnodes_phys_coords(this%sub_cells_node_ids(:,subcell))
end subroutine marching_cubes_get_phys_coords_of_subcell

!========================================================================================
subroutine marching_cubes_get_ref_coords_of_subcell( this, subcell, points)
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip)            , intent(in)    :: subcell
  type(point_t)          , intent(inout) :: points(:)
  assert(this%mc_runtime_init)
  assert(this%mc_cell_info_init)
  assert( size(points) == this%get_num_subcell_nodes())
  assert( this%is_cut()  )
  assert( (1_ip <= subcell) .and. (subcell <= this%get_num_subcells() ) )
  call this%update_sub_triangulation()
  points(:) = this%subnodes_ref_coords(this%sub_cells_node_ids(:,subcell))
end subroutine marching_cubes_get_ref_coords_of_subcell

!========================================================================================
function marching_cubes_get_num_subfacets( this ) result ( num_subfacets )
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: num_subfacets
  assert(this%mc_tables_init)
  assert(this%mc_cell_info_init)
  assert(this%is_cut())
  ! In order to determine the number of subfacets in the current (cut) cell
  ! we require to call update_sub_triangulation(). Recall that, in the
  ! case of hexahedral background meshes, it may happen that the standard marching cubes 
  ! algorithm leads to an invalid subtriangulation. In such a case, we need to call QHULL
  ! in order to create an in-situ Delaunay triangulation, which in turn may lead to a number
  ! of subfacets different from the one corresponding to the matching marching cubes case
  call this%update_sub_triangulation()
  num_subfacets = this%num_subfacets
end function marching_cubes_get_num_subfacets

!========================================================================================
function marching_cubes_get_num_subfacet_nodes( this ) result ( num_nodes_subfacet )
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: num_nodes_subfacet
  assert(this%mc_tables_init)
  assert(this%mc_cell_info_init)
  assert(this%is_cut())
  num_nodes_subfacet = this%mc_table_num_nodes_in_sub_facet
end function marching_cubes_get_num_subfacet_nodes

!========================================================================================
subroutine marching_cubes_get_phys_coords_of_subfacet( this, subfacet, points )
  implicit none
  class(marching_cubes_t),  intent(in)    :: this
  integer(ip),              intent(in)    :: subfacet
  type(point_t),            intent(inout) :: points(:)
  integer(ip)               :: mc_case
  type(point_t),    pointer :: subnodes_phys_coords(:)
  assert(this%mc_runtime_init)
  assert(this%mc_cell_info_init)
  assert(size(points) ==  this%get_num_subfacet_nodes())
  assert(this%is_cut())
  assert( (1_ip <= subfacet) .and. (subfacet <= this%get_num_subfacets() ) )
  call this%update_sub_triangulation()
  mc_case = this%mc_case_x_cell( this%current_cell_gid )
  subnodes_phys_coords => this%sub_nodes_cell_maps(mc_case)%get_quadrature_points_coordinates()
  points(:) = subnodes_phys_coords(this%unfitted_sub_facets_node_ids(:,subfacet))
end subroutine marching_cubes_get_phys_coords_of_subfacet

!========================================================================================
subroutine marching_cubes_get_ref_coords_of_subfacet( this, subfacet, points )

  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip)            , intent(in)    :: subfacet
  type(point_t)          , intent(inout) :: points(:)
  integer(ip)            :: mc_case
  assert(this%mc_runtime_init)
  assert(this%mc_cell_info_init)
  assert( size(points) == this%get_num_subfacet_nodes())
  assert(this%is_cut())
  assert( (1_ip <= subfacet) .and. (subfacet <= this%get_num_subfacets() ) )
  call this%update_sub_triangulation()
  mc_case = this%mc_case_x_cell( this%current_cell_gid )
  points(:) = this%subnodes_ref_coords(this%unfitted_sub_facets_node_ids(:,subfacet))
end subroutine marching_cubes_get_ref_coords_of_subfacet

!========================================================================================
function marching_cubes_is_cut( this ) result ( is_cut )
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  logical :: is_cut
  integer(ip) :: mc_case
  integer(ip) :: num_mc_cases
  assert( this%mc_runtime_init )
  mc_case = this%mc_case_x_cell( this%current_cell_gid )
  num_mc_cases = this%mc_table_num_cases
  is_cut = (1_ip < mc_case) .and. ( mc_case < num_mc_cases)
end function marching_cubes_is_cut

!========================================================================================
function marching_cubes_is_interior( this ) result ( is_interior )
  implicit none
  class(marching_cubes_t), intent(in)  :: this
  logical :: is_interior
  integer(ip) :: mc_case
  integer(ip) :: num_mc_cases
  assert(this%mc_runtime_init)
  mc_case = this%mc_case_x_cell( this%current_cell_gid )
  num_mc_cases = this%mc_table_num_cases
  is_interior = ( mc_case == num_mc_cases )
end function marching_cubes_is_interior

!========================================================================================
function marching_cubes_is_exterior( this ) result ( is_exterior )
  implicit none
  class(marching_cubes_t), intent(in)  :: this
  logical :: is_exterior
  integer(ip) :: mc_case
  assert(this%mc_runtime_init)
  mc_case = this%mc_case_x_cell( this%current_cell_gid )
  is_exterior = ( mc_case == 1_ip )
end function marching_cubes_is_exterior

!========================================================================================
function marching_cubes_is_interior_subcell( this, subcell ) result ( is_in )
  implicit none
  class(marching_cubes_t), intent(in)  :: this
  integer(ip), intent(in) :: subcell
  logical :: is_in
  integer(ip) :: num_subcells
  integer(ip) :: pos
  assert(this%mc_runtime_init)
  assert(this%is_cut())
  ! Although is_interior_subcell requires the subtriangulation to be updated
  ! for the current (cut) cell, we do not call update_sub_triangulation() explicitly
  ! as we assume that this%get_num_subcells() already triggers it if necessary
  num_subcells = this%get_num_subcells()
  assert( ( 1_ip <= subcell) .and. subcell <= num_subcells )
  pos = this%subcells_status(subcell)
  is_in = ( pos == -1_ip )
end function marching_cubes_is_interior_subcell

!========================================================================================
function marching_cubes_is_exterior_subcell( this, subcell ) result ( is_out )
  implicit none
  class(marching_cubes_t), intent(in)  :: this
  integer(ip), intent(in) :: subcell
  logical :: is_out
  integer(ip) :: num_subcells
  integer(ip) :: pos
  assert(this%mc_runtime_init)
  assert(this%is_cut())
  ! Although is_exterior_subcell requires the subtriangulation to be updated
  ! for the current (cut) cell, we do not call update_sub_triangulation() explicitly
  ! as we assume that this%get_num_subcells() already triggers it if necessary
  num_subcells = this%get_num_subcells()
  assert( ( 1_ip <= subcell) .and. subcell <= num_subcells )
  pos = this%subcells_status( subcell )
  is_out = ( pos == 1_ip )
end function marching_cubes_is_exterior_subcell

!========================================================================================
function marching_cubes_get_num_subnodes( this ) result (num_subnodes)
  implicit none
  class(marching_cubes_t), intent(in) :: this
  integer(ip) :: num_subnodes
  integer(ip) :: mc_case
  assert(this%mc_tables_init)
  mc_case      = this%mc_case_x_cell( this%current_cell_gid )
  num_subnodes = this%mc_table_num_cut_edges_x_case(mc_case) + this%num_current_cell_nodes
end function marching_cubes_get_num_subnodes


!========================================================================================
function marching_cubes_get_num_fitted_subfacets ( this, facet_lid ) result (num_fitted_subfacets)
  implicit none
  class(marching_cubes_t), intent(in) :: this
  integer(ip),             intent(in) :: facet_lid
  integer(ip) :: num_fitted_subfacets
  integer(ip) :: mc_case
  mc_case              = this%mc_case_x_cell( this%current_cell_gid )
  num_fitted_subfacets = this%mc_table_num_fitted_sub_facets_x_case_and_facet( facet_lid, mc_case )
end function marching_cubes_get_num_fitted_subfacets

!========================================================================================
subroutine marching_cubes_get_phys_coords_of_subvef ( this, facet_lid, subvef, points )
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip)            , intent(in)    :: facet_lid
  integer(ip)            , intent(in)    :: subvef
  type(point_t)          , intent(inout) :: points(:)
  integer(ip)            :: mc_case
  type(point_t), pointer :: subnodes_phys_coords(:)
  assert(this%mc_runtime_init)
  call this%update_sub_triangulation()
  mc_case = this%mc_case_x_cell( this%current_cell_gid )
  subnodes_phys_coords => this%sub_nodes_cell_maps(mc_case)%get_quadrature_points_coordinates()
  points(:) = subnodes_phys_coords(this%fitted_sub_facets_node_ids_x_facet(:, subvef, facet_lid ))
end subroutine marching_cubes_get_phys_coords_of_subvef

!========================================================================================
subroutine marching_cubes_get_ref_coords_of_subvef ( this, reference_fe, facet_lid, subvef, points )
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  class(reference_fe_t)  , intent(in)    :: reference_fe
  integer(ip)            , intent(in)    :: facet_lid
  integer(ip)            , intent(in)    :: subvef
  type(point_t)          , intent(inout) :: points(:)
  integer(ip) :: mc_case
  integer(ip) :: num_dims
  integer(ip) :: dime1
  integer(ip) :: dime2
  integer(ip) :: ipoint
  integer(ip) :: cell_to_facet_coords_2d(4)
  integer(ip) :: cell_to_facet_coords_3d(2,6)
  assert(this%mc_runtime_init)
  call this%update_sub_triangulation()
  mc_case = this%mc_case_x_cell( this%current_cell_gid )
  points(:) = this%subnodes_ref_coords(this%fitted_sub_facets_node_ids_x_facet( :, subvef, facet_lid ))
  num_dims = this%num_dims
  
  select case (reference_fe%get_topology())
    case ( topology_tet )
     cell_to_facet_coords_2d(1:3) = [1,2,1]
     cell_to_facet_coords_3d(:,1:4) = reshape(&
                                                           [1,2,&
                                                            1,3,&
                                                            2,3,&
                                                            1,2],[2,4])
    case ( topology_hex )
     cell_to_facet_coords_2d(:) = [1,1,2,2]
     cell_to_facet_coords_3d(:,:) = reshape(&
                                                           [1,2,&
                                                            1,2,&
                                                            1,3,&
                                                            1,3,&
                                                            2,3,&
                                                            2,3],[2,6])
   case DEFAULT
     mcheck(.false., 'get_ref_coords_of_subvef::unfitted_vef_iterator: Only hex and tet lagrangian reference FE' )
   end select
  
  if (num_dims == 2) then
    dime1 = cell_to_facet_coords_2d(facet_lid)
    do ipoint = 1, size(points)
      call points(ipoint)%set(1, points(ipoint)%get(dime1))
      call points(ipoint)%set(2, 0.0_rp)
      call points(ipoint)%set(3, 0.0_rp)
    end do
  else if (num_dims == 3) then
    dime1 = cell_to_facet_coords_3d(1,facet_lid)
    dime2 = cell_to_facet_coords_3d(2,facet_lid)
    do ipoint = 1, size(points)
      call points(ipoint)%set(1, points(ipoint)%get(dime1))
      call points(ipoint)%set(2, points(ipoint)%get(dime2))
      call points(ipoint)%set(3, 0.0_rp)
    end do
  else
    mcheck(.false.,'get_ref_coords_of_subvef::unfitted_vef_iterator: Only for 2D and 3D')
  end if
  
end subroutine marching_cubes_get_ref_coords_of_subvef

!========================================================================================
function marching_cubes_is_cut_facet ( this, facet_lid ) result ( is_cut )
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip),             intent(in)    :: facet_lid
  logical :: is_cut
  integer(ip) :: mc_case
  integer(ip) :: istat
  
  mc_case = this%mc_case_x_cell( this%current_cell_gid )
  istat   = this%mc_table_facet_status_x_case_and_facet( facet_lid, mc_case )
  is_cut  = (istat == 0_ip)
  
end function marching_cubes_is_cut_facet


!========================================================================================
function marching_cubes_is_interior_facet ( this, facet_lid ) result ( is_interior )
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip),             intent(in)    :: facet_lid
  logical :: is_interior
  integer(ip) :: mc_case
  integer(ip) :: istat
  
  mc_case     = this%mc_case_x_cell( this%current_cell_gid )
  istat       = this%mc_table_facet_status_x_case_and_facet( facet_lid, mc_case )
  is_interior = (istat == -1_ip)
  
end function marching_cubes_is_interior_facet

!========================================================================================
function marching_cubes_is_exterior_facet ( this, facet_lid ) result ( is_exterior )
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip),             intent(in)    :: facet_lid
  logical :: is_exterior
  integer(ip) :: mc_case
  integer(ip) :: istat
  
  mc_case     = this%mc_case_x_cell( this%current_cell_gid )
  istat       = this%mc_table_facet_status_x_case_and_facet( facet_lid, mc_case )
  is_exterior = (istat == 1_ip)
  
end function marching_cubes_is_exterior_facet

!========================================================================================
function marching_cubes_is_interior_subfacet ( this, facet_lid, subvef ) result ( is_in)
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip),             intent(in)    :: facet_lid
  integer(ip),             intent(in)    :: subvef
  logical :: is_in
  integer(ip) :: mc_case
  integer(ip) :: istat
  
  mc_case = this%mc_case_x_cell( this%current_cell_gid )
  istat   = this%mc_table_fitted_sub_facets_status_x_case_and_facet( subvef, facet_lid, mc_case )
  is_in   = (istat == -1_ip)

end function marching_cubes_is_interior_subfacet

!========================================================================================
function marching_cubes_is_exterior_subfacet ( this, facet_lid, subvef ) result ( is_out )
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip),             intent(in)    :: facet_lid
  integer(ip),             intent(in)    :: subvef
  logical :: is_out
  integer(ip) :: mc_case
  integer(ip) :: istat

  mc_case = this%mc_case_x_cell( this%current_cell_gid )
  istat   = this%mc_table_fitted_sub_facets_status_x_case_and_facet( subvef, facet_lid, mc_case )
  is_out  = (istat == 1_ip)

end function marching_cubes_is_exterior_subfacet

!========================================================================================
subroutine marching_cubes_set_current_cell ( this, cell ) 
  implicit none
  class(marching_cubes_t)       , intent(inout) :: this
  class(cell_iterator_t), target, intent(in)    :: cell
  
  ! If a client calls "set_current_cell" with the same cell
  ! used in a previous call to "set_current_cell"ctes, then don't
  ! touch the current_cell_sub_triangulation_updated member
  ! variable
  if ( cell%get_gid() /= this%current_cell_gid ) then
    this%current_cell_sub_triangulation_updated = .false.
  end if 
  call ubc_set_current_cell(this,cell)
  if ( .not. cell%has_finished() ) then 
     this%current_cell_gid = cell%get_gid()
     this%num_current_cell_nodes   = cell%get_num_nodes()
  else
     this%current_cell_gid = -1_ip
     this%num_current_cell_nodes   = -1_ip
  end if    
end subroutine marching_cubes_set_current_cell

!========================================================================================
subroutine marching_cubes_print ( this )

  implicit none
  class(marching_cubes_t), intent(in)    :: this

  class(cell_iterator_t), allocatable :: cell
  type(point_t),          allocatable :: cell_coords(:)
  type(point_t),          allocatable :: subcell_coords(:)
  type(point_t),          allocatable :: subfacet_coords(:)
  integer(ip)                         :: inode
  integer(ip)                         :: isubcell
  integer(ip)                         :: isubfacet
  class(triangulation_t), pointer :: triangulation
  
  triangulation => this%get_triangulation()

  ! Print basic info of triangulation
  write(*,*) " "
  write (*,'(a)') '**** print type(marching_cubes_t) [begin] ****'
  write(*,*) " "
  write (*,'(a,i10)') 'num_dims:           ', triangulation%get_num_dims()
  write (*,'(a,i10)') 'num_cells:                ', triangulation%get_num_cells()
  write (*,'(a,i10)') 'num_local_cells:          ', triangulation%get_num_local_cells()
  write (*,'(a,i10)') 'num_ghost_cells:          ', triangulation%get_num_ghost_cells()
  write (*,'(a,i10)') 'num_cut_cells:            ', this%get_num_cut_cells()
  write (*,'(a,i10)') 'num_interior_cells:       ', this%get_num_interior_cells()
  write (*,'(a,i10)') 'num_exterior_cells:       ', this%get_num_exterior_cells()
  write (*,'(a,i10)') 'max_num_nodes_in_cell:    ', triangulation%get_max_num_shape_functions()
  write (*,'(a,i10)') 'max_num_subcells_in_cell: ', this%get_max_num_subcells_in_cell()
  write (*,'(a,i10)') 'max_num_nodes_in_subcell: ', this%get_max_num_nodes_in_subcell()
  write (*,'(a,i10)') 'max_num_subfacets_in_cell: ', this%get_max_num_subfacets_in_cell()
  write (*,'(a,i10)') 'max_num_nodes_in_subfacet: ', this%get_max_num_nodes_in_subfacet()
  write (*,'(a,i10)') 'max_num_subnodes_in_cell: ', this%get_max_num_subnodes_in_cell()
  write(*,*) " "

  ! Print basic info of cells
  call triangulation%create_cell_iterator(cell)
  write(*,'(7a20)') 'id', 'is_cut', 'is_interior', 'is_exterior', 'num_nodes' , 'num_subcells', 'num_nodes_subcell'
  do while ( .not. cell%has_finished() )
    write(*,'(i20,3L20,3i20)') cell%get_gid(), cell%is_cut(), cell%is_interior(), cell%is_exterior(), &
                               cell%get_num_nodes(), cell%get_num_subcells(), cell%get_num_subcell_nodes()
    call cell%next()
  end do
  write(*,*) " "

  call memalloc( triangulation%get_max_num_shape_functions(), cell_coords   , __FILE__, __LINE__ )
  call memalloc( this%get_max_num_nodes_in_subcell()  , subcell_coords, __FILE__, __LINE__ )
  call memalloc( this%get_max_num_nodes_in_subfacet()  , subfacet_coords, __FILE__, __LINE__ )

  ! Print coordinates of cells and sub-cells
  write(*,'(3a7,7a11)') 'id', 'scid', 'sfid', 'x1', 'y1', 'z1', 'x2', 'y2', 'z2', 'etc.'
  call cell%first()
  do while ( .not. cell%has_finished() )
    call cell%get_nodes_coordinates( cell_coords )
    write (*,'(i7,2a7,20(2x,e9.2))'  ) cell%get_gid(), ' ', ' ',(cell_coords(inode)%get_value(),inode=1,cell%get_num_nodes())
    do isubcell = 1, cell%get_num_subcells()
      call cell%get_phys_coords_of_subcell(isubcell,subcell_coords)
      write (*,'(a7,i7,a7,20(2x,e9.2))'  ) ' ', isubcell, ' ' ,(subcell_coords(inode)%get_value(),inode=1,cell%get_num_subcell_nodes())
    end do
    do isubfacet = 1, cell%get_num_subfacets()
      call cell%get_phys_coords_of_subfacet(isubfacet,subfacet_coords)
      write (*,'(2a7,i7,20(2x,e9.2))'  ) ' ', ' ' , isubfacet,(subfacet_coords(inode)%get_value(),inode=1,cell%get_num_subfacet_nodes())
    end do
    call cell%next()
  end do

  write(*,*) " "
  write (*,'(a)') '**** print type(marching_cubes_t) [end] ****'
  write(*,*) " "

 call memfree( cell_coords   , __FILE__, __LINE__ )
 call memfree( subcell_coords, __FILE__, __LINE__ )
 call memfree( subfacet_coords, __FILE__, __LINE__ )
 call triangulation%free_cell_iterator(cell)

end subroutine marching_cubes_print

! Private TBP

!========================================================================================
function marching_cubes_is_inverted_subcell(this,subcell) result (is_inverted)

  implicit none
  class(marching_cubes_t), target, intent(in) :: this
  integer(ip),                     intent(in) :: subcell
  logical :: is_inverted

  type(point_t)        :: Xe(4)
  type(vector_field_t) :: u,v,w
  integer(ip), pointer :: Te(:)
  real(rp)             :: vol

  ! This routine is only needed (and implemented) when the sub-cell is a tetrahedron
  ! Check it
  assert( 1 <= subcell .and. subcell <= this%num_subcells )
  assert( this%get_num_subcell_nodes() == 4)
  assert( this%num_dims == 3)

  ! Get connectivities and coordinates
  ! We assume that update_triangulation was called for this cell
  Te => this%sub_cells_node_ids(:,subcell)
  Xe(:) = this%subnodes_ref_coords(Te)

  ! Compute (signed) volume
  u = Xe(2) - Xe(1)
  v = Xe(3) - Xe(1)
  w = Xe(4) - Xe(1)
  vol = w*cross_product(u,v)

  ! Check if inverted
  is_inverted = vol < 0.0_rp

end function marching_cubes_is_inverted_subcell

!========================================================================================
function marching_cubes_is_valid_submesh(this) result ( is_valid_submesh )

  implicit none
  class(marching_cubes_t), target, intent(in) :: this
  logical :: is_valid_submesh

  integer(ip)          :: subcell
  type(point_t)        :: Xe(4)
  type(vector_field_t) :: u,v,w
  integer(ip), pointer :: Te(:)
  real(rp)             :: vol
  real(rp),  parameter :: volume_reference_fe_hex = 8.0_rp
  real(rp),  parameter :: volume_reference_fe_tet = 1.0_rp/6.0_rp
  real(rp),  parameter :: tol_volume =  1.0e-13_rp
  ! This routine is only needed (and implemented) when the sub-cell is a tetrahedron
  ! Check it
  assert( this%get_num_subcell_nodes() == 4 )
  assert( this%num_dims == 3 )

  vol = 0.0_rp
  do subcell=1,this%num_subcells

    ! Get connectivities and coordinates
    ! We assume that update_triangulation was called for this cell
    Te => this%sub_cells_node_ids(:,subcell)
    Xe(:) = this%subnodes_ref_coords(Te)

    ! Compute volume
    u = Xe(1) - Xe(4)
    v = Xe(2) - Xe(4)
    w = Xe(3) - Xe(4)
    vol = vol + volume_reference_fe_tet*abs(u*cross_product(v,w))
  end do

  if ( this%reference_fe_geo%get_topology() == topology_hex ) then
    is_valid_submesh = ( abs( vol-volume_reference_fe_hex ) < tol_volume )
  else if ( this%reference_fe_geo%get_topology() == topology_tet ) then
    is_valid_submesh = ( abs( vol-volume_reference_fe_tet ) < tol_volume )
  end if
end function marching_cubes_is_valid_submesh

!========================================================================================
subroutine marching_cubes_generate_subcells(this)

  implicit none
  class(marching_cubes_t), target, intent(inout) :: this

#ifdef ENABLE_QHULL

  integer(ip) :: ierror
  real(qh_coordT), allocatable :: points(:,:)
  integer(qh_int),    pointer  :: cells(:,:)
  integer(ip),       parameter :: num_dims = 3
  integer(ip)                  :: num_points
  integer(ip)                  :: num_cells
  integer(ip)                  :: ipoin
  integer(ip)                  :: idime

  assert(this%num_dims == num_dims)
  assert(qh_int == ip)
  assert(qh_coordT == rp)

  ! Convert point coordinates to an intrinsic Fortran array
  num_points = this%get_num_subnodes()
  call memalloc(num_dims,num_points,points,__FILE__,__LINE__)
  do ipoin = 1,num_points
    do idime = 1, num_dims
      points(idime,ipoin) = this%subnodes_ref_coords(ipoin)%get(idime)
    end do
  end do

  ! Compute number of cells in the Delaunay triangulation
  num_cells = 0
  ierror = delaunay_init_and_compute_f90(num_dims, num_points, points, num_cells)
  check(ierror == 0)
  this%num_subcells = num_cells
  call this%reallocate_nsubcells_arrays()
  

  ! Fill in the cells connectivities
  cells => this%sub_cells_node_ids
  cells(:,:) = 0
  check(num_cells <= size(cells,2))
  ierror = delaunay_fill_cells_f90(num_dims, num_cells, cells)
  check(ierror == 0)

  ! Clean up
  ierror = delaunay_free_f90()
  check(ierror == 0)
  call memfree(points,__FILE__,__LINE__)

#else

  mcheck(.false.,'This subroutine needs ENABLE_QHULL')

#endif

end subroutine marching_cubes_generate_subcells

!========================================================================================
subroutine marching_cubes_generate_subcells_status(this)

  implicit none
  class(marching_cubes_t), intent(inout) :: this

  integer(ip)            :: isubcell
  integer(ip)            :: inode
  real(rp),      pointer :: levelset_nodal_values(:)
  real(rp)               :: phi
  integer(ip), parameter :: field_id = 1

  ! By default the sub-cells are outside
  this%subcells_status(:) = 0_ip
  this%subcells_status( 1 : this%num_subcells ) = 1_ip

  ! Recover the values of the levelset function on the subnodes
  this%level_set_all_nodes(:) = 0.0_rp
  call this%fe%set_gid( this%current_cell_gid )
  call this%fe_levelset%gather_nodal_values( this%fe, field_id, this%level_set_all_nodes )
  
  assert( this%fe_space%get_num_fields()==field_id )

  ! Set as interior the sub-cells that touches an interior point
  do isubcell = 1, this%num_subcells
    do inode = 1, this%get_num_subcell_nodes()
      phi = this%level_set_all_nodes( this%sub_cells_node_ids( inode, isubcell ) )
      if ( phi < 0 ) then
        this%subcells_status( isubcell ) = -1_ip
        exit
      end if
    end do
  end do
  

end subroutine marching_cubes_generate_subcells_status

!========================================================================================
subroutine marching_cubes_generate_boundary_subfacets(this)

  implicit none
  class(marching_cubes_t), target, intent(inout) :: this

  integer(ip), parameter :: nbef = 4
  integer(ip), parameter :: nbfn = 3
  integer(ip), parameter :: FACETS(nbfn,nbef) = reshape([1,2,3, 1,4,2, 1,3,4, 2,4,3],[nbfn,nbef])
                                                        ![1,3,2, 1,2,4, 2,3,4, 1,4,3]
  integer(ip)          :: iscell
  integer(ip)          :: isfacet
  integer(ip)          :: nsfacet
  integer(ip), pointer :: Te(:)
  integer(ip)          :: ineig

  assert(this%num_dims == 3)

  ! Reset the sub-facets nodes ids
  this%unfitted_sub_facets_node_ids(:,:) = 0

  ! Find the neighbors in the sub-mesh
  this%subcell_facet_neigs(:,:) = -1
  call find_facets_neighbors_in_mesh(&
    T      =  this%sub_cells_node_ids,&
    nbel   =  this%num_subcells,&
    facets =  FACETS,&
    nbef   =  nbef,&
    neigs  =  this%subcell_facet_neigs)

  nsfacet = 0
  ! Loop in interior sub-cells
  do iscell = 1,this%num_subcells
    if (this%subcells_status(iscell)==-1) then
      Te => this%sub_cells_node_ids(:,iscell)

      ! Loop in interior sub-cells
      do isfacet = 1, nbef
        ineig = this%subcell_facet_neigs(isfacet,iscell)
        assert(ineig /= -1)

        ! If the neig along this facet is exterior, then take the facets node ids
        if (ineig>0) then
          if (this%subcells_status(ineig)==1) then
            nsfacet = nsfacet + 1
            ! memrealloc is here since the number of subfacets is determined by delaunay and cannot be known beforehand
            call memrealloc_if_more_space_needed ( &
                 this%get_max_num_nodes_in_subfacet(), &
                 nsfacet, &
                 this%unfitted_sub_facets_node_ids, &
                __FILE__, __LINE__ )
            this%unfitted_sub_facets_node_ids(:,nsfacet) = Te(FACETS(:,isfacet))
          end if
        end if

      end do

    end if
  end do
  this%num_subfacets = nsfacet

end subroutine marching_cubes_generate_boundary_subfacets


!========================================================================================
function marching_cubes_fulfills_assumptions(this) result (fulfills)
  implicit none
  class(marching_cubes_t), intent(in) :: this
  logical :: fulfills

  class(cell_iterator_t),      allocatable  :: cell
  class(reference_fe_t),            pointer :: reference_fe_geo
  character(:),                 allocatable :: topology
  integer(ip)                               :: num_dim, num_dim_tmp, p_order

  ! Hypothesis: All cells in the mesh are either bi-linear tri/qua or tri-linear tet/hex
  fulfills = .true.
  call this%create_cell_iterator(cell)
  num_dim  = this%num_dims
  if ( (num_dim .ne. 2) .and. (num_dim .ne. 3) ) fulfills = .false.
  do while ( .not. cell%has_finished() )
    if (cell%is_local()) then
      reference_fe_geo => cell%get_reference_fe()
      num_dim_tmp  = reference_fe_geo%get_num_dims()
      if (num_dim .ne. num_dim_tmp) fulfills = .false.
      p_order  = reference_fe_geo%get_order()
      if (p_order .ne. 1_ip) fulfills = .false.
      topology = reference_fe_geo%get_topology()
      if (.not. fulfills) exit
    end if
    call cell%next()
  end do
  call this%free_cell_iterator(cell)

end function marching_cubes_fulfills_assumptions

!========================================================================================
subroutine marching_cubes_mc_tables_create(this)
  implicit none
  class(marching_cubes_t), intent(inout) :: this

  class(reference_fe_t), pointer :: ref_fe
  integer(ip)                    :: num_vertices
  integer(ip)                    :: num_dim
  
  class(triangulation_t), pointer :: triangulation
  triangulation => this%get_triangulation()

  ! To be safe
  call this%mc_tables_free()

  ! Get element type, we assume hex-like topology
  mcheck( triangulation%get_num_reference_fes() == 1_ip, 'marching_cubes::mc_tables_create: Implememntation pending for hybrid meshes' )
  ref_fe       => triangulation%get_reference_fe(ref_fe_geo_id = 1_ip)
  num_vertices =  ref_fe%get_num_vertices()
  num_dim      =  this%num_dims

  
  ! Fill in the sizes of the tables
  if (num_dim == 2_ip) then
    if ( num_vertices == 3_ip ) then
       this%mc_table_num_cases                          = MC_TRI3_NUM_CASES
       this%mc_table_num_facets                         = MC_TRI3_NUM_FACETS
       this%mc_table_max_num_sub_cells                  = MC_TRI3_MAX_NUM_SUBCELLS
       this%mc_table_max_num_unfitted_sub_facets        = MC_TRI3_MAX_NUM_SUBFACES
       this%mc_table_max_num_fitted_sub_facets_in_facet = MC_TRI3_MAX_NUM_FITTED_SUB_FACETS_IN_FACET
       this%mc_table_max_num_cut_edges                  = MC_TRI3_MAX_NUM_CUT_EDGES
       this%mc_table_num_nodes_in_sub_cell              = MC_TRI3_NUM_NODES_PER_SUBCELL
       this%mc_table_num_nodes_in_sub_facet             = MC_TRI3_NUM_NODES_PER_SUBFACE
    else if ( num_vertices == 4_ip ) then
       this%mc_table_num_cases                          = MC_QUA4_NUM_CASES
       this%mc_table_num_facets                         = MC_QUA4_NUM_FACETS
       this%mc_table_max_num_sub_cells                  = MC_QUA4_MAX_NUM_SUBCELLS
       this%mc_table_max_num_unfitted_sub_facets        = MC_QUA4_MAX_NUM_SUBFACES
       this%mc_table_max_num_fitted_sub_facets_in_facet = MC_QUA4_MAX_NUM_FITTED_SUB_FACETS_IN_FACET
       this%mc_table_max_num_cut_edges                  = MC_QUA4_MAX_NUM_CUT_EDGES
       this%mc_table_num_nodes_in_sub_cell              = MC_QUA4_NUM_NODES_PER_SUBCELL
       this%mc_table_num_nodes_in_sub_facet             = MC_QUA4_NUM_NODES_PER_SUBFACE
    end if
  else if (num_dim == 3_ip) then
    if ( num_vertices == 4_ip ) then
       this%mc_table_num_cases                          = MC_TET4_NUM_CASES
       this%mc_table_num_facets                         = MC_TET4_NUM_FACETS
       this%mc_table_max_num_sub_cells                  = MC_TET4_MAX_NUM_SUBCELLS
       this%mc_table_max_num_unfitted_sub_facets        = MC_TET4_MAX_NUM_SUBFACES
       this%mc_table_max_num_fitted_sub_facets_in_facet = MC_TET4_MAX_NUM_FITTED_SUB_FACETS_IN_FACET
       this%mc_table_max_num_cut_edges                  = MC_TET4_MAX_NUM_CUT_EDGES
       this%mc_table_num_nodes_in_sub_cell              = MC_TET4_NUM_NODES_PER_SUBCELL
       this%mc_table_num_nodes_in_sub_facet             = MC_TET4_NUM_NODES_PER_SUBFACE
    else if ( num_vertices == 8_ip ) then
       this%mc_table_num_cases                          = MC_HEX8_NUM_CASES
       this%mc_table_num_facets                         = MC_HEX8_NUM_FACETS
       this%mc_table_max_num_sub_cells                  = MC_HEX8_MAX_NUM_SUBCELLS
       this%mc_table_max_num_unfitted_sub_facets        = MC_HEX8_MAX_NUM_SUBFACES
       this%mc_table_max_num_fitted_sub_facets_in_facet = MC_HEX8_MAX_NUM_FITTED_SUB_FACETS_IN_FACET
       this%mc_table_max_num_cut_edges                  = MC_HEX8_MAX_NUM_CUT_EDGES
       this%mc_table_num_nodes_in_sub_cell              = MC_HEX8_NUM_NODES_PER_SUBCELL
       this%mc_table_num_nodes_in_sub_facet             = MC_HEX8_NUM_NODES_PER_SUBFACE
    else 
       mcheck( .false. , 'marching_cubes::mc_tables_create: Non-supported mesh element type' )
    end if
  else
    mcheck( .false. , 'marching_cubes::mc_tables_create: Non-supported mesh dimensions' )
  end if

  ! Now, we know the sizes and can allocate
  call memalloc (this%mc_table_num_cases, &
                 this%mc_table_num_sub_cells_x_case    , __FILE__, __LINE__ )

  call memalloc (this%mc_table_num_cases, &
                 this%mc_table_num_unfitted_sub_facets_x_case    , __FILE__, __LINE__ )

  call memalloc (this%mc_table_num_cases, &
                 this%mc_table_num_cut_edges_x_case   , __FILE__, __LINE__ )

  call memalloc (this%mc_table_max_num_sub_cells, this%mc_table_num_cases, &
                 this%mc_table_sub_cells_status_x_case  , __FILE__, __LINE__ )

  call memalloc (this%mc_table_num_nodes_in_sub_cell, this%mc_table_max_num_sub_cells, this%mc_table_num_cases, &
                 this%mc_table_sub_cells_node_ids_x_case, __FILE__, __LINE__ )

  call memalloc (this%mc_table_num_nodes_in_sub_facet, this%mc_table_max_num_unfitted_sub_facets, this%mc_table_num_cases, &
                 this%mc_table_unfitted_sub_facets_node_ids_x_case, __FILE__, __LINE__ )

  call memalloc (this%mc_table_num_facets, this%mc_table_num_cases, &
                 this%mc_table_num_fitted_sub_facets_x_case_and_facet, __FILE__, __LINE__ )

  call memalloc (this%mc_table_num_facets, this%mc_table_num_cases, &
                 this%mc_table_facet_status_x_case_and_facet, __FILE__, __LINE__ )

  call memalloc (this%mc_table_max_num_fitted_sub_facets_in_facet,this%mc_table_num_facets, this%mc_table_num_cases, &
                 this%mc_table_fitted_sub_facets_status_x_case_and_facet, __FILE__, __LINE__ )

  call memalloc (this%mc_table_num_nodes_in_sub_facet,this%mc_table_max_num_fitted_sub_facets_in_facet,this%mc_table_num_facets, this%mc_table_num_cases, &
                 this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet, __FILE__, __LINE__ )

  ! Fill tables for the selected element type
  if (num_dim == 2_ip) then
     if ( num_vertices == 3_ip ) then
        this%mc_table_num_sub_cells_x_case(:)                              = MC_TRI3_NUM_SUBCELLS_PER_CASE(:)
        this%mc_table_num_unfitted_sub_facets_x_case(:)                    = MC_TRI3_NUM_SUBFACES_PER_CASE(:)
        this%mc_table_num_cut_edges_x_case(:)                              = MC_TRI3_NUM_CUT_EDGES_PER_CASE(:)
        this%mc_table_sub_cells_status_x_case(:,:)                         = MC_TRI3_INOUT_SUBCELLS_PER_CASE(:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,:)                     = MC_TRI3_SUBCELL_NODE_IDS_PER_CASE(:,:,:)
        this%mc_table_unfitted_sub_facets_node_ids_x_case(:,:,:)           = MC_TRI3_SUBFACE_NODE_IDS_PER_CASE(:,:,:)
        this%mc_table_num_fitted_sub_facets_x_case_and_facet(:,:)          = MC_TRI3_NUM_SUB_FACETS_PER_CASE_AND_FACET(:,:)
        this%mc_table_facet_status_x_case_and_facet(:,:)                   = MC_TRI3_FACET_TYPE_PER_CASE_AND_FACET(:,:)
        this%mc_table_fitted_sub_facets_status_x_case_and_facet(:,:,:)     = MC_TRI3_INOUT_FITTED_SUB_FACETS_PER_CASE_AND_FACET(:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,:) = MC_TRI3_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET(:,:,:,:)
     else if ( num_vertices == 4_ip ) then
        this%mc_table_num_sub_cells_x_case(:)                              = MC_QUA4_NUM_SUBCELLS_PER_CASE(:)
        this%mc_table_num_unfitted_sub_facets_x_case(:)                    = MC_QUA4_NUM_SUBFACES_PER_CASE(:)
        this%mc_table_num_cut_edges_x_case(:)                              = MC_QUA4_NUM_CUT_EDGES_PER_CASE(:)
        this%mc_table_sub_cells_status_x_case(:,:)                         = MC_QUA4_INOUT_SUBCELLS_PER_CASE(:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,:)                     = MC_QUA4_SUBCELL_NODE_IDS_PER_CASE(:,:,:)
        this%mc_table_unfitted_sub_facets_node_ids_x_case(:,:,:)           = MC_QUA4_SUBFACE_NODE_IDS_PER_CASE(:,:,:)
        this%mc_table_num_fitted_sub_facets_x_case_and_facet(:,:)          = MC_QUA4_NUM_SUB_FACETS_PER_CASE_AND_FACET(:,:)
        this%mc_table_facet_status_x_case_and_facet(:,:)                   = MC_QUA4_FACET_TYPE_PER_CASE_AND_FACET(:,:)
        this%mc_table_fitted_sub_facets_status_x_case_and_facet(:,:,:)     = MC_QUA4_INOUT_FITTED_SUB_FACETS_PER_CASE_AND_FACET(:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,:) = MC_QUA4_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET(:,:,:,:)
     end if
  else
     if ( num_vertices == 4_ip ) then
        this%mc_table_num_sub_cells_x_case(:)                              = MC_TET4_NUM_SUBCELLS_PER_CASE(:)
        this%mc_table_num_unfitted_sub_facets_x_case(:)                    = MC_TET4_NUM_SUBFACES_PER_CASE(:)
        this%mc_table_num_cut_edges_x_case(:)                              = MC_TET4_NUM_CUT_EDGES_PER_CASE(:)
        this%mc_table_sub_cells_status_x_case(:,:)                         = MC_TET4_INOUT_SUBCELLS_PER_CASE(:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,:)                     = MC_TET4_SUBCELL_NODE_IDS_PER_CASE(:,:,:)
        this%mc_table_unfitted_sub_facets_node_ids_x_case(:,:,:)           = MC_TET4_SUBFACE_NODE_IDS_PER_CASE(:,:,:)
        this%mc_table_num_fitted_sub_facets_x_case_and_facet(:,:)          = MC_TET4_NUM_SUB_FACETS_PER_CASE_AND_FACET(:,:)
        this%mc_table_facet_status_x_case_and_facet(:,:)                   = MC_TET4_FACET_TYPE_PER_CASE_AND_FACET(:,:)
        this%mc_table_fitted_sub_facets_status_x_case_and_facet(:,:,:)     = MC_TET4_INOUT_FITTED_SUB_FACETS_PER_CASE_AND_FACET(:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,:) = MC_TET4_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET(:,:,:,:)
     else if ( num_vertices == 8_ip ) then 
        this%mc_table_num_sub_cells_x_case(:)      = MC_HEX8_NUM_SUBCELLS_PER_CASE(:)
        this%mc_table_num_unfitted_sub_facets_x_case(:)      = MC_HEX8_NUM_SUBFACES_PER_CASE(:)
        this%mc_table_num_cut_edges_x_case(:)     = MC_HEX8_NUM_CUT_EDGES_PER_CASE(:)
        !this%mc_table_inout_subcells_x_case(:,:)    = MC_HEX8_INOUT_SUBCELLS_PER_CASE(:,:)
        !this%mc_table_subcell_node_ids_x_case(:,:,:)  = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE(:,:,:)
        !this%mc_table_subfacet_node_ids_x_case(:,:,:)  = MC_HEX8_SUBFACE_NODE_IDS_PER_CASE(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,1:9) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL1(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,10:18) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL2(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,19:27) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL3(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,28:36) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL4(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,37:45) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL5(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,46:54) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL6(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,55:63) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL7(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,64:72) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL8(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,73:81) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL9(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,82:90) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL10(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,91:99) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL11(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,100:108) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL12(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,109:117) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL13(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,118:126) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL14(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,127:135) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL15(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,136:144) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL16(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,145:153) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL17(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,154:162) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL18(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,163:171) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL19(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,172:180) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL20(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,181:189) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL21(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,190:198) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL22(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,199:207) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL23(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,208:216) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL24(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,217:225) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL25(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,226:234) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL26(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,235:243) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL27(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,244:252) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL28(:,:,:)
        this%mc_table_sub_cells_node_ids_x_case(:,:,253:256) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL29(:,:,:)
        this%mc_table_sub_cells_status_x_case(:,1:36) = MC_HEX8_INOUT_SUBCELLS_PER_CASE_BL1(:,:)
        this%mc_table_sub_cells_status_x_case(:,37:72) = MC_HEX8_INOUT_SUBCELLS_PER_CASE_BL2(:,:)
        this%mc_table_sub_cells_status_x_case(:,73:108) = MC_HEX8_INOUT_SUBCELLS_PER_CASE_BL3(:,:)
        this%mc_table_sub_cells_status_x_case(:,109:144) = MC_HEX8_INOUT_SUBCELLS_PER_CASE_BL4(:,:)
        this%mc_table_sub_cells_status_x_case(:,145:180) = MC_HEX8_INOUT_SUBCELLS_PER_CASE_BL5(:,:)
        this%mc_table_sub_cells_status_x_case(:,181:216) = MC_HEX8_INOUT_SUBCELLS_PER_CASE_BL6(:,:)
        this%mc_table_sub_cells_status_x_case(:,217:252) = MC_HEX8_INOUT_SUBCELLS_PER_CASE_BL7(:,:)
        this%mc_table_sub_cells_status_x_case(:,253:256) = MC_HEX8_INOUT_SUBCELLS_PER_CASE_BL8(:,:)
        this%mc_table_unfitted_sub_facets_node_ids_x_case(:,:,1:45) = MC_HEX8_SUBFACE_NODE_IDS_PER_CASE_BL1(:,:,:)
        this%mc_table_unfitted_sub_facets_node_ids_x_case(:,:,46:90) = MC_HEX8_SUBFACE_NODE_IDS_PER_CASE_BL2(:,:,:)
        this%mc_table_unfitted_sub_facets_node_ids_x_case(:,:,91:135) = MC_HEX8_SUBFACE_NODE_IDS_PER_CASE_BL3(:,:,:)
        this%mc_table_unfitted_sub_facets_node_ids_x_case(:,:,136:180) = MC_HEX8_SUBFACE_NODE_IDS_PER_CASE_BL4(:,:,:)
        this%mc_table_unfitted_sub_facets_node_ids_x_case(:,:,181:225) = MC_HEX8_SUBFACE_NODE_IDS_PER_CASE_BL5(:,:,:)
        this%mc_table_unfitted_sub_facets_node_ids_x_case(:,:,226:256) = MC_HEX8_SUBFACE_NODE_IDS_PER_CASE_BL6(:,:,:)
        this%mc_table_num_fitted_sub_facets_x_case_and_facet(:,1:36) = MC_HEX8_NUM_SUB_FACETS_PER_CASE_AND_FACET_BL1(:,:)
        this%mc_table_num_fitted_sub_facets_x_case_and_facet(:,37:72) = MC_HEX8_NUM_SUB_FACETS_PER_CASE_AND_FACET_BL2(:,:)
        this%mc_table_num_fitted_sub_facets_x_case_and_facet(:,73:108) = MC_HEX8_NUM_SUB_FACETS_PER_CASE_AND_FACET_BL3(:,:)
        this%mc_table_num_fitted_sub_facets_x_case_and_facet(:,109:144) = MC_HEX8_NUM_SUB_FACETS_PER_CASE_AND_FACET_BL4(:,:)
        this%mc_table_num_fitted_sub_facets_x_case_and_facet(:,145:180) = MC_HEX8_NUM_SUB_FACETS_PER_CASE_AND_FACET_BL5(:,:)
        this%mc_table_num_fitted_sub_facets_x_case_and_facet(:,181:216) = MC_HEX8_NUM_SUB_FACETS_PER_CASE_AND_FACET_BL6(:,:)
        this%mc_table_num_fitted_sub_facets_x_case_and_facet(:,217:252) = MC_HEX8_NUM_SUB_FACETS_PER_CASE_AND_FACET_BL7(:,:)
        this%mc_table_num_fitted_sub_facets_x_case_and_facet(:,253:256) = MC_HEX8_NUM_SUB_FACETS_PER_CASE_AND_FACET_BL8(:,:)
        this%mc_table_facet_status_x_case_and_facet(:,1:36) = MC_HEX8_FACET_TYPE_PER_CASE_AND_FACET_BL1(:,:)
        this%mc_table_facet_status_x_case_and_facet(:,37:72) = MC_HEX8_FACET_TYPE_PER_CASE_AND_FACET_BL2(:,:)
        this%mc_table_facet_status_x_case_and_facet(:,73:108) = MC_HEX8_FACET_TYPE_PER_CASE_AND_FACET_BL3(:,:)
        this%mc_table_facet_status_x_case_and_facet(:,109:144) = MC_HEX8_FACET_TYPE_PER_CASE_AND_FACET_BL4(:,:)
        this%mc_table_facet_status_x_case_and_facet(:,145:180) = MC_HEX8_FACET_TYPE_PER_CASE_AND_FACET_BL5(:,:)
        this%mc_table_facet_status_x_case_and_facet(:,181:216) = MC_HEX8_FACET_TYPE_PER_CASE_AND_FACET_BL6(:,:)
        this%mc_table_facet_status_x_case_and_facet(:,217:252) = MC_HEX8_FACET_TYPE_PER_CASE_AND_FACET_BL7(:,:)
        this%mc_table_facet_status_x_case_and_facet(:,253:256) = MC_HEX8_FACET_TYPE_PER_CASE_AND_FACET_BL8(:,:)
        this%mc_table_fitted_sub_facets_status_x_case_and_facet(:,:,1:45) = MC_HEX8_INOUT_FITTED_SUB_FACETS_PER_CASE_AND_FACET_BL1(:,:,:)
        this%mc_table_fitted_sub_facets_status_x_case_and_facet(:,:,46:90) = MC_HEX8_INOUT_FITTED_SUB_FACETS_PER_CASE_AND_FACET_BL2(:,:,:)
        this%mc_table_fitted_sub_facets_status_x_case_and_facet(:,:,91:135) = MC_HEX8_INOUT_FITTED_SUB_FACETS_PER_CASE_AND_FACET_BL3(:,:,:)
        this%mc_table_fitted_sub_facets_status_x_case_and_facet(:,:,136:180) = MC_HEX8_INOUT_FITTED_SUB_FACETS_PER_CASE_AND_FACET_BL4(:,:,:)
        this%mc_table_fitted_sub_facets_status_x_case_and_facet(:,:,181:225) = MC_HEX8_INOUT_FITTED_SUB_FACETS_PER_CASE_AND_FACET_BL5(:,:,:)
        this%mc_table_fitted_sub_facets_status_x_case_and_facet(:,:,226:256) = MC_HEX8_INOUT_FITTED_SUB_FACETS_PER_CASE_AND_FACET_BL6(:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,1:9) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL1(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,10:18) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL2(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,19:27) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL3(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,28:36) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL4(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,37:45) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL5(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,46:54) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL6(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,55:63) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL7(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,64:72) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL8(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,73:81) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL9(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,82:90) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL10(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,91:99) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL11(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,100:108) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL12(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,109:117) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL13(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,118:126) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL14(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,127:135) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL15(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,136:144) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL16(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,145:153) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL17(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,154:162) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL18(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,163:171) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL19(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,172:180) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL20(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,181:189) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL21(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,190:198) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL22(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,199:207) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL23(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,208:216) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL24(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,217:225) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL25(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,226:234) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL26(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,235:243) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL27(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,244:252) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL28(:,:,:,:)
        this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet(:,:,:,253:256) = MC_HEX8_FITTED_SUB_FACETS_NODE_IDS_PER_CASE_AND_FACET_BL29(:,:,:,:)
     end if
  end if

  this%mc_tables_init = .true.

end subroutine marching_cubes_mc_tables_create

!========================================================================================
subroutine marching_cubes_mc_tables_free(this)
  implicit none
  class(marching_cubes_t), intent(inout) :: this

  if (allocated (this%mc_table_num_sub_cells_x_case    )) call memfree (this%mc_table_num_sub_cells_x_case    , __FILE__, __LINE__)
  if (allocated (this%mc_table_num_unfitted_sub_facets_x_case    )) call memfree (this%mc_table_num_unfitted_sub_facets_x_case    , __FILE__, __LINE__)
  if (allocated (this%mc_table_num_cut_edges_x_case   )) call memfree (this%mc_table_num_cut_edges_x_case   , __FILE__, __LINE__)
  if (allocated (this%mc_table_sub_cells_status_x_case  )) call memfree (this%mc_table_sub_cells_status_x_case  , __FILE__, __LINE__)
  if (allocated (this%mc_table_sub_cells_node_ids_x_case)) call memfree (this%mc_table_sub_cells_node_ids_x_case, __FILE__, __LINE__)
  if (allocated (this%mc_table_unfitted_sub_facets_node_ids_x_case)) call memfree (this%mc_table_unfitted_sub_facets_node_ids_x_case, __FILE__, __LINE__)
  if (allocated (this%mc_table_num_fitted_sub_facets_x_case_and_facet)) &
    call memfree( this%mc_table_num_fitted_sub_facets_x_case_and_facet, __FILE__,__LINE__ )
  if (allocated (this%mc_table_facet_status_x_case_and_facet)) &
    call memfree (this%mc_table_facet_status_x_case_and_facet, __FILE__,__LINE__ )
  if (allocated (this%mc_table_fitted_sub_facets_status_x_case_and_facet))&
    call memfree (this%mc_table_fitted_sub_facets_status_x_case_and_facet, __FILE__,__LINE__ )
  if (allocated (this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet))&
    call memfree (this%mc_table_fitted_sub_facets_node_ids_x_case_and_facet, __FILE__,__LINE__ )

  this%mc_tables_init = .false.

end subroutine marching_cubes_mc_tables_free

!========================================================================================
subroutine marching_cubes_discrete_levelset_create(this)
  implicit none
  class(marching_cubes_t), target, intent(inout) :: this
  class(triangulation_t), pointer :: triangulation
  class(reference_fe_t),   pointer :: ref_fe_geo
  class(serial_fe_space_t),           pointer :: fe_space
  class(cell_iterator_t), allocatable :: cell
  integer(ip) :: istat

  ! Create the reference fe
  call this%create_cell_iterator(cell)
  ref_fe_geo => cell%get_reference_fe()
  allocate(this%reference_fes(1),stat=istat); check(istat==0)
  this%reference_fes(1) =  make_reference_fe ( topology = ref_fe_geo%get_topology(), &
                                               fe_type = fe_type_lagrangian, &
                                               num_dims = this%num_dims, &
                                               order = ref_fe_geo%get_max_order(), &
                                               field_type = field_type_scalar, &
                                               conformity = .true., &
                                               continuity = .true. )
  call this%free_cell_iterator(cell)

  ! Create the fe space
  triangulation => this%get_triangulation()
  select type(triangulation)
    type is(serial_unfitted_triangulation_t)

     allocate(serial_fe_space_t:: this%fe_space, stat=istat); check(istat==0)
     call this%fe_space%create(triangulation     = triangulation, &
                               reference_fes     = this%reference_fes )

    type is(unfitted_p4est_serial_triangulation_t)

      allocate(serial_fe_space_t :: this%fe_space, stat=istat); check(istat==0)
      call this%fe_space%create(triangulation     = triangulation, &
                                conditions        = this%dummy_conditions, &
                                reference_fes     = this%reference_fes )

    type is(par_unfitted_triangulation_t)

      allocate(this%dummy_coarse_handlers(1),stat=istat); check(istat==0)
      this%dummy_coarse_handlers(1)%p => this%dummy_coarse_handler

      allocate(par_fe_space_t:: this%fe_space, stat=istat); check(istat==0)
      fe_space => this%fe_space
      select type (fe_space)
      class is (par_fe_space_t)
        call fe_space%create(triangulation      = triangulation, &
                             conditions         = this%dummy_conditions, &
                             reference_fes      = this%reference_fes , &
                             coarse_fe_handlers = this%dummy_coarse_handlers)
    class default
      check(.false.)
  end select

  class default
    mcheck(.false.,'Wrong triangulation type')
  end select

  ! Create the discrete levelset function
  call this%fe_levelset%create(this%fe_space)
  call this%fe_space%interpolate(1,this%level_set_function,this%fe_levelset)

  ! Apply the tolerance
  call this%discrete_levelset_fix()
  fe_space => this%fe_space
  select type (fe_space)
  class is (par_fe_space_t)
    call this%discrete_levelset_comm(fe_space)
  end select
  call fe_space%update_hanging_dof_values(this%fe_levelset)

end subroutine marching_cubes_discrete_levelset_create

!========================================================================================
subroutine marching_cubes_discrete_levelset_free(this)
  implicit none
  class(marching_cubes_t), intent(inout) :: this
  integer(ip) :: istat, i
  call this%fe_levelset%free()
  if (allocated(this%fe_space)) then
    call this%fe_space%free()
    deallocate(this%fe_space, stat=istat);check(istat==0)
  end if
  if ( allocated(this%reference_fes) ) then
    do i=1, size(this%reference_fes)
      call this%reference_fes(i)%free()
    end do
    deallocate(this%reference_fes, stat=istat); check(istat==0)
  end if
  if (allocated(this%dummy_coarse_handlers)) then
    deallocate(this%dummy_coarse_handlers,stat=istat); check(istat==0)
  end if
  call this%block_layout%free()
end subroutine marching_cubes_discrete_levelset_free

!========================================================================================
subroutine marching_cubes_discrete_levelset_fix(this)
  implicit none
  class(marching_cubes_t), intent(inout) :: this

  class(fe_cell_iterator_t),   allocatable  :: fe
  class(cell_iterator_t), allocatable  :: cell
  class(reference_fe_t), pointer :: reference_fe_geo
  type(point_t), allocatable :: Xe_ref(:)
  real(rp), allocatable :: nodal_vals(:)
  integer(ip), parameter :: edge_dim = 1
  integer(ip) :: num_nodes
  integer(ip) :: iedge, first_edge, last_edge, cell_node, edge_node
  type(list_iterator_t) :: nodes_in_edge_iterator
  integer(ip) :: istat
  integer(ip), parameter :: num_nodes_in_edge = 2
  integer(ip) :: nodes_in_edge(num_nodes_in_edge)
  real(rp)    :: phi_edge(num_nodes_in_edge)
  integer(ip) :: field_id
  type(point_t) :: X_intersection
  real(rp), parameter :: edge_length = 2
  type(vector_field_t) :: DX
  real(rp) :: tol
  type(quadrature_t), pointer :: nodal_quadrature


  ! Recover the tolerance from the levelset
  tol = this%level_set_function%get_tolerance()

  ! The level set function only has one field (for the moment)
  field_id = 1

  ! Get the nodal coordinates in the reference element
  call this%fe_space%create_fe_cell_iterator(fe)
  call this%create_cell_iterator(cell)
  reference_fe_geo => fe%get_reference_fe_geo()
  num_nodes = cell%get_num_nodes()
  allocate( Xe_ref(1:num_nodes), stat=istat ); check(istat == 0)
  nodal_quadrature => reference_fe_geo%get_nodal_quadrature()
  call nodal_quadrature%get_coordinates_as_points( Xe_ref )
  call this%free_cell_iterator(cell)

  ! Check that the length of the edge is ok
  !DX = Xe_ref(1) - Xe_ref(2)
  !if (this%num_dims<3) call DX%set(3,0.0_rp)
  !massert(abs(DX%nrm2() - edge_length)<1.0e-13,'The lenght of the edge is not 2.0!')

  call memalloc(num_nodes,nodal_vals,__FILE__,__LINE__)

  ! Allocate and fill the intersection points
  call fe%first()
  do while ( .not. fe%has_finished() )
    if (fe%is_local()) then

      ! Evaluate the levelset
      call this%fe_levelset%gather_nodal_values(fe,field_id,nodal_vals)

      ! Prepare Loop in cell edges
      reference_fe_geo => fe%get_reference_fe_geo()
      first_edge = reference_fe_geo%get_first_n_face_id_of_dim(edge_dim)
      last_edge  = first_edge + reference_fe_geo%get_num_n_faces_of_dim(edge_dim) - 1

      ! Loop in cell edges
      do iedge = first_edge, last_edge

        ! Loop in edge nodes
        nodes_in_edge_iterator = reference_fe_geo%create_dofs_n_face_iterator(iedge)
        do while (.not. nodes_in_edge_iterator%is_upper_bound())
          edge_node = nodes_in_edge_iterator%get_distance_to_lower_bound()
          cell_node = nodes_in_edge_iterator%get_current()

          ! Store the levelset and nodes ids of the current edge
          phi_edge(edge_node) = nodal_vals(cell_node)
          nodes_in_edge(edge_node) = cell_node

          call nodes_in_edge_iterator%next()
        end do

        ! Check if intersection point exists
        if ( (phi_edge(1) >= 0 .and. phi_edge(2) < 0) .or. (phi_edge(2) >= 0 .and. phi_edge(1) < 0)   ) then

          ! Compute the intersection points of the edge
          X_intersection = Xe_ref(nodes_in_edge(1)) + &
          (abs(phi_edge(1))/(abs(phi_edge(1))+abs(phi_edge(2))))*( Xe_ref(nodes_in_edge(2)) - Xe_ref(nodes_in_edge(1)) )

          ! Compute the distance from the intersection point to each of the nodes endpoints
          ! If one of the distances is smaller that the edge size times the tol, 
          ! fix the levelset on the corresponding node

          DX = Xe_ref(nodes_in_edge(1)) - X_intersection
          if (this%num_dims<3) call DX%set(3,0.0_rp)
          if (DX%nrm2() < tol*edge_length) nodal_vals(nodes_in_edge(1)) = 0.0_rp

          DX = Xe_ref(nodes_in_edge(2)) - X_intersection
          if (this%num_dims<3) call DX%set(3,0.0_rp)
          if (DX%nrm2() < tol*edge_length) nodal_vals(nodes_in_edge(2)) = 0.0_rp

        end if

      end do

      ! Fix the levelset
      call this%fe_levelset%insert_nodal_values(fe,field_id,nodal_vals)

    end if
    call fe%next()
  end do

  deallocate( Xe_ref, stat=istat );  check(istat == 0)
  call memfree(nodal_vals,__FILE__,__LINE__)
  call this%fe_space%free_fe_cell_iterator(fe)

end subroutine marching_cubes_discrete_levelset_fix

!========================================================================================
subroutine marching_cubes_discrete_levelset_comm(this,par_fe_space)
  implicit none
  class(marching_cubes_t), intent(inout) :: this
  class(par_fe_space_t),   intent(in)    :: par_fe_space

  type(par_scalar_array_t)             :: par_array
  type(environment_t), pointer         :: p_env
  type(dof_import_t),  pointer         :: dof_import
  type(serial_scalar_array_t), pointer :: serial_array
  real(rp), pointer                    :: touched(:)
  class(vector_t), pointer             :: dof_values
  real(rp), pointer                    :: raw_dof_values(:)
  integer(ip)                          :: i
  integer(ip)                          :: field_id, block_id
  integer(ip), pointer                 :: field_to_block(:)

  !1) Build an array containing 1 in the entries corresponding to dofs
  ! where the discrete levelset is exactly 0 and 0 otherwise

  !2) Communicate this array

  !3) Set to 0 the dofs of the discrete levelset that are 0 at least in one subdomain

  field_id = 1
  assert(par_fe_space%get_num_fields() == 1)
  field_to_block => par_fe_space%get_field_blocks()
  block_id = field_to_block(field_id)
  p_env => par_fe_space%get_environment()
  dof_import => par_fe_space%get_block_dof_import(block_id)
  call par_array%create_and_allocate(p_env, dof_import)
  serial_array   => par_array%get_serial_scalar_array()
  touched => serial_array%get_entries()

  dof_values => this%fe_levelset%get_free_dof_values()
  select type(dof_values)
  class is (par_scalar_array_t)

    serial_array => dof_values%get_serial_scalar_array()
    raw_dof_values => serial_array%get_entries()
    assert( size(touched) == size(raw_dof_values))

    ! Mark the dofs of the levelset that are 0.0
    touched(:) = 0.0_rp
    do i=1,size(touched)
      if (raw_dof_values(i)==0.0_rp) touched(i) = 1.0_rp
    end do

    ! Communicate the mark
    call par_array%comm()

    ! Set to 0.0 the dofs of the levelset that are marked in at least another subdomain
    do i=1,size(touched)
      if (touched(i)>=1.0_rp) raw_dof_values(i) = 0.0_rp
    end do

  class default
    mcheck(.false.,'Error in downcasting vector_t to par_scalar_array_t')
  end select

  call par_array%free()

end subroutine marching_cubes_discrete_levelset_comm

!========================================================================================
subroutine marching_cubes_mc_runtime_info_create(this)
  implicit none
  class(marching_cubes_t), intent(inout) :: this

  class(fe_cell_iterator_t), allocatable  :: fe
  class(cell_iterator_t), allocatable  :: cell
  class(reference_fe_t), pointer :: reference_fe_geo
  type(point_t), allocatable :: Xe_ref(:)
  real(rp), allocatable :: nodal_vals(:)
  integer(ip), parameter :: edge_dim = 1
  integer(ip) :: inode, num_nodes
  integer(ip) :: iedge, first_edge, last_edge, cell_node, edge_node
  type(list_iterator_t) :: nodes_in_edge_iterator
  integer(ip) :: num_cells, ipoin, num_int_points
  integer(ip) :: icase, istat, num_nodes_outside
  integer(ip), parameter :: num_nodes_in_edge = 2
  integer(ip) :: nodes_in_edge(num_nodes_in_edge)
  real(rp)    :: phi_node, phi_edge(num_nodes_in_edge)
  integer(ip) :: field_id
  type(quadrature_t), pointer :: nodal_quadrature
  class(triangulation_t), pointer :: triangulation
  
  triangulation => this%get_triangulation()

  ! To be safe
  call this%mc_runtime_info_free()

  ! The level set function only has one field (for the moment)
  field_id = 1

  ! Get the nodal coordinates in the reference element
  call this%fe_space%create_fe_cell_iterator(fe)
  call this%create_cell_iterator(cell)
  reference_fe_geo => fe%get_reference_fe_geo()
  num_nodes = cell%get_num_nodes()
  allocate( Xe_ref(1:num_nodes), stat=istat ); check(istat == 0)
  nodal_quadrature => reference_fe_geo%get_nodal_quadrature()
  call nodal_quadrature%get_coordinates_as_points( Xe_ref )
  call this%free_cell_iterator(cell)

  ! Allocate and fill marching cube cases
  num_cells = triangulation%get_num_local_cells()
  call memalloc (num_cells, this%mc_case_x_cell, __FILE__, __LINE__ )
  call memalloc(num_nodes,nodal_vals,__FILE__,__LINE__)
  do while ( .not. fe%has_finished() )
    if (fe%is_local()) then
      call this%fe_levelset%gather_nodal_values(fe,field_id,nodal_vals)
      icase = 0_ip
      num_nodes_outside = 0_ip
      do inode = 1, num_nodes
        phi_node = nodal_vals(inode)
        if (phi_node < 0.0_rp) icase = ior( icase, 2_ip**(inode-1_ip) )
        if (phi_node > 0.0_rp) num_nodes_outside = num_nodes_outside + 1
      end do
      if ( num_nodes_outside == 0_ip ) then
        ! This is to avoid to set as cut an element that has negative and zero nodes 
        ! (which is in fact a full interior element)
        this%mc_case_x_cell( fe%get_gid() ) = this%mc_table_num_cases
      else
        this%mc_case_x_cell( fe%get_gid() ) = icase + 1
      end if
    end if
    call fe%next()
  end do

  ! Allocate and fill the intersection points pointers
  call memalloc (num_cells+1, this%mc_ptr_to_intersections, __FILE__, __LINE__ )
  this%mc_ptr_to_intersections(1) = 1
  call fe%first()
  do while ( .not. fe%has_finished() )
      if (fe%is_local()) then
      this%mc_ptr_to_intersections(fe%get_gid() + 1) = this%mc_ptr_to_intersections(fe%get_gid()) &
      + this%mc_table_num_cut_edges_x_case(this%mc_case_x_cell(fe%get_gid()))
    end if
    call fe%next()
  end do

  ! Allocate and fill the intersection points
  num_int_points = this%mc_ptr_to_intersections(num_cells + 1) - this%mc_ptr_to_intersections(1)
  allocate ( this%mc_intersection_points( num_int_points ), stat = istat )
  check(istat == 0)
  call fe%first()
  ipoin = 1
  do while ( .not. fe%has_finished() )
    if (fe%is_local()) then

      ! Only execute this loop for cut elements
      if ( this%mc_case_x_cell(fe%get_gid())==1 .or. this%mc_case_x_cell(fe%get_gid())==this%mc_table_num_cases ) then
        call fe%next()
        cycle
      end if

      ! Evaluate the levelset
      call this%fe_levelset%gather_nodal_values(fe,field_id,nodal_vals)

      ! Prepare Loop in cell edges
      reference_fe_geo => fe%get_reference_fe_geo()
      first_edge = reference_fe_geo%get_first_n_face_id_of_dim(edge_dim)
      last_edge  = first_edge + reference_fe_geo%get_num_n_faces_of_dim(edge_dim) - 1

      ! Loop in cell edges
      do iedge = first_edge, last_edge

        ! Loop in edge nodes
        nodes_in_edge_iterator = reference_fe_geo%create_dofs_n_face_iterator(iedge)
        do while (.not. nodes_in_edge_iterator%is_upper_bound())
          edge_node = nodes_in_edge_iterator%get_distance_to_lower_bound()
          cell_node = nodes_in_edge_iterator%get_current()

          ! Store the levelset and nodes ids of the current edge
          phi_edge(edge_node) = nodal_vals(cell_node)
          nodes_in_edge(edge_node) = cell_node

          call nodes_in_edge_iterator%next()
        end do

        ! Compute the intersection points of the edge
        if ( (phi_edge(1) >= 0 .and. phi_edge(2) < 0) .or. (phi_edge(2) >= 0 .and. phi_edge(1) < 0)   ) then
          this%mc_intersection_points(ipoin) = Xe_ref(nodes_in_edge(1)) + &
          (abs(phi_edge(1))/(abs(phi_edge(1))+abs(phi_edge(2))))*( Xe_ref(nodes_in_edge(2)) - Xe_ref(nodes_in_edge(1)) )
          ipoin = ipoin + 1
        end if

      end do

    end if
    call fe%next()
  end do

  deallocate( Xe_ref, stat=istat );  check(istat == 0)
  call memfree(nodal_vals,__FILE__,__LINE__)
  call this%fe_space%free_fe_cell_iterator(fe)
  this%mc_runtime_init = .true.

end subroutine marching_cubes_mc_runtime_info_create

!========================================================================================
subroutine marching_cubes_mc_runtime_info_free(this)
  implicit none
  class(marching_cubes_t), intent(inout) :: this
  integer(ip) :: istat, i
  if (allocated (this%mc_case_x_cell       )) call memfree ( this%mc_case_x_cell        , __FILE__, __LINE__ )
  if (allocated (this%mc_ptr_to_intersections)) call memfree ( this%mc_ptr_to_intersections , __FILE__, __LINE__ )
  if (allocated (this%mc_intersection_points)) then
    deallocate(this%mc_intersection_points, stat=istat); check(istat==0)
  end if
  this%mc_runtime_init = .false.
end subroutine marching_cubes_mc_runtime_info_free

!========================================================================================
subroutine marching_cubes_subnodes_data_create( this )

  implicit none
  class(marching_cubes_t), intent(inout) :: this

  integer(ip) :: istat, icase
  class(cell_iterator_t), allocatable  :: cell
  class(reference_fe_t), pointer :: reference_fe_geo
  integer(ip) :: n_subfacets, n_subnodes,  n_nodes_subfacet

  assert(this%mc_tables_init)
  assert(this%mc_runtime_init)

  call this%subnodes_data_free()
  
  ! TODO we don't really need to allocate for all the mc cases
  allocate( this%sub_nodes_nodal_quadratures(1:this%get_num_mc_cases()), stat=istat); check(istat==0_ip)
  allocate( this%sub_nodes_cell_maps          (1:this%get_num_mc_cases()), stat=istat); check(istat==0_ip)

  ! Initialize each one of the quadratures
  call this%create_cell_iterator(cell)
  do icase=1, this%get_num_mc_cases()
    n_subnodes =  this%mc_table_num_cut_edges_x_case(icase) + cell%get_num_nodes()
    call this%sub_nodes_nodal_quadratures(icase)%create(this%num_dims,n_subnodes)
  end do

  ! Initialize each one of the cell_maps
  reference_fe_geo => cell%get_reference_fe()
  do icase=1, this%get_num_mc_cases()
    call this%sub_nodes_cell_maps(icase)%create( this%sub_nodes_nodal_quadratures(icase), reference_fe_geo)
  end do

  !Allocate place holders for the sub-mesh
  n_subfacets     = this%mc_table_max_num_unfitted_sub_facets
  n_subnodes      = this%get_max_num_subnodes_in_cell()
  n_nodes_subfacet = this%get_max_num_nodes_in_subfacet()
  call this%allocate_nsubcells_arrays()
  call memalloc(n_subnodes,this%level_set_all_nodes,__FILE__,__LINE__)
  call memalloc(n_nodes_subfacet,n_subfacets,this%unfitted_sub_facets_node_ids,__FILE__,__LINE__)
  call memalloc(n_nodes_subfacet,this%mc_table_max_num_fitted_sub_facets_in_facet,this%mc_table_num_facets,this%fitted_sub_facets_node_ids_x_facet,__FILE__,__LINE__)
  allocate( this%subnodes_ref_coords(1:n_subnodes) , stat=istat); check(istat==0_ip)
  call this%fe_space%create_fe_cell_iterator(this%fe)

  call this%free_cell_iterator(cell)
  this%mc_cell_info_init = .true.
end subroutine marching_cubes_subnodes_data_create


!========================================================================================
subroutine marching_cubes_allocate_nsubcells_arrays( this )
  implicit none
  class(marching_cubes_t), intent(inout) :: this
  integer(ip)                            :: n_subcells
  integer(ip)                            :: n_nodes_subcell
  integer(ip),                parameter  :: num_facets_tet = 4
  n_subcells      = this%mc_table_max_num_sub_cells
  n_nodes_subcell = this%get_max_num_nodes_in_subcell()
  call memalloc(n_nodes_subcell,n_subcells,this%sub_cells_node_ids,__FILE__,__LINE__)
  call memalloc(n_subcells,this%subcells_status,__FILE__,__LINE__)
  if (this%num_dims==3) then
    call memalloc(num_facets_tet,n_subcells,this%subcell_facet_neigs,__FILE__,__LINE__)
  end if
  call memalloc(n_subcells,this%sub_cell_has_been_reoriented,__FILE__,__LINE__)
end subroutine marching_cubes_allocate_nsubcells_arrays


!========================================================================================
subroutine marching_cubes_reallocate_nsubcells_arrays( this )
  implicit none
  class(marching_cubes_t), intent(inout) :: this
  integer(ip)                            :: n_subcells
  integer(ip)                            :: n_nodes_subcell
  integer(ip),                parameter  :: num_facets_tet = 4  
   
  n_subcells      = this%num_subcells 
  n_nodes_subcell = this%get_max_num_nodes_in_subcell()
  call memrealloc_if_more_space_needed(n_nodes_subcell,&
                                       n_subcells,this%sub_cells_node_ids,&
                                       __FILE__,__LINE__)
  call memrealloc_if_more_space_needed(n_subcells,&
                                       this%subcells_status,& 
                                       __FILE__,__LINE__)
  if (this%num_dims==3) then
    call memrealloc_if_more_space_needed(num_facets_tet,&
                                         n_subcells,&
                                         this%subcell_facet_neigs,__FILE__,__LINE__)
  end if
  call memrealloc_if_more_space_needed(n_subcells,&
                                       this%sub_cell_has_been_reoriented,&
                                       __FILE__,__LINE__)
end subroutine marching_cubes_reallocate_nsubcells_arrays

!========================================================================================
subroutine marching_cubes_subnodes_data_free( this )

  implicit none
  class(marching_cubes_t), intent(inout) :: this
  integer(ip) :: istat, i

  if ( allocated(this%subnodes_ref_coords) ) then
    deallocate( this%subnodes_ref_coords, stat=istat ); check( istat==0_ip )
  end if

  if ( allocated(this%sub_nodes_nodal_quadratures) ) then
    do i=1,size(this%sub_nodes_nodal_quadratures)
      call this%sub_nodes_nodal_quadratures(i)%free()
    end do
    deallocate( this%sub_nodes_nodal_quadratures, stat=istat ); check( istat==0_ip )
  end if

  if ( allocated(this%sub_nodes_cell_maps) ) then
    do i=1,size(this%sub_nodes_cell_maps)
      call this%sub_nodes_cell_maps(i)%free()
    end do
    deallocate( this%sub_nodes_cell_maps, stat=istat ); check( istat==0_ip )
  end if

  if(allocated(this%sub_cells_node_ids  )) call memfree(this%sub_cells_node_ids  ,__FILE__,__LINE__)
  if(allocated(this%level_set_all_nodes  )) call memfree(this%level_set_all_nodes  ,__FILE__,__LINE__)
  if(allocated(this%subcells_status  )) call memfree(this%subcells_status  ,__FILE__,__LINE__)
  if(allocated(this%subcell_facet_neigs  )) call memfree(this%subcell_facet_neigs  ,__FILE__,__LINE__)
  if(allocated(this%unfitted_sub_facets_node_ids  )) call memfree(this%unfitted_sub_facets_node_ids  ,__FILE__,__LINE__)
  if(allocated(this%fitted_sub_facets_node_ids_x_facet  )) call memfree(this%fitted_sub_facets_node_ids_x_facet  ,__FILE__,__LINE__)
  if(allocated(this%sub_cell_has_been_reoriented)) call memfree(this%sub_cell_has_been_reoriented,__FILE__,__LINE__)
  if(allocated(this%fe_space)) call this%fe_space%free_fe_cell_iterator(this%fe)
end subroutine marching_cubes_subnodes_data_free


