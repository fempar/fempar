! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!========================================================================================
subroutine uim_create(this,fe_space,marching_cubes)
  implicit none
  class(unfitted_integration_manager_t),intent(inout) :: this
  class(serial_fe_space_t), target, intent(in)    :: fe_space
  class(marching_cubes_t), target,  intent(in)    :: marching_cubes
  class(triangulation_t), pointer :: triangulation
  type(environment_t), pointer :: environment
  call this%free()
  this%fe_space => fe_space
  this%marching_cubes => marching_cubes
  triangulation => fe_space%get_triangulation()
  environment => triangulation%get_environment()
  if ( environment%am_i_l1_task() ) then
#ifdef DEBUG
    call this%check_assumptions()
#endif
    call this%init_reference_subelem()
    call this%init_cut_integration()
    call this%init_cut_boundary_integration()
    call this%init_cut_fitted_facets_integration()
  end if
end subroutine uim_create

!========================================================================================
subroutine uim_free( this )
  implicit none
  class(unfitted_integration_manager_t), intent(inout) :: this
  call this%free_reference_subelem()
  call this%free_cut_integration()
  call this%free_cut_boundary_integration()
  call this%free_cut_fitted_facets_integration()
  this%fe_space => null()
  this%marching_cubes => null()
end subroutine uim_free

!========================================================================================
subroutine uim_check_assumptions(this)
  implicit none
  class(unfitted_integration_manager_t), intent(inout) :: this

  class(fe_cell_iterator_t), allocatable :: fe
  integer(ip) :: num_fields, ifield
  class(reference_fe_t), pointer :: ref_fe
  class(reference_fe_t), pointer :: ref_fe_1
  class(reference_fe_t), pointer :: geo_ref_fe
  class(reference_fe_t), pointer :: geo_ref_fe_1

  ! Hypothesis:
  ! Same geom ref element in all cells
  ! Same ref elem in all cells, but possibly different among fields

  call this%fe_space%create_fe_cell_iterator(fe)
  num_fields = this%fe_space%get_num_fields()

  ! Check geom ref element
  ! TODO how to check the fe_type? EDIT: I think it is not necessary
  call fe%first()
  geo_ref_fe_1 => fe%get_reference_fe_geo()
  do while (.not. fe%has_finished())
    if (fe%is_local()) then
      geo_ref_fe => fe%get_reference_fe_geo()
      assert( geo_ref_fe_1%get_topology()          ==    geo_ref_fe%get_topology()          )
      assert( geo_ref_fe_1%get_num_dims() ==    geo_ref_fe%get_num_dims() )
      assert( geo_ref_fe_1%get_order()             ==    geo_ref_fe%get_order()             )
      assert( geo_ref_fe_1%get_field_type()        ==    geo_ref_fe%get_field_type()        )
      assert( geo_ref_fe_1%get_continuity()        .eqv. geo_ref_fe%get_continuity()        )
      assert( geo_ref_fe_1%get_conformity()        .eqv. geo_ref_fe%get_conformity()        )
    end if
    call fe%next()
  end do

  do ifield = 1, num_fields

    ! Find first non-empty fe in this field
    call fe%first_local_non_void(ifield)
    ref_fe_1 => fe%get_reference_fe(ifield)
    
    ! Check ref elems
    call fe%first()
    do while (.not. fe%has_finished())
      if (fe%is_local() .and. (.not. fe%is_void(ifield) )) then
        ref_fe     => fe%get_reference_fe(ifield)
        assert( ref_fe_1%get_topology()          ==    ref_fe%get_topology()         )
        assert( ref_fe_1%get_num_dims() ==    ref_fe%get_num_dims())
        assert( ref_fe_1%get_order()             ==    ref_fe%get_order()            )
        assert( ref_fe_1%get_field_type()        ==    ref_fe%get_field_type()       )
        assert( ref_fe_1%get_continuity()        .eqv. ref_fe%get_continuity()       )
        assert( ref_fe_1%get_conformity()        .eqv. ref_fe%get_conformity()       )
      end if
      call fe%next()
    end do

  end do

  call this%fe_space%free_fe_cell_iterator(fe)

end subroutine uim_check_assumptions

!========================================================================================
subroutine uim_init_reference_subelem( this )
  implicit none
  class(unfitted_integration_manager_t), intent(inout) :: this
  
  integer(ip) :: num_dim
  integer(ip) :: p
  
  call this%free_reference_subelem()
  
  num_dim = this%marching_cubes%get_num_dims()

  ! Create the reference sub-element
  ! TODO a better way to create a reference element?
  ! TODO we assume that the sub-element is always either a triangle or a tetrahedron
  ! TODO We assume also order 1 in the geometrical representation of the unfitted boundary
  call this%geo_reference_subelem%create( topology = topology_tet,&
                                      num_dims = num_dim,&
                                      order = 1,&
                                      field_type = field_type_scalar,&
                                      conformity = .true., &
                                      continuity = .false. )
  
  call this%geo_reference_subfacet%create( topology = topology_tet,&
                                      num_dims = num_dim-1,&
                                      order = 1,&
                                      field_type = field_type_scalar,&
                                      conformity = .true., &
                                      continuity = .false. )
  
  ! Find the max degree
  p = this%fe_space%get_max_order()
  
  ! Create the quadrature for the sub-element
  ! degree 2*(d*p-1) needed for integrate stifness matrix
  ! If you need to integrate the mass matrix this would be 2*d*p
  call this%geo_reference_subelem%create_quadrature(this%quadrature_subelem,degree=2*(num_dim*p-1))
  
  ! Create the quadrature for the sub-face
  ! degree 2*(d*p-1) needed for integrate (n*grad(u))*(n*grad(u))
  ! 2*d*p Needed for the penalty terms 
  call this%geo_reference_subelem%create_facet_quadrature(this%quadrature_subfacet,degree=2*num_dim*p)
  
  ! Create the fe maps
  call this%cell_map_subelem%create( this%quadrature_subelem, this%geo_reference_subelem )
  call this%cell_map_subfacet%create( this%quadrature_subfacet, this%geo_reference_subfacet )

end subroutine uim_init_reference_subelem

!========================================================================================
subroutine uim_free_reference_subelem( this )
  implicit none
  class(unfitted_integration_manager_t), intent(inout) :: this
  call this%cell_map_subfacet%free()
  call this%cell_map_subelem%free()
  call this%geo_reference_subfacet%free()
  call this%geo_reference_subelem%free()
  call this%quadrature_subelem%free()
  call this%quadrature_subfacet%free()
end subroutine uim_free_reference_subelem

!========================================================================================
subroutine uim_init_cut_integration( this )
  implicit none
  class(unfitted_integration_manager_t), intent(inout) :: this

  integer(ip) :: num_dim, num_gp, num_gp_subelem, num_subelems, num_fields
  integer(ip) :: mc_case, mc_num_cases, istat, ifield

  class(fe_cell_iterator_t), allocatable :: fe
  class(reference_fe_t),     pointer        :: reference_elem
  class(reference_fe_t), pointer :: geo_reference_elem

  call this%free_cut_integration()
  num_dim = this%marching_cubes%get_num_dims()
  num_gp_subelem = this%quadrature_subelem%get_num_quadrature_points()
  mc_num_cases = this%marching_cubes%get_num_mc_cases()

  allocate( this%cut_quadratures(1:mc_num_cases), stat=istat ); check(istat==0_ip)
  do mc_case = 1, mc_num_cases
    num_gp = num_gp_subelem*this%marching_cubes%get_num_subcells_mc_case(mc_case)
    call this%cut_quadratures(mc_case)%create( num_dim, num_gp )
  end do

  ! We assume that the same geom ref element is in all the mesh
  ! We assume that the same ref element is in all the mesh (but can be different amnong fields)
  call this%fe_space%create_fe_cell_iterator(fe)
  geo_reference_elem => fe%get_reference_fe_geo() !This is safe since the geo_reference_elem is always non void

  ! TODO @fverdugo DRIVER PRIORITY HIGH EFFORT MEDIUM
  ! Now we allocate in function of the number of mc cases. 
  ! But this can be heavitly improved, since many mc cases have the same number of subcells
  ! TODO we whant to make it independent of the method used for sub-dividing the cells
  allocate( this%cut_cell_maps(1:mc_num_cases), stat=istat ); check(istat==0_ip)
  do mc_case = 1, mc_num_cases
    call this%cut_cell_maps(mc_case)%create( this%cut_quadratures(mc_case), geo_reference_elem )
  end do

  ! cell integrators
  num_fields = this%fe_space%get_num_fields()
  allocate( this%cut_cell_integrators(1:mc_num_cases,1:num_fields), stat=istat ); check(istat==0_ip)
  do ifield = 1,num_fields

    ! Find the fist non void ref FE in the field
    call fe%first_local_non_void(ifield)
    if (fe%has_finished()) call fe%first()
    reference_elem => fe%get_reference_fe(field_id=ifield)

    do mc_case = 1, mc_num_cases
      call this%cut_cell_integrators(mc_case,ifield)%create( this%cut_quadratures(mc_case), reference_elem )
    end do

  end do

  ! Create empty dummy objects
  call this%empty_quadrature%create(num_dim,0)
  call this%empty_cell_map%create( this%empty_quadrature, geo_reference_elem )
  allocate (this%empty_cell_integrator(1:num_fields), stat=istat); check(istat==0)
  do ifield = 1,num_fields

    ! Find the fist non void ref FE in the field
    call fe%first_local_non_void(ifield)
    if (fe%has_finished()) call fe%first()
    reference_elem => fe%get_reference_fe(field_id=ifield)
    call this%empty_cell_integrator(ifield)%create( this%empty_quadrature, reference_elem )
  end do

  call this%fe_space%free_fe_cell_iterator(fe)

end subroutine uim_init_cut_integration

!========================================================================================
subroutine uim_free_cut_integration( this )

  implicit none
  class(unfitted_integration_manager_t), intent(inout) :: this

  integer(ip) :: ind, istat, jnd

  if ( allocated(this%cut_quadratures) ) then
    do ind = 1,size(this%cut_quadratures)
      call this%cut_quadratures(ind)%free()
    end do
    deallocate( this%cut_quadratures, stat=istat ); check(istat==0_ip)
  end if

  if ( allocated(this%cut_cell_maps) ) then
    do ind = 1,size(this%cut_cell_maps)
      call this%cut_cell_maps(ind)%free()
    end do
    deallocate( this%cut_cell_maps, stat=istat ); check(istat==0_ip)
  end if

  if ( allocated(this%cut_cell_integrators) ) then
    do ind = 1,size(this%cut_cell_integrators,1)
      do jnd = 1,size(this%cut_cell_integrators,2)
        call this%cut_cell_integrators(ind,jnd)%free()
      end do
    end do
    deallocate( this%cut_cell_integrators, stat=istat ); check(istat==0_ip)
  end if

  call this%empty_quadrature%free()
  call this%empty_cell_map%free()

  if ( allocated(this%empty_cell_integrator) ) then
    do ind = 1,size(this%empty_cell_integrator)
      call this%empty_cell_integrator(ind)%free()
    end do
    deallocate( this%empty_cell_integrator, stat=istat ); check(istat==0_ip)
  end if

end subroutine uim_free_cut_integration

!========================================================================================
subroutine uim_init_cut_boundary_integration( this )

  implicit none
  class(unfitted_integration_manager_t), intent(inout) :: this

  class(fe_cell_iterator_t), allocatable :: fe
  class(reference_fe_t),     pointer        :: reference_elem
  class(reference_fe_t), pointer :: geo_reference_elem

  integer(ip) :: mc_case, mc_num_cases, istat, pini, pend, subfacet, ifield
  integer(ip) :: num_dim, num_gp, num_subfacets, num_fields

  real(rp), pointer :: quad_coords(:,:), sub_quad_coords(:,:)
  real(rp), pointer :: quad_weight(:), sub_quad_weight(:)

  call this%free_cut_boundary_integration()

  num_gp = this%quadrature_subfacet%get_num_quadrature_points()
  num_dim = this%marching_cubes%get_num_dims()
  mc_num_cases = this%marching_cubes%get_num_mc_cases()
  num_fields = this%fe_space%get_num_fields()

  !TODO not needed to allocate for all the mc cases
  allocate( this%cut_boundary_quadratures_cell_dim    (1:mc_num_cases), stat = istat ); check(istat==0)
  allocate( this%cut_boundary_piecewise_cell_maps       (1:mc_num_cases), stat = istat ); check(istat==0)
  allocate( this%cut_boundary_cell_maps                 (1:mc_num_cases), stat = istat ); check(istat==0)
  allocate( this%cut_boundary_cell_integrators        (1:mc_num_cases,1:num_fields), stat = istat ); check(istat==0)

  do mc_case = 1, mc_num_cases
    num_subfacets = this%marching_cubes%get_num_subfacets_mc_case(mc_case)
    call this%cut_boundary_quadratures_cell_dim(mc_case)%create(num_dim,     num_gp*num_subfacets)
  end do

  ! Fill the quadratures with the values of the reference subfacet
  do mc_case = 1, mc_num_cases
    num_subfacets = this%marching_cubes%get_num_subfacets_mc_case(mc_case)
    sub_quad_coords => this%quadrature_subfacet%get_coordinates()
    sub_quad_weight => this%quadrature_subfacet%get_weights()
    quad_coords     => this%cut_boundary_quadratures_cell_dim(mc_case)%get_coordinates()
    quad_weight     => this%cut_boundary_quadratures_cell_dim(mc_case)%get_weights()
    do subfacet = 1, num_subfacets
      pend = subfacet*num_gp
      pini = pend -  num_gp + 1
      quad_coords(:,pini:pend) = sub_quad_coords(:,:)
      quad_weight(pini:pend) = sub_quad_weight(:)
    end do
  end do

  !We assume that the same ref element is in all the mesh (discarding void FEs), but possibly different in all fields
  call this%fe_space%create_fe_cell_iterator(fe)
  geo_reference_elem => fe%get_reference_fe_geo() ! This is safe since the geo_reference_fe is always non-void

  do mc_case = 1, mc_num_cases
    num_subfacets = this%marching_cubes%get_num_subfacets_mc_case(mc_case)
    call this%cut_boundary_piecewise_cell_maps(mc_case)%create_facet_map(&
         this%quadrature_subfacet, this%geo_reference_subelem, num_subfacets  )
  end do

  do mc_case = 1, mc_num_cases
    num_subfacets = this%marching_cubes%get_num_subfacets_mc_case(mc_case)
    call this%cut_boundary_cell_maps(mc_case)%create(&
         this%cut_boundary_quadratures_cell_dim(mc_case), geo_reference_elem)
  end do

  do ifield = 1, num_fields

    ! Find the fist non void ref FE in the field
    call fe%first_local_non_void(ifield)
    if (fe%has_finished()) call fe%first()
    reference_elem => fe%get_reference_fe(field_id=ifield)

    do mc_case = 1, mc_num_cases
    call this%cut_boundary_cell_integrators(mc_case,ifield)%create(&
           this%cut_boundary_quadratures_cell_dim(mc_case), reference_elem )
    end do

  end do

  call this%empty_piecewise_cell_map%create_facet_map( this%empty_quadrature, geo_reference_elem, 0 )

  call this%fe_space%free_fe_cell_iterator(fe)

end subroutine uim_init_cut_boundary_integration

!========================================================================================
subroutine uim_free_cut_boundary_integration( this )

  implicit none
  class(unfitted_integration_manager_t), intent(inout) :: this

  integer(ip) :: id, istat, jd

  if ( allocated( this%cut_boundary_quadratures_cell_dim ) ) then
    do id = 1, size(this%cut_boundary_quadratures_cell_dim)
      call this%cut_boundary_quadratures_cell_dim(id)%free()
    end do
    deallocate( this%cut_boundary_quadratures_cell_dim , stat = istat ); check(istat==0)
  end if

  if ( allocated( this%cut_boundary_piecewise_cell_maps ) ) then
    do id = 1, size(this%cut_boundary_piecewise_cell_maps )
      call this%cut_boundary_piecewise_cell_maps(id)%free()
    end do
    deallocate( this%cut_boundary_piecewise_cell_maps , stat = istat ); check(istat==0)
  end if

  if ( allocated( this%cut_boundary_cell_maps ) ) then
    do id = 1, size(this%cut_boundary_cell_maps )
      call this%cut_boundary_cell_maps(id)%free()
    end do
    deallocate( this%cut_boundary_cell_maps , stat = istat ); check(istat==0)
  end if

  if ( allocated( this%cut_boundary_cell_integrators ) ) then
    do id = 1, size(this%cut_boundary_cell_integrators,1)
      do jd = 1, size(this%cut_boundary_cell_integrators,2)
        call this%cut_boundary_cell_integrators(id,jd)%free()
      end do
    end do
    deallocate( this%cut_boundary_cell_integrators , stat = istat ); check(istat==0)
  end if

  call this%empty_piecewise_cell_map%free()

end subroutine uim_free_cut_boundary_integration

!========================================================================================
subroutine uim_init_cut_fitted_facets_integration( this )
  implicit none
  class(unfitted_integration_manager_t), intent(inout) :: this

  ! TODO

  integer(ip) :: num_dim, num_gp, num_gp_subfacet, num_subfacets, num_fields
  integer(ip) :: mc_case, mc_num_cases, istat, mc_num_facets, mc_facet
  integer(ip) :: max_num_fitted_sub_facets, ipos, max_pos, inum
  integer(ip) :: field_id
  class(fe_cell_iterator_t), allocatable :: fe
  class(reference_fe_t), pointer :: geo_reference_elem
  class(reference_fe_t), pointer :: geo_reference_elem_null
  class(reference_fe_t), pointer :: reference_elem
  class(reference_fe_t), pointer :: reference_elem_null

  call this%free_cut_fitted_facets_integration()

  num_dim = this%quadrature_subfacet%get_num_dims()
  num_gp_subfacet = this%quadrature_subfacet%get_num_quadrature_points()
  mc_num_cases = this%marching_cubes%get_num_mc_cases()
  mc_num_facets = this%marching_cubes%get_num_facets()

  max_num_fitted_sub_facets = 0
  do mc_case = 1, mc_num_cases
    do mc_facet = 1, mc_num_facets
      num_subfacets = this%marching_cubes%get_num_fitted_sub_facets(mc_facet,mc_case)
      max_num_fitted_sub_facets = max(max_num_fitted_sub_facets,num_subfacets)
    end do
  end do

  max_pos = 0
  allocate( this%num_fitted_sub_facets_to_pos(max_num_fitted_sub_facets), stat=istat ); check(istat==0_ip)
  this%num_fitted_sub_facets_to_pos(:) = 0_ip
  do mc_case = 1, mc_num_cases
    do mc_facet = 1, mc_num_facets
      num_subfacets = this%marching_cubes%get_num_fitted_sub_facets(mc_facet,mc_case)
      if (num_subfacets==0) then
        cycle
      end if
      if (this%num_fitted_sub_facets_to_pos(num_subfacets)==0) then
        max_pos = max_pos + 1
        this%num_fitted_sub_facets_to_pos(num_subfacets)=max_pos
      end if
    end do
  end do

  call this%fe_space%create_fe_cell_iterator(fe)
  geo_reference_elem => fe%get_reference_fe_geo()
  geo_reference_elem_null => null()
  assert(fe%get_num_fields()==1)
  field_id = 1
  call fe%first_local_non_void(field_id)
  if (fe%has_finished()) call fe%first()
  reference_elem => fe%get_reference_fe(field_id)
  reference_elem_null => null()

  allocate( this%cut_fitted_facet_quadratures(max_pos), stat=istat ); check(istat==0_ip)
  allocate( this%cut_fitted_facet_maps(pos_map_max_id,max_pos), stat=istat ); check(istat==0_ip)
  allocate( this%cut_fitted_facet_integrators(pos_map_max_id,max_pos), stat=istat ); check(istat==0_ip)
  do ipos = 1, max_pos

    num_subfacets = 0
    do inum = 1,max_num_fitted_sub_facets
      if (this%num_fitted_sub_facets_to_pos(inum)==ipos) then
        num_subfacets = inum
        exit
      end if
    end do
    assert( (num_subfacets>0) )

    num_gp = num_gp_subfacet*num_subfacets

    call this%cut_fitted_facet_quadratures(ipos)%create( num_dim, num_gp )

    call this%cut_fitted_facet_maps(pos_map_in_domain,ipos)%create(&
      this%cut_fitted_facet_quadratures(ipos), geo_reference_elem, geo_reference_elem )

    call this%cut_fitted_facet_maps(pos_map_on_boundary,ipos)%create(&
      this%cut_fitted_facet_quadratures(ipos), geo_reference_elem, geo_reference_elem_null )

    call this%cut_fitted_facet_integrators(pos_map_in_domain,ipos)%create(&
      this%cut_fitted_facet_quadratures(ipos), reference_elem, reference_elem )
    
    call this%cut_fitted_facet_integrators(pos_map_on_boundary,ipos)%create(&
      this%cut_fitted_facet_quadratures(ipos), reference_elem, reference_elem_null )

  end do
  
  ! Cerate dummy objects
  call this%empty_facet_quadrature%create(num_dim,0)
  call this%empty_facet_maps(pos_map_in_domain)%create(this%empty_facet_quadrature,geo_reference_elem, geo_reference_elem)
  call this%empty_facet_maps(pos_map_on_boundary)%create(this%empty_facet_quadrature,geo_reference_elem, geo_reference_elem_null)
  call this%empty_facet_integrators(pos_map_in_domain)%create(this%empty_facet_quadrature,reference_elem, reference_elem)
  call this%empty_facet_integrators(pos_map_on_boundary)%create(this%empty_facet_quadrature,reference_elem, reference_elem_null)

  call this%fe_space%free_fe_cell_iterator(fe)

end subroutine uim_init_cut_fitted_facets_integration

!========================================================================================
subroutine uim_free_cut_fitted_facets_integration( this )

  implicit none
  class(unfitted_integration_manager_t), intent(inout) :: this

  integer(ip) :: id, istat, jd

  if ( allocated( this%cut_fitted_facet_quadratures ) ) then
    do id = 1, size(this%cut_fitted_facet_quadratures,1)
      call this%cut_fitted_facet_quadratures(id)%free()
    end do
    deallocate( this%cut_fitted_facet_quadratures , stat = istat ); check(istat==0)
  end if

  if ( allocated( this%cut_fitted_facet_maps ) ) then
    do jd = 1, size(this%cut_fitted_facet_maps,2)
      do id = 1, size(this%cut_fitted_facet_maps,1)
        call this%cut_fitted_facet_maps(id,jd)%free()
      end do
    end do
    deallocate( this%cut_fitted_facet_maps , stat = istat ); check(istat==0)
  end if

  if ( allocated( this%cut_fitted_facet_integrators ) ) then
    do id = 1, size(this%cut_fitted_facet_integrators,1 )
      do jd = 1, size(this%cut_fitted_facet_integrators,2 )
      call this%cut_fitted_facet_integrators(id,jd)%free()
      end do
    end do
    deallocate( this%cut_fitted_facet_integrators , stat = istat ); check(istat==0)
  end if

  if (allocated(this%num_fitted_sub_facets_to_pos)) then
    deallocate(this%num_fitted_sub_facets_to_pos)
  end if
  
    ! Cerate dummy objects
  call this%empty_facet_quadrature%free()
  call this%empty_facet_maps(pos_map_in_domain)%free()
  call this%empty_facet_maps(pos_map_on_boundary)%free()
  call this%empty_facet_integrators(pos_map_in_domain)%free()
  call this%empty_facet_integrators(pos_map_on_boundary)%free()
  !empty_facet_integrators

end subroutine uim_free_cut_fitted_facets_integration
