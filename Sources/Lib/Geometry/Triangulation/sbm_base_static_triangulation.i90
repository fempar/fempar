! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! Private methods for creating cell-related data
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
subroutine bst_allocate_and_fill_ptr_vefs_x_cell (this, ptr_vefs_x_cell)
    implicit none
    class(base_static_triangulation_t), intent(inout) :: this
    integer(ip)                  , intent(in)    :: ptr_vefs_x_cell(this%num_local_cells+1)
    integer(ip) :: icell
    
    assert ( associated ( this%environment ) )
    assert ( this%environment%am_i_l1_task() )
    
    call memalloc ( this%num_local_cells+this%num_ghost_cells+1, &
                    this%ptr_vefs_x_cell, &
                    __FILE__, __LINE__ )
    
    this%ptr_vefs_x_cell = 0
    do icell = 1, this%num_local_cells
      this%ptr_vefs_x_cell(icell+1) = ptr_vefs_x_cell(icell+1) - ptr_vefs_x_cell(icell)
    end do
   
    ! write(*,*) this%element_import%get_num_neighbours()
    ! write(*,*) this%element_import%get_neighbours_ids()
    ! write(*,*) this%element_import%get_rcv_ptrs()
    ! write(*,*) this%element_import%get_rcv_leids()
    ! write(*,*) this%element_import%get_num_neighbours()
    ! write(*,*) this%element_import%get_neighbours_ids()
    ! write(*,*) this%element_import%get_snd_ptrs()
    ! write(*,*) this%element_import%get_snd_leids()

    call this%environment%l1_neighbours_exchange ( this%cell_import%get_num_neighbours(), &
                                             this%cell_import%get_neighbours_ids(),&
                                             this%cell_import%get_rcv_ptrs(),&
                                             this%cell_import%get_rcv_leids(),&
                                             this%cell_import%get_num_neighbours(), &
                                             this%cell_import%get_neighbours_ids(),&
                                             this%cell_import%get_snd_ptrs(),&
                                             this%cell_import%get_snd_leids(),&
                                             this%ptr_vefs_x_cell(2:),&
                                             this%ptr_vefs_x_cell(2:))
    this%ptr_vefs_x_cell(1) = 1
    do icell = 1, this%num_local_cells+this%num_ghost_cells
      this%ptr_vefs_x_cell(icell+1) = this%ptr_vefs_x_cell(icell+1) + this%ptr_vefs_x_cell(icell)
    end do
  end subroutine bst_allocate_and_fill_ptr_vefs_x_cell
  
subroutine bst_allocate_cells_ggid (this)
  implicit none
  class(base_static_triangulation_t), intent(inout) :: this
  assert ( associated ( this%environment ) )
  assert ( this%environment%am_i_l1_task() )
  call this%free_cells_ggid()
  call memalloc ( this%num_local_cells + this%num_ghost_cells, this%cells_ggid, __FILE__, __LINE__ )
end subroutine bst_allocate_cells_ggid
  
subroutine bst_fill_local_cells_ggid (this, cells_gid)
  implicit none
  class(base_static_triangulation_t), intent(inout) :: this
  integer(igp)                 , intent(in)    :: cells_gid(this%num_local_cells)
  integer(ip) :: icell
  assert ( associated ( this%environment ) )
  assert ( this%environment%am_i_l1_task() )
  if(this%environment%get_l1_size()>1) then
     do icell=1, this%num_local_cells
       this%cells_ggid(icell) = cells_gid(icell)
     end do
  else
     do icell=1, this%num_local_cells
       this%cells_ggid(icell) = icell
     end do  
  end if
end subroutine bst_fill_local_cells_ggid
 
subroutine bst_allocate_cells_mypart (this)
  implicit none
  class(base_static_triangulation_t), intent(inout) :: this
  assert ( associated ( this%environment ) )
  assert ( this%environment%am_i_l1_task() )
  call this%free_cells_mypart()
  call memalloc ( this%num_local_cells + this%num_ghost_cells, this%cells_mypart, __FILE__, __LINE__ )
end subroutine bst_allocate_cells_mypart
  
subroutine bst_fill_local_cells_mypart (this)
  implicit none
  class(base_static_triangulation_t), intent(inout) :: this
  integer(ip) :: icell
  assert ( associated ( this%environment ) )
  assert ( this%environment%am_i_l1_task() )
  do icell=1, this%num_local_cells
    this%cells_mypart(icell) = this%environment%get_l1_rank()+1
  end do
end subroutine bst_fill_local_cells_mypart

subroutine bst_allocate_cells_set (this)
  implicit none
  class(base_static_triangulation_t), intent(inout) :: this
  call this%free_cells_set()
  call memalloc ( this%num_local_cells + this%num_ghost_cells, this%cells_set, __FILE__, __LINE__ )
end subroutine bst_allocate_cells_set

subroutine bst_allocate_disconnected_cells_set (this)
  implicit none
  class(base_static_triangulation_t), intent(inout) :: this
  call this%free_disconnected_cells_set()
  call memalloc ( this%num_local_cells + this%num_ghost_cells, this%disconnected_cells_set_ids, __FILE__, __LINE__ )
end subroutine bst_allocate_disconnected_cells_set

subroutine bst_fill_cells_set (this, cells_set)
  implicit none
  class(base_static_triangulation_t), intent(inout) :: this
  integer(ip)                       , intent(in)    :: cells_set(:)
  
  assert ( size(cells_set) == this%num_local_cells )
  this%cells_set(1:this%num_local_cells) = cells_set
  if(this%environment%get_l1_size()>1) &
    call this%environment%l1_neighbours_exchange ( this%cell_import%get_num_neighbours(), &
                                             this%cell_import%get_neighbours_ids(),    &
                                             this%cell_import%get_rcv_ptrs(),          &
                                             this%cell_import%get_rcv_leids(),         &
                                             this%cell_import%get_num_neighbours(), &
                                             this%cell_import%get_neighbours_ids(),    &
                                             this%cell_import%get_snd_ptrs(),          &
                                             this%cell_import%get_snd_leids(),         &
                                             this%cells_set,                           & 
                                             this%cells_set)
end subroutine bst_fill_cells_set

function bst_compute_max_cells_set_id (this)
  implicit none
  class(base_static_triangulation_t), intent(inout) :: this
  integer(ip)                                       :: bst_compute_max_cells_set_id
  class(environment_t), pointer :: environment 
  
  bst_compute_max_cells_set_id = maxval(this%cells_set)
  environment => this%get_environment()
  call environment%l1_max(bst_compute_max_cells_set_id) 
end function bst_compute_max_cells_set_id 

subroutine bst_resize_disconnected_cells_set (this)
  implicit none
  class(base_static_triangulation_t), intent(inout) :: this
  if (allocated( this%disconnected_cells_set_ids )) call memfree( this%disconnected_cells_set_ids, __FILE__, __LINE__) 
  call memalloc( this%get_num_cells(), this%disconnected_cells_set_ids, __FILE__, __LINE__) 
  this%disconnected_cells_set_ids = 0
end subroutine bst_resize_disconnected_cells_set

subroutine bst_fill_disconnected_cells_set (this, disconnected_cells_set)
  implicit none
  class(base_static_triangulation_t), intent(inout) :: this
  integer(ip)                       , intent(in)    :: disconnected_cells_set(:)
  
  assert ( size(disconnected_cells_set) == this%num_local_cells )
  this%disconnected_cells_set_ids(1:this%num_local_cells) = disconnected_cells_set
  if(this%environment%get_l1_size()>1) &
    call this%environment%l1_neighbours_exchange ( this%cell_import%get_num_neighbours(), &
                                             this%cell_import%get_neighbours_ids(),    &
                                             this%cell_import%get_rcv_ptrs(),          &
                                             this%cell_import%get_rcv_leids(),         &
                                             this%cell_import%get_num_neighbours(),    &
                                             this%cell_import%get_neighbours_ids(),    &
                                             this%cell_import%get_snd_ptrs(),          &
                                             this%cell_import%get_snd_leids(),         &
                                             this%disconnected_cells_set_ids,          & 
                                             this%disconnected_cells_set_ids)
end subroutine bst_fill_disconnected_cells_set

subroutine bst_free_ptr_vefs_x_cell (this)
  implicit none
  class(base_static_triangulation_t), intent(inout) :: this
  if (allocated (this%ptr_vefs_x_cell)) call memfree ( this%ptr_vefs_x_cell, __FILE__, __LINE__ )
end subroutine bst_free_ptr_vefs_x_cell

subroutine bst_free_lst_vefs_gids ( this )
  implicit none
  class(base_static_triangulation_t), intent(inout) :: this
  if ( allocated(this%lst_vefs_gids) ) call memfree( this%lst_vefs_gids, __FILE__, __LINE__ )
end subroutine bst_free_lst_vefs_gids

subroutine bst_free_cells_ggid (this)
  implicit none
  class(base_static_triangulation_t), intent(inout) :: this
  if (allocated (this%cells_ggid)) call memfree ( this%cells_ggid, __FILE__, __LINE__ )
end subroutine bst_free_cells_ggid

subroutine bst_free_cells_mypart (this)
  implicit none
  class(base_static_triangulation_t), intent(inout) :: this
  if (allocated (this%cells_mypart)) call memfree ( this%cells_mypart, __FILE__, __LINE__ )
end subroutine bst_free_cells_mypart

subroutine bst_free_cells_set (this)
  implicit none
  class(base_static_triangulation_t), intent(inout) :: this
  if (allocated (this%cells_set)) call memfree ( this%cells_set, __FILE__, __LINE__ )
end subroutine bst_free_cells_set

subroutine bst_free_disconnected_cells_set (this)
  implicit none
  class(base_static_triangulation_t), intent(inout) :: this
  if (allocated (this%disconnected_cells_set_ids)) call memfree ( this%disconnected_cells_set_ids, __FILE__, __LINE__ )
end subroutine bst_free_disconnected_cells_set

subroutine bst_orient_tet_mesh(this,lst_vefs_gids_ghost_extended)
  implicit none
  class(base_static_triangulation_t), intent(inout) :: this
  integer(igp)            , optional, intent(in)    :: lst_vefs_gids_ghost_extended(:)
  integer(ip)  :: icell, spos, epos, nnode, i
  integer(igp), allocatable :: gids(:)
  integer(ip) , allocatable :: perm(:)
  
  nnode = this%ptr_vefs_x_cell(2) - this%ptr_vefs_x_cell(1)
  call memalloc(nnode, gids,__FILE__,__LINE__)
  call memalloc(nnode, perm,__FILE__,__LINE__)
  
  do icell = 1, this%num_local_cells + this%num_ghost_cells
     spos = this%ptr_vefs_x_cell(icell)
     epos = this%ptr_vefs_x_cell(icell+1)-1
     if ( present(lst_vefs_gids_ghost_extended) ) then
       gids = lst_vefs_gids_ghost_extended(spos:epos)
       perm = (/(i, i=1,nnode, 1)/)
       call sort(nnode, gids, index=perm)
       this%lst_vefs_gids(spos:epos) = this%lst_vefs_gids(spos+perm(1:nnode)-1)
     else
       call sort(nnode, this%lst_vefs_gids(spos:epos))
     end if
  end do
  
  call memfree(gids,__FILE__,__LINE__)
  call memfree(perm,__FILE__,__LINE__)
end subroutine bst_orient_tet_mesh

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! Private methods to perform nearest neighbor exchange
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine bst_fetch_ghost_cells_data(this, &
                                                         lst_vefs_gids, &
                                                         lst_vefs_gids_ghost_extended, &
                                                         lst_vefs_dim, &
                                                         lst_vefs_dim_ghost_extended, &
                                                         coordinates, &
                                                         coordinates_ghost_extended)
    implicit none
    class(base_static_triangulation_t) , intent(in)    :: this
    integer(igp)                       , intent(in)    :: lst_vefs_gids(*)
    integer(igp), allocatable          , intent(inout) :: lst_vefs_gids_ghost_extended(:)
    integer(ip) , optional             , intent(in)    :: lst_vefs_dim(*)
    integer(ip) , optional, allocatable, intent(inout) :: lst_vefs_dim_ghost_extended(:)
    real(rp)    , optional             , intent(in)    :: coordinates(:,:)
    real(rp)    , optional, allocatable, intent(inout) :: coordinates_ghost_extended(:,:)
    
    integer(ieep), allocatable :: snd_buf(:)  
    integer(ieep), allocatable :: rcv_buf(:) 
    integer(ip)  , allocatable :: snd_ptrs_buf(:)  
    integer(ip)  , allocatable :: rcv_ptrs_buf(:) 
    integer(ip)  , allocatable :: cell_sizes(:)
    integer(ip)  , pointer     :: snd_ptrs(:)
    integer(ip)  , pointer     :: snd_leids(:)
    integer(ip)  , pointer     :: rcv_ptrs(:)
    integer(ip)  , pointer     :: rcv_leids(:)
    type(bst_cell_iterator_t) :: cell
    integer(ip)                :: icell, first, last, extra_data_size_x_vef
    integer(ip)                :: start_buf, end_buf, current, i, j, num_neighbours
    
    assert ( associated ( this%environment ) )
    assert ( this%environment%am_i_l1_task() )
    assert ( .not.(present(lst_vefs_dim).and.present(coordinates))) ! Not present both at the same time

    if ( allocated (lst_vefs_gids_ghost_extended) ) &
      call memfree( lst_vefs_gids_ghost_extended, __FILE__, __LINE__)
    call memalloc ( this%ptr_vefs_x_cell(this%num_local_cells+this%num_ghost_cells+1)-1, &
                    lst_vefs_gids_ghost_extended, &
                    __FILE__, &
                    __LINE__ )

    first  = this%ptr_vefs_x_cell(1)
    last   = this%ptr_vefs_x_cell(this%num_local_cells+1)-1
    lst_vefs_gids_ghost_extended(first:last) = lst_vefs_gids(first:last)
    extra_data_size_x_vef = 0

    if(present(lst_vefs_dim)) then
       assert(present(lst_vefs_dim_ghost_extended))
       if ( allocated (lst_vefs_dim_ghost_extended) )  &
            call memfree( lst_vefs_dim_ghost_extended, __FILE__, __LINE__)
       call memalloc ( this%ptr_vefs_x_cell(this%num_local_cells+this%num_ghost_cells+1)-1, &
                       lst_vefs_dim_ghost_extended, &
                       __FILE__, &
                       __LINE__ )
       lst_vefs_dim_ghost_extended(first:last) = lst_vefs_dim(first:last)  
       extra_data_size_x_vef = size_of_ip
    end if

    ! We assume that coordinates are exchanged when the triangulation only contains vertices
    if(present(coordinates)) then
       assert(present(coordinates_ghost_extended))
       if ( allocated (coordinates_ghost_extended) )  &
            call memfree( coordinates_ghost_extended, __FILE__, __LINE__)
            call memalloc ( SPACE_DIM, this%ptr_vefs_x_cell(this%num_local_cells+this%num_ghost_cells+1)-1, &
                            coordinates_ghost_extended, &
                            __FILE__, &
                            __LINE__ )
       coordinates_ghost_extended(:,first:last) = coordinates(:,first:last)  
       extra_data_size_x_vef = size_of_rp*SPACE_DIM
    end if


    call memalloc ( this%num_local_cells+this%num_ghost_cells, &
                    cell_sizes, &
                    __FILE__, &
                    __LINE__ )
      
    num_neighbours = this%cell_import%get_num_neighbours()
    snd_ptrs => this%cell_import%get_snd_ptrs()
    rcv_ptrs => this%cell_import%get_rcv_ptrs()
    snd_leids => this%cell_import%get_snd_leids()
    rcv_leids => this%cell_import%get_rcv_leids()
    
    call memalloc ( num_neighbours+1, snd_ptrs_buf, __FILE__, __LINE__ )
    call memalloc ( num_neighbours+1, rcv_ptrs_buf, __FILE__, __LINE__ )
    
    call cell%create(this)
    
    snd_ptrs_buf = 0
    do i=1, num_neighbours
     do j=snd_ptrs(i),snd_ptrs(i+1)-1
       icell = snd_leids(j)
       call cell%set_gid(icell)
       cell_sizes(icell) = this%cell_size(cell) + extra_data_size_x_vef*(cell%get_num_vefs())
       snd_ptrs_buf(i+1) = snd_ptrs_buf(i+1) + cell_sizes(icell)
     end do
    end do
    
     snd_ptrs_buf(1) = 1
     do i=1, num_neighbours
       snd_ptrs_buf(i+1) = snd_ptrs_buf(i) + snd_ptrs_buf(i+1)
     end do
    
     rcv_ptrs_buf = 0
     do i=1, num_neighbours
      do j=rcv_ptrs(i),rcv_ptrs(i+1)-1
       icell = rcv_leids(j)
       call cell%set_gid(icell)
       cell_sizes(icell) = this%cell_size(cell) + extra_data_size_x_vef*(cell%get_num_vefs())
       rcv_ptrs_buf(i+1) = rcv_ptrs_buf(i+1) + cell_sizes(icell)
      end do
     end do
     
     rcv_ptrs_buf(1) = 1
     do i=1, num_neighbours
       rcv_ptrs_buf(i+1) = rcv_ptrs_buf(i) + rcv_ptrs_buf(i+1)
     end do
    
     call memalloc (snd_ptrs_buf(num_neighbours+1)-1, snd_buf, __FILE__,__LINE__)
     call memalloc (rcv_ptrs_buf(num_neighbours+1)-1, rcv_buf, __FILE__,__LINE__)
      
     ! Pack data items into send buffer
     current = 1
     if(present(lst_vefs_dim)) then ! vef_dims and coordinates are not present together
         do i=1, num_neighbours
            current = snd_ptrs_buf(i)
            do j=snd_ptrs(i),snd_ptrs(i+1)-1
              icell = snd_leids(j)
              call cell%set_gid(icell)
              first     = this%ptr_vefs_x_cell(icell)
              last      = this%ptr_vefs_x_cell(icell+1)-1
              start_buf = current
              end_buf   = current + cell_sizes(icell)-1
              call this%cell_pack ( cell = cell, &
                                    buffer = snd_buf(start_buf:end_buf), &
                                    vef_gids = lst_vefs_gids_ghost_extended(first:last), &
                                    vef_dims = lst_vefs_dim_ghost_extended(first:last) )
              current = current + cell_sizes(icell)
            end do
         end do
     else if(present(coordinates)) then
         do i=1, num_neighbours
            current = snd_ptrs_buf(i)
            do j=snd_ptrs(i),snd_ptrs(i+1)-1
              icell = snd_leids(j)
              call cell%set_gid(icell)
              first     = this%ptr_vefs_x_cell(icell)
              last      = this%ptr_vefs_x_cell(icell+1)-1
              start_buf = current
              end_buf   = current + cell_sizes(icell)-1
              call this%cell_pack ( cell = cell, &
                                    buffer = snd_buf(start_buf:end_buf), &
                                    vef_gids = lst_vefs_gids_ghost_extended(first:last), &
                                    coordinates = coordinates_ghost_extended(:,first:last) )
              current = current + cell_sizes(icell)
            end do
         end do
     else
         do i=1, num_neighbours
            current = snd_ptrs_buf(i)
            do j=snd_ptrs(i),snd_ptrs(i+1)-1
              icell = snd_leids(j)
              call cell%set_gid(icell)
              first     = this%ptr_vefs_x_cell(icell)
              last      = this%ptr_vefs_x_cell(icell+1)-1
              start_buf = current
              end_buf   = current + cell_sizes(icell)-1
              call this%cell_pack ( cell = cell, &
                                    buffer = snd_buf(start_buf:end_buf), &
                                    vef_gids = lst_vefs_gids_ghost_extended(first:last) )
              current = current + cell_sizes(icell)
            end do
         end do
     endif
     
     ! Exchange data with nearest neighbours
     call this%environment%l1_neighbours_exchange ( num_neighbours,&
                                              this%cell_import%get_neighbours_ids(),&
                                              snd_ptrs_buf,&
                                              snd_buf,&
                                              rcv_ptrs_buf,&
                                              rcv_buf) 
          
     ! Unpack data items from recv buffer
     current = rcv_ptrs_buf(1)
     if(present(lst_vefs_dim)) then
         do i=1, num_neighbours
            do j=rcv_ptrs(i),rcv_ptrs(i+1)-1
              icell = rcv_leids(j)
              call cell%set_gid(icell)
              first     = this%ptr_vefs_x_cell(icell)
              last       = this%ptr_vefs_x_cell(icell+1)-1
              start_buf = current
              end_buf   = current + cell_sizes(icell)-1
              call this%cell_unpack ( cell = cell, &
                                      buffer = rcv_buf(start_buf:end_buf), &
                                      vef_gids = lst_vefs_gids_ghost_extended(first:last), &
                                      vef_dims = lst_vefs_dim_ghost_extended(first:last) )
              current = current + cell_sizes(icell)
            end do
         end do
     else if(present(coordinates)) then
         do i=1, num_neighbours
            do j=rcv_ptrs(i),rcv_ptrs(i+1)-1
              icell = rcv_leids(j)
              call cell%set_gid(icell)
              first     = this%ptr_vefs_x_cell(icell)
              last       = this%ptr_vefs_x_cell(icell+1)-1
              start_buf = current
              end_buf   = current + cell_sizes(icell)-1
              call this%cell_unpack ( cell = cell, &
                                      buffer = rcv_buf(start_buf:end_buf), &
                                      vef_gids = lst_vefs_gids_ghost_extended(first:last), &
                                      coordinates = coordinates_ghost_extended(:,first:last) )
              current = current + cell_sizes(icell)
            end do
         end do
     else
         do i=1, num_neighbours
            do j=rcv_ptrs(i),rcv_ptrs(i+1)-1
              icell = rcv_leids(j)
              call cell%set_gid(icell)
              first     = this%ptr_vefs_x_cell(icell)
              last       = this%ptr_vefs_x_cell(icell+1)-1
              start_buf = current
              end_buf   = current + cell_sizes(icell)-1
              call this%cell_unpack ( cell = cell, &
                                      buffer = rcv_buf(start_buf:end_buf), &
                                      vef_gids = lst_vefs_gids_ghost_extended(first:last) )
              current = current + cell_sizes(icell)
            end do
         end do
     endif
     call cell%free()
     call memfree ( cell_sizes, __FILE__, __LINE__ )
     call memfree ( snd_ptrs_buf, __FILE__, __LINE__ )
     call memfree ( rcv_ptrs_buf, __FILE__, __LINE__ )
     call memfree ( snd_buf, __FILE__, __LINE__ )
     call memfree ( rcv_buf, __FILE__, __LINE__ )
  end subroutine bst_fetch_ghost_cells_data
  
  function bst_cell_size ( cell )
    implicit none
    class(bst_cell_iterator_t) , intent(in)  :: cell
    integer(ip) :: bst_cell_size
    bst_cell_size = size_of_ip + size_of_igp + &
                                     size_of_igp*(cell%get_num_vefs()) ! + size_of_ip*(cell%get_num_vefs())
  end function bst_cell_size
  
  subroutine bst_cell_pack_vef_ggids (cell, buffer, vef_gids, buffer_offset)
    implicit none
    class(bst_cell_iterator_t), intent(in)  :: cell
    integer(igp)          , intent(in)  :: vef_gids(:)
    integer(ieep)         , intent(out) :: buffer(:)
    integer(ip), optional , intent(out) :: buffer_offset
    integer(ip)                         :: first, last
        
    first = 1
    last   = first + size_of_igp -1
    buffer(first:last) = transfer(cell%get_ggid(),buffer(first:last))
    first = last + 1
    last   = first + size_of_ip -1
    buffer(first:last) = transfer(cell%get_my_part(),buffer(first:last))
    first = last + 1
    last   = first + cell%get_num_vefs()*size_of_igp - 1
    buffer(first:last) = transfer(vef_gids,buffer(first:last))
    if(present(buffer_offset)) buffer_offset = last

  end subroutine bst_cell_pack_vef_ggids


  subroutine bst_cell_pack_vef_ggids_and_dim (cell, buffer, vef_gids, vef_dims)
    implicit none
    class(bst_cell_iterator_t), intent(in)  :: cell
    integer(igp)          , intent(in)  :: vef_gids(:)
    integer(ip)           , intent(in)  :: vef_dims(:)
    integer(ieep)         , intent(out) :: buffer(:)
    integer(ip)                        :: first, last
        
    call bst_cell_pack_vef_ggids(cell,buffer,vef_gids, buffer_offset=last)
    first = last + 1
    last  = first + cell%get_num_vefs()*size_of_ip - 1
    buffer(first:last) = transfer(vef_dims,buffer(first:last))

  end subroutine bst_cell_pack_vef_ggids_and_dim


  subroutine bst_cell_pack_vef_ggids_and_coordinates (cell, buffer, vef_gids, coordinates)
    implicit none
    class(bst_cell_iterator_t), intent(in)  :: cell
    integer(igp)          , intent(in)  :: vef_gids(:)
    real(rp)              , intent(in)  :: coordinates(:,:)
    integer(ieep)         , intent(out) :: buffer(:)
    integer(ip)                        :: first, last, ivef
        
    call bst_cell_pack_vef_ggids(cell,buffer,vef_gids, buffer_offset=last)
    do ivef=1,cell%get_num_vefs()
       first = last + 1
       last  = first + SPACE_DIM*size_of_rp - 1
       buffer(first:last) = transfer(coordinates(:,ivef),buffer(first:last))
    end do

  end subroutine bst_cell_pack_vef_ggids_and_coordinates
  
  subroutine bst_cell_unpack_vef_ggids (cell, buffer, vef_gids, buffer_offset)
    implicit none
    class(bst_cell_iterator_t), intent(inout) :: cell
    integer(ieep)         , intent(in)    :: buffer(:)
    integer(igp)          , intent(out)   :: vef_gids(:)
    integer(ip), optional , intent(out)   :: buffer_offset
    integer(ip)                          :: first, last
    integer(igp)                         :: gid
    integer(ip)                          :: mypart
    
    first = 1
    last = first + size_of_igp -1
    gid = transfer(buffer(first:last), gid) 
    call cell%set_ggid(gid)
    
    first = last + 1
    last = first + size_of_ip - 1
    mypart = transfer(buffer(first:last), mypart)
    call cell%set_mypart(mypart)
    
    first = last + 1
    last = first + cell%get_num_vefs()*size_of_igp - 1
    vef_gids = transfer(buffer(first:last), vef_gids)

    if(present(buffer_offset)) buffer_offset = last
            
  end subroutine bst_cell_unpack_vef_ggids


  subroutine bst_cell_unpack_vef_ggids_and_dim (cell, buffer, vef_gids, vef_dims)
    implicit none
    class(bst_cell_iterator_t), intent(inout) :: cell
    integer(ieep)         , intent(in)    :: buffer(:)
    integer(igp)          , intent(out)   :: vef_gids(:)
    integer(ip)           , intent(out)   :: vef_dims(:)
    integer(ip)                           :: first, last, ivef
    
    call bst_cell_unpack_vef_ggids(cell, buffer, vef_gids, buffer_offset=last)
    first = last + 1
    last = first + cell%get_num_vefs()*size_of_ip - 1
    vef_dims = transfer(buffer(first:last), vef_dims)
    
  end subroutine bst_cell_unpack_vef_ggids_and_dim


  subroutine bst_cell_unpack_vef_ggids_and_coordinates (cell, buffer, vef_gids, coordinates)
    implicit none
    class(bst_cell_iterator_t), intent(inout) :: cell
    integer(ieep)         , intent(in)    :: buffer(:)
    integer(igp)          , intent(out)   :: vef_gids(:)
    real(rp)              , intent(out)   :: coordinates(:,:)
    integer(ip)                           :: first, last, ivef
    
    call bst_cell_unpack_vef_ggids(cell, buffer, vef_gids, buffer_offset=last)
    do ivef=1,cell%get_num_vefs()
       first = last + 1
       last = first +SPACE_DIM*size_of_rp - 1
       coordinates(:,ivef) = transfer(buffer(first:last), coordinates(:,ivef))
    end do
  end subroutine bst_cell_unpack_vef_ggids_and_coordinates


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! Private methods for creating vef-related data
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
subroutine bst_compute_num_vefs ( this )
  implicit none
  class(base_static_triangulation_t), intent(inout) :: this
  type(hash_table_ip_ip_t) :: visited_vefs
  integer(ip) :: icell, ivef, vef_lid, istat
  type(bst_cell_iterator_t) :: cell
  
  call visited_vefs%init(max(5,int(real(this%num_local_cells,rp)*0.2_rp,ip))) 
  this%num_vefs = 0
  call cell%create(this)
  do while( .not. cell%has_finished() )
     do ivef=1, cell%get_num_vefs()
        vef_lid = cell%get_vef_gid(ivef)
        call visited_vefs%put(key=vef_lid, val=1, stat=istat)
        if (istat == now_stored) this%num_vefs = this%num_vefs + 1
     end do
     call cell%next()
  end do
  call visited_vefs%free()
  call cell%free()
end subroutine bst_compute_num_vefs

subroutine bst_allocate_and_fill_vefs_ggid ( this, lst_vefs_gid )
  implicit none
  class(base_static_triangulation_t), intent(inout) :: this
  integer(igp)                                      :: lst_vefs_gid(*)
  integer(ip)                                       :: icell, ivef, vef_lid, current
  integer(igp)                                      :: vef_gid
  type(bst_cell_iterator_t) :: cell

  assert ( this%num_vefs >= 0 ) 

  call this%free_vefs_ggid()
  call memalloc(this%num_vefs, this%vefs_ggid,__FILE__,__LINE__)

  call cell%create(this)
  current = 1
  do while( .not. cell%has_finished() )
     do ivef=1, cell%get_num_vefs()
        vef_lid = cell%get_vef_gid(ivef)
        vef_gid = lst_vefs_gid(current)
        this%vefs_ggid(vef_lid) = vef_gid
        current = current + 1 
     end do
     call cell%next()
  end do
  call cell%free()
end subroutine bst_allocate_and_fill_vefs_ggid

subroutine bst_free_vefs_ggid( this )
  implicit none
  class(base_static_triangulation_t), intent(inout) :: this
  if (allocated(this%vefs_ggid)) call memfree(this%vefs_ggid,__FILE__,__LINE__)
end subroutine bst_free_vefs_ggid

subroutine bst_triangulation_free_vefs_type( this )
  implicit none
  class(base_static_triangulation_t), intent(inout) :: this
  if (allocated(this%vefs_type)) call memfree(this%vefs_type,__FILE__,__LINE__)
end subroutine bst_triangulation_free_vefs_type

subroutine bst_allocate_and_fill_cells_around ( this )
  implicit none
  class(base_static_triangulation_t), intent(inout)  :: this
  integer(ip)                                        :: ivef, vef_lid
  type(bst_cell_iterator_t) :: cell

  call this%free_cells_around()

  call memalloc ( this%num_vefs+1, this%ptrs_cells_around, __FILE__, __LINE__ )
  this%ptrs_cells_around = 0

  call cell%create(this)
  do while( .not. cell%has_finished() )
     do ivef=1, cell%get_num_vefs()
        vef_lid = cell%get_vef_gid(ivef)
        this%ptrs_cells_around(vef_lid +1) = this%ptrs_cells_around(vef_lid+1) + 1
     end do
     call cell%next()
  end do

  this%ptrs_cells_around(1) = 1
  do ivef=2, this%num_vefs+1
     this%ptrs_cells_around(ivef) = this%ptrs_cells_around(ivef) + this%ptrs_cells_around(ivef-1)
  end do

  call memalloc ( this%ptrs_cells_around(this%num_vefs+1)-1, this%lst_cells_around, __FILE__, __LINE__ )

  call cell%first()
  do while ( .not. cell%has_finished() )
     do ivef=1, cell%get_num_vefs()
        vef_lid = cell%get_vef_gid(ivef)
        this%lst_cells_around(this%ptrs_cells_around(vef_lid)) = cell%get_gid()
        this%ptrs_cells_around(vef_lid) = this%ptrs_cells_around(vef_lid) + 1
     end do
     call cell%next()
  end do

  do ivef=this%num_vefs+1,2,-1 
     this%ptrs_cells_around(ivef) = this%ptrs_cells_around(ivef-1)
  end do
  this%ptrs_cells_around(1) = 1
  call cell%free()
end subroutine bst_allocate_and_fill_cells_around

subroutine bst_free_cells_around(this)
  implicit none
  class(base_static_triangulation_t), intent(inout) :: this
  if (allocated(this%ptrs_cells_around)) call memfree(this%ptrs_cells_around,__FILE__,__LINE__)
  if (allocated(this%lst_cells_around)) call memfree(this%lst_cells_around,__FILE__,__LINE__)
end subroutine bst_free_cells_around

subroutine bst_find_local_ghost_vefs (this)
  implicit none
  class(base_static_triangulation_t), intent(inout) :: this
  integer(ip)           :: ivef,icell
  type(bst_cell_iterator_t) :: cell
  type(bst_vef_iterator_t)  :: vef
  logical               :: vef_is_local, vef_is_ghost

  assert ( this%num_vefs >= 0 )
  assert ( allocated(this%vefs_type) )

  call cell%create(this)
  call vef%create(this)
  ! Find vefs at interfaces and count them
  do while ( .not. vef%has_finished() )
     vef_is_local = .true.
     vef_is_ghost = .true.
     do icell = 1, vef%get_num_cells_around()
        call vef%get_cell_around(icell,cell)
        if(cell%is_ghost()) then
           vef_is_local = .false.
        else if(cell%is_local()) then
           vef_is_ghost = .false.
        end if
     end do
     if(vef_is_local) then
        call vef%set_it_as_local()
     else if(vef_is_ghost) then
        call vef%set_it_as_ghost()
     else
        call vef%set_it_at_interface()
     end if
     call vef%next()
  end do
  call cell%free()
  call vef%free()
end subroutine bst_find_local_ghost_vefs

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! Traversals
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
subroutine bst_create_cell_iterator ( this, cell )
  implicit none
  class(base_static_triangulation_t) , intent(in)    :: this
  class(cell_iterator_t), allocatable, intent(inout) :: cell
  integer(ip) :: istat
  call this%free_cell_iterator(cell)
  allocate(bst_cell_iterator_t :: cell, stat=istat); check(istat==0)
  call cell%create(this)
end subroutine bst_create_cell_iterator

subroutine bst_free_cell_iterator ( this, cell )
  implicit none
  class(base_static_triangulation_t) , intent(in)    :: this
  class(cell_iterator_t), allocatable, intent(inout) :: cell
  integer(ip) :: istat
  if(allocated(cell)) then
     call cell%free()
     deallocate(cell, stat=istat); check(istat==0)
  end if
end subroutine bst_free_cell_iterator

subroutine bst_create_vef_iterator ( this, vef )
  implicit none
  class(base_static_triangulation_t) , intent(in)    :: this
  class(vef_iterator_t), allocatable , intent(inout) :: vef
  integer(ip) :: istat
  call this%free_vef_iterator(vef)
  allocate(bst_vef_iterator_t :: vef, stat=istat); check(istat==0)
  call vef%create(this)
end subroutine bst_create_vef_iterator

subroutine bst_free_vef_iterator ( this, vef )
  implicit none
  class(base_static_triangulation_t) , intent(in)    :: this
  class(vef_iterator_t), allocatable , intent(inout) :: vef
  integer(ip) :: istat
  if(allocated(vef)) then
     call vef%free()
     deallocate(vef, stat=istat); check(istat==0)
  end if
end subroutine bst_free_vef_iterator
  
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! Other
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

function bst_get_num_proper_vefs ( this ) 
  implicit none
  class(base_static_triangulation_t), intent(in) :: this
  integer(ip) :: bst_get_num_proper_vefs
  bst_get_num_proper_vefs = this%num_vefs
end function bst_get_num_proper_vefs

function bst_get_num_improper_vefs ( this ) 
  implicit none
  class(base_static_triangulation_t), intent(in) :: this
  integer(ip) :: bst_get_num_improper_vefs
  bst_get_num_improper_vefs = 0
end function bst_get_num_improper_vefs

subroutine bst_print ( this )
   class(base_static_triangulation_t), intent(in) :: this
   integer(ip) :: ivef,inode
   type(bst_vef_iterator_t)  :: vef
   type(bst_cell_iterator_t) :: cell 

   type(point_t), allocatable :: cell_coordinates(:)
   integer(ip) :: vef_lid

   write (*,'(a)') '****print type(static_triangulation_t)****'
   write (*,'(a,i10)') 'num_dims:' , this%num_dims
   write (*,'(a,i10)') 'num_local_cells:', this%num_local_cells
   write (*,'(a,i10)') 'num_ghost_cells:', this%num_ghost_cells
   write (*,'(a,i10)') 'num_itfc_vefs:  ', this%get_num_itfc_vefs()
   write (*,'(a)') '**** Cells ****'

   call cell%create(this)
   write (*,'(a)') '       id      is_local   is_ghost  num_vefs    vef        vef  ....'
   do while ( .not. cell%has_finished() )
       write(*,'(i10,2l10,10(2x,i10))') cell%get_gid(), cell%is_local(), cell%is_ghost(), cell%get_num_vefs(), (cell%get_vef_gid(ivef),ivef=1,cell%get_num_vefs())
       call cell%next()
   end do

   ! Allocate cell_coordinates using size of first cell
   call cell%first()
   call memalloc(cell%get_num_nodes(),cell_coordinates,__FILE__,__LINE__)

    write (*,'(a)') '       id      is_local   num_vefs    coord        coord  ....'
    do while ( .not. cell%has_finished() )
       !write(*,*) 'Printing cell:',cell%get_gid(),cell%is_local()
       if(cell%is_local()) then
          call memrealloc(cell%get_num_nodes(),cell_coordinates,__FILE__,__LINE__)
          call cell%get_nodes_coordinates (cell_coordinates)
          write (*,'(i10,20(2x,e15.7))'  ) cell%get_gid(), (cell_coordinates(inode)%get_value(),inode=1,cell%get_num_nodes())
       end if
       call cell%next()
    end do
    write (*,'(a)') '**** End Cells ****'

    write (*,'(a)') '**** Vefs ****'
    write (*,'(a)') '        id          dim    is_local    is_at_interface  is_ghost   is_at_bound       set        geom '
    call vef%create(this)
    do while ( .not. vef%has_finished() )
       vef_lid = vef%get_gid()
       write(*,'(2(i10,2x),4(10x,l1),2(2x,i10))') vef_lid,  vef%get_dim(),  vef%is_local(),  vef%is_at_interface(), vef%is_ghost(), vef%is_at_boundary(), vef%get_set_id(),this%vefs_geometry(vef_lid)
       call vef%next()
    end do
    call vef%free()
    call memfree(cell_coordinates,__FILE__,__LINE__)
    call cell%free()
  end subroutine bst_print


  recursive subroutine bst_free ( this )
    implicit none
    class(base_static_triangulation_t), target, intent(inout) :: this
    integer(ip) :: icell, ivef, istat
    if ( associated(this%environment) ) then
      if ( this%environment%am_i_l1_task() ) then
        ! Free cell-related data
        call this%free_ptr_vefs_x_cell()
        call this%free_lst_vefs_gids()
        call this%free_cells_ggid()
        call this%free_cells_mypart() 
        call this%free_cells_set()
        call this%free_disconnected_cells_set()
     
        ! Free vef-related data
        call this%free_vefs_ggid()
        call this%free_vefs_type()
        call this%free_cells_around()
        call this%free_lst_itfc_vefs()
      end if
      call this%geometry%free()
    end if
    call triangulation_free(this)
   end subroutine bst_free

   subroutine bst_environment_free_or_nullify ( this) 
     implicit none
     class(base_static_triangulation_t), target, intent(inout) :: this
     check(.false.)
   end subroutine  bst_environment_free_or_nullify 
   
   function bst_get_num_reference_fes ( this ) 
     implicit none
     class(base_static_triangulation_t), intent(in) :: this
     integer(ip) :: bst_get_num_reference_fes
     integer(ip) :: i
     bst_get_num_reference_fes = 0
     do i=1, max_num_reference_fes_geo
       if ( associated(this%reference_fe_geo_list(i)%p) ) then
         bst_get_num_reference_fes = bst_get_num_reference_fes + 1 
       end if
     end do 
   end function bst_get_num_reference_fes
   
   function bst_get_reference_fe ( this, ref_fe_geo_id )
     implicit none
     class(base_static_triangulation_t), target, intent(in) :: this 
     integer(ip)                               , intent(in) :: ref_fe_geo_id
     class(reference_fe_t), pointer :: bst_get_reference_fe
     assert ( ref_fe_geo_id >= 1 .and. ref_fe_geo_id <= this%get_num_reference_fes() ) 
     bst_get_reference_fe => this%reference_fe_geo_list(ref_fe_geo_id)%p
   end function bst_get_reference_fe 
   
   function bst_get_max_num_shape_functions ( this ) 
     implicit none
     class(base_static_triangulation_t), intent(in) :: this
     integer(ip) :: bst_get_max_num_shape_functions
     integer(ip) :: reference_fe_geo_id
     bst_get_max_num_shape_functions = -1
     do reference_fe_geo_id=1, max_num_reference_fes_geo
       if(associated(this%reference_fe_geo_list(reference_fe_geo_id)%p)) then
         bst_get_max_num_shape_functions = &
             max(bst_get_max_num_shape_functions, &
             this%reference_fe_geo_list(reference_fe_geo_id)%p%get_num_shape_functions())
       endif
     enddo
   end function bst_get_max_num_shape_functions

   function bst_is_tet_mesh ( this ) 
     implicit none
     class(base_static_triangulation_t), intent(in) :: this
     integer(ip) :: dum, istat
     logical :: bst_is_tet_mesh
     
     bst_is_tet_mesh = .false.
     if (this%num_dims == 2) then
        call this%reference_fe_geo_index%get(key=6,val=dum,stat=istat)
        if (istat == key_found) then
           bst_is_tet_mesh = .true.
        elseif (istat == key_not_found) then
           bst_is_tet_mesh = .false.
           return
        end if
        call this%reference_fe_geo_index%get(key=8,val=dum,stat=istat)
        if (istat == key_found) bst_is_tet_mesh = .false.
     elseif (this%num_dims == 3) then
        call this%reference_fe_geo_index%get(key=14,val=dum,stat=istat)
        if (istat == key_found) then
           bst_is_tet_mesh = .true.
        elseif (istat == key_not_found) then
           bst_is_tet_mesh = .false.
           return
        end if
        call this%reference_fe_geo_index%get(key=20,val=dum,stat=istat)
        if (istat == key_found) then
           bst_is_tet_mesh = .false.
           return
        end if
        call this%reference_fe_geo_index%get(key=26,val=dum,stat=istat)
        if (istat == key_found) then
           bst_is_tet_mesh = .false.
           return
        end if
     end if
     
   end function bst_is_tet_mesh

   function bst_is_hex_mesh ( this ) 
     implicit none
     class(base_static_triangulation_t), intent(in) :: this
     integer(ip) :: dum, istat
     logical :: bst_is_hex_mesh     
     
     bst_is_hex_mesh = .false.
     if (this%num_dims == 2) then
        call this%reference_fe_geo_index%get(key=8,val=dum,stat=istat)
        if (istat == key_found) then
           bst_is_hex_mesh = .true.
        elseif (istat == key_not_found) then
           bst_is_hex_mesh = .false.
           return
        end if
        call this%reference_fe_geo_index%get(key=6,val=dum,stat=istat)
        if (istat == key_found) bst_is_hex_mesh = .false.
     elseif (this%num_dims == 3) then
        call this%reference_fe_geo_index%get(key=26,val=dum,stat=istat)
        if (istat == key_found) then
           bst_is_hex_mesh = .true.
        elseif (istat == key_not_found) then
           bst_is_hex_mesh = .false.
           return
        end if
        call this%reference_fe_geo_index%get(key=20,val=dum,stat=istat)
        if (istat == key_found) then
           bst_is_hex_mesh = .false.
           return
        end if
        call this%reference_fe_geo_index%get(key=14,val=dum,stat=istat)
        if (istat == key_found) then
           bst_is_hex_mesh = .false.
           return
        end if
     end if
     
   end function bst_is_hex_mesh

   function bst_is_mix_mesh ( this ) 
     implicit none
     class(base_static_triangulation_t), intent(in) :: this
     integer(ip) :: dum, istat, ntypes     
     logical :: bst_is_mix_mesh
     
     ntypes = 0
     if (this%num_dims == 2) then
        call this%reference_fe_geo_index%get(key=8,val=dum,stat=istat)
        if (istat == key_found) ntypes = ntypes + 1
        call this%reference_fe_geo_index%get(key=6,val=dum,stat=istat)
        if (istat == key_found) ntypes = ntypes + 1
     elseif (this%num_dims == 3) then
        call this%reference_fe_geo_index%get(key=26,val=dum,stat=istat)
        if (istat == key_found) ntypes = ntypes + 1
        call this%reference_fe_geo_index%get(key=20,val=dum,stat=istat)
        if (istat == key_found) ntypes = ntypes + 1
        call this%reference_fe_geo_index%get(key=14,val=dum,stat=istat)
        if (istat == key_found) ntypes = ntypes + 1
     end if
     bst_is_mix_mesh = ntypes > 1
   end function bst_is_mix_mesh
   
   function bst_is_conforming ( this ) 
     implicit none
     class(base_static_triangulation_t), intent(in) :: this
     logical :: bst_is_conforming
     bst_is_conforming = .true.
   end function bst_is_conforming 
